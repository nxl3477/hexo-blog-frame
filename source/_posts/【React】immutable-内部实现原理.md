---
title: 【React】immutable 内部实现原理
date: 2019-07-03 20:01:04
categories: immutable
tags: immutable
---

## immutable.js
Immutable.js 采用了持久化数据结构（每次修改后我们都会得到一个新的版本，且旧版本可以完好保留），保证每一个对象都是不可变的，任何添加、修改、删除等操作都会生成一个新的对象，且通过结构共享(对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是结构共享)等方式大幅提高性能。


## 原理解读
1. Vector trie 原理是，使用二叉树，将所有值按照顺序，从左到右存放于叶子节点，当需要更新数据
时，只将其更新路径上的节点生成新的对象，没有改变的节点继续共用。
2. Immutable.js 实现了一个hash函数，可以把一个值转换成相应数字。接下来HAMT
3. Hash array maps trie 压缩treeImmutablejs 对于 Map，使用了这种方式优化，并且通过树宽与树高的压缩，形成了文中例图中的效果（10010 10000 聚合成了一个节点，并且移除了同级的空节点）。

![2019-07-03-20-25-37](http://img.nixiaolei.com/2019-07-03-20-25-37.png)

![2019-07-03-20-43-09](http://img.nixiaolei.com/2019-07-03-20-43-09.png)

## 查找原理
可以看到上面那张图一样， 查找 `tea`, 先找到 `t` 再找到`e` ,再往下找到`a`， 根据这个查找路径， 找到对应的值

二进制的查找方式也是这个原理， 如下图所示， 左上角的值与二进制路径互相映射

![2019-07-03-20-54-59](http://img.nixiaolei.com/2019-07-03-20-54-59.png)


## 分区
1. 数字分区（Digit partitioning）指我们把一个 key 作为数字对应到一棵前缀树上。
2. 位分区（Bit Partitioning）数字分区的方法是有点耗时的，在每一层我们都要进行两次除法一次取
模，显然这样并不高效，位分区就是对其的一种优化。位分区是建立在数字分区的基础上的，所有以2的
整数次幂（2，4，8，16，32…）为基数的数字分区前缀树，都可以转为位分区。基于一些位运算相关
的知识，我们就能避免一些耗时的计算。数字分区把 key 拆分成一个个数字，而位分区把 key 分成一组
组 bit。以一个 32 路的前缀树为例，数字分区的方法是把 key 以 32 为基数拆分（实际上就是 32 进
制），而位分区是把它以 5 个 bits 拆分，因为32 = 25，那我们就可以把 32 进制数的每一位看做 5 个二
进制位 。


## bitMap
> bitMap学习链接：https://blog.csdn.net/moakun/article/details/79927791


利用位运算来快速查找计算，  得出结果， immutable 也正是利用了这一点， 在代码逻辑的关键处大量的使用了位运算

## 为什么选择32位
Immutable.js 的 Vector Trie 采用了 32 作为数组的长度，我们解释了由于采用了位分区，该数字只能
是2的整数次幂，所以不能是 31、33 等。但8、16、64等等呢？这是通过实际测试得出的，图中分别是
查找和更新的时间，看上去似乎 8 或 16 更好？考虑到平时的使用中，查找比更新频次高很多，所以
Immutable.js 选择了 32


![2019-07-03-21-36-06](http://img.nixiaolei.com/2019-07-03-21-36-06.png)


## 32位如何处理

immutable 会把32位挨个转换为二进制， 因为 2^5 = 32， 类似如下图， 每一位都会转换为相应的二进制用于快速位运算

![2019-07-03-21-36-54](http://img.nixiaolei.com/2019-07-03-21-36-54.png)


## 核心原理
1. Bitmap 一种数据结构，代表了有限域中的稠集（dense set），每一个元素至少出现一次，没有其他
的数据和元素相关联。在索引，数据压缩等方面有广泛应用。

2. HashArrayMapNode，拥有的子节点数量 ＞16 ，拥有的数组长度为 32
3. BitmapIndexedNode，拥有的子节点数量 ≤16 ，拥有的数组长度与子节点数量一致，经由 bitmap
压缩
4. ValueNode，叶子节点，存储 key 和 value
5. HashCollisionNode的节点去处理发生冲突的键值


## 经典的代码段
```Js
//计算二进制中1的数量
function popCount(x) {
  x -= (x >> 1) & 0x55555555;
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  x = (x + (x >> 4)) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x7f;
}
```