---
title: 面试题集合
date: 2019-03-20 17:40:34
categories: 面试
tags: [面试]
---

## 事件机制

### Promise

#### 题目一: 
```JavaScript
setTimeout(() => {
  console.log(4)
}, 0)
new Promise(resolve => {
  console.log(1)
  setTimeout(() => {
    resolve("done")
    console.log(6)
  }, 0)
  resolve(5)
}).then((res) => {
  // 微任务
  console.log(res)
})
console.log(2)
```

**答案:**
> 1 , 2 , 5 , 4, 6

注意， 没有`done`！


**分析:**
`Promise` 的`resolve`只会触发一次， 因为`Promise`的状态已经被修改为`resolve`

所以第二次的`resolve` 不会触发


#### 题目二:
```JavaScript
setTimeout(() => {
  console.log(4)
}, 0)
new Promise(resolve => {
  console.log(1)
  new Promise(resolve => {
    console.log(7)
    setTimeout(() => {
      resolve("done")
      console.log("aa")
    }, 0)
    resolve(8)
  }).then((res) => {
    console.log(res)
  })
  resolve(5)
}).then((res) => {
  console.log(res)
})
console.log(2)
```

**答案:**
> 1, 7, 2, 8 , 5 , 4 , aa


**分析:**
`Promise`的完成先后还得看谁先挂载了 `then`， 并不是谁先`new`就是谁


























## ES6系列

### async await:
#### 题目一: async 什么原理 ?

**例子:**
```JavaScript
async function  test () {
  let result = await 10 
}
test()
```

经过 Babel 转换
```JavaScript
while (1) {
  switch (_context.prev = _context.next) {
    case 0:
      _context.next = 2;
      return 10;

    case 2:
      result = _context.sent;

    case 3:
    case "end":
      return _context.stop();
  }
```

**分析**
我们可以看到，经过`babel` 转换过的 `async await` 代码中关键的这句， `while`循环， 并且是一个死循环， `babel` 就是这样来模拟 `async await`的， 当`await`返回结果时， `_context.stop`抛出异常退出死循环



#### 题目二: 请问result输出几 ?
```JavaScript
var a = 0
async function  test () {
  let result = a + await 10
  console.log(result)
}
test()
a = a + 1
test()
```
**答案:**
> 10  , 11

**分析:**
1. `await` 后如果是一个常量, 将作为 `Promise.resolve`的结果返回
2. 因为 `async await` 是 `generator`的语法糖， 当执行 `test` 方法时， 变量`a`的值会被锁住

所以第一个结果是`10`， 第二个结果是 `11`






















