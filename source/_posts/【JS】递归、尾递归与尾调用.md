---
title: 【JS】递归、尾递归与尾调用
date: 2019-06-16 19:04:41
categories: JavaScript
tags: [JavaScript, 尾递归, 尾调用]
---


## 尾调用
所谓的尾调用， 尾调用是我们平时实现递归操作的一种方式, 通过在函数末尾调用另一个函数， 来抹除上一个函数的堆栈记录， 可以理解为是一种任务承接的方式

demo:
```js
function f(index, total) {
  if(index-- === 1) {
    return total
  }
  g(index, total + index)
}

function g( index, total ) {
  f( index, total )
}
```



## 尾递归
尾递归和普通递归的区别就是， 尾递归的递归方式是在函数最后一步操作调用自身， 并将本轮计算结果以参数形式传入

demo:
```js
function loop(index, total) {
  if(index-- === 1) {
    return total
  }
  return loop(index, total + index)
}

loop(100, 0)
```

### 尾调用优化

在ES6中， 我们将迎来尾递归优化， 通过尾递归优化， javascript代码在解释成机器码的时候， 将会向while看齐， 也就是说， 同时拥有数学表达能力和`while`的效能。


ES6的“尾调用优化”的原理就是覆盖掉自身的函数执行记录， 也就是将递归变为循环， 只保存一个调用记录，这样就不会发生爆栈的情况了




### 浏览器的实现情况
虽然是ES6的规范， 浏览器也实现了， 但实际上平时使用时“尾调用优化”是默认关闭的。 为什么！因为浏览器不敢开哦。 因为一旦开了尾调用优化， 就等于放弃了存留函数的堆栈信息， 当开发者调错时会十分困难， 找不到正确的堆栈信息， 当然可以利用js的元编程强行开启

### 其他避免爆栈手段
* 使用`蹦床函数`， 将递归拉平
* 直接将递归改写成循环
* 使用元编程强行开启浏览器的“尾递归优化”

















