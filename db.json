{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/my_favicon.ico","path":"images/my_favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/myavatar.jpg","path":"images/myavatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/my_favicon_small.ico","path":"images/my_favicon_small.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bai.js","path":"js/src/bai.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/md5.js","path":"js/src/md5.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/baidu_verify_UCp8DVX1mJ.html","hash":"1862349bcebd44d95e04e440c274368ca2c6e938","modified":1568048266058},{"_id":"source/google0e4fe1e51eb21469.html","hash":"4706a06de6dcf15d319375f5a48263abc9ddb693","modified":1568048266058},{"_id":"source/robots.txt","hash":"ee24edc14442eb670d4262a04792b6582ed112ff","modified":1568048266058},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1568048266077},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1568048266077},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1568048266077},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1568048266077},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1568048266077},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1568048266077},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1568048266077},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1568048266078},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1568048266078},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1568048266078},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1568048266078},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1568048266078},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1568048266078},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1568048266087},{"_id":"themes/next/_config.yml","hash":"087e8780e7e7c6971f96eceff416ba9d23ca1019","modified":1568048266078},{"_id":"source/_posts/CSS如何了解新知识.md","hash":"92c164fa35e2d33f7121c84ec8b0ae07d5655997","modified":1568048266029},{"_id":"source/_posts/JavaScript事件机制.md","hash":"b0495cc90ff940fe8b527d36aebbc489aa303c0f","modified":1568048266029},{"_id":"source/_posts/Js与CSS变量操作.md","hash":"03c9cb6cc4cd228cb0ab6e8aebda304f3b4b8813","modified":1568048266029},{"_id":"source/_posts/TypeScript手册.md","hash":"79a9815ed30b9487c861fe519935afa6668cd2ce","modified":1568048266030},{"_id":"source/_posts/TypeScript语法.md","hash":"2d58c122ac74c260d9835b7c6024145591b82eea","modified":1568048266030},{"_id":"source/_posts/css分层-命名规范.md","hash":"699026ce9ce684e21484dee745e43d9820e700f4","modified":1568048266030},{"_id":"source/_posts/hexo中如何使用本地图片.md","hash":"1c9188b165b00b4ac3008a961ee8193ae41aa452","modified":1568048266030},{"_id":"source/_posts/css预处理与后处理器.md","hash":"339760f450884615404aceff9d39c39e0018fad9","modified":1568048266030},{"_id":"source/_posts/k8s学习笔记.md","hash":"6f933893dbb00f0d2e84110041877d6842e60b65","modified":1568048266030},{"_id":"source/_posts/this的软绑定和硬绑定.md","hash":"cd217e734c85c666ca700f34f8c4c8b315838591","modified":1568048266037},{"_id":"source/_posts/vue-cli3脚手架配置px2rem适配方案.md","hash":"58d2638282aba044a42e9662a16aa54fe96f4b5c","modified":1568048266037},{"_id":"source/_posts/vue的add命令与npm的小区别.md","hash":"64c90b703617bd672039be4ff7ba772961fd296a","modified":1568048266037},{"_id":"source/_posts/vuecli3脚手架环境变量.md","hash":"7184103740363698acc7c14ed1ad1166ebfeb37e","modified":1568048266037},{"_id":"source/_posts/【AOP】面向切面编程.md","hash":"329c519a06e2f23132dbc1134d0ce1cce3edb037","modified":1568048266037},{"_id":"source/_posts/【CSS全景】淘宝造物节H5原理.md","hash":"bc4f7f500320afe0192c0c09136b468af898f79c","modified":1568048266038},{"_id":"source/_posts/【CSS矩阵】你不知道的Css矩阵.md","hash":"de2efc919b6f20f8882a84741b9069b58400f193","modified":1568048266038},{"_id":"source/_posts/【C语言】入门知识.md","hash":"2b4650d2d1c6f0db5231261820a7b4903963f0fe","modified":1568048266038},{"_id":"source/_posts/【JS】MessageChannel消息通道.md","hash":"fe860fc0433e2987667dbf6c1bc4d1b4f8f0a2eb","modified":1568048266038},{"_id":"source/_posts/【JS】Object、Array与Map的比较.md","hash":"72f257d44e2b622f550faa3f2626b8219143b5dd","modified":1568048266038},{"_id":"source/_posts/【JS】Set是如何实现的.md","hash":"d334e2cf4730386ffcc99a3024179d0e403969dc","modified":1568048266038},{"_id":"source/_posts/【JS】什么是AO-VO-GO.md","hash":"bacaff96cbf3486fec5dbc2a352e4fbf8cc59b1a","modified":1568048266038},{"_id":"source/_posts/【JS】V8引擎里for和forEach.md","hash":"8329c40b882591e9322ec220ae8cb6bee093b800","modified":1568048266038},{"_id":"source/_posts/【JS】如何测试Js代码性能.md","hash":"1bdcc63c458433ab0c879af63a343f2810338888","modified":1568048266039},{"_id":"source/_posts/【JS】关于requestIdleCallback函数的作用.md","hash":"eefcd7411eb97e72f96350a740fc7d58242983ce","modified":1568048266039},{"_id":"source/_posts/【JS】递归、尾递归与尾调用.md","hash":"ac1646b14cd7337fb21215bcb1ab94cbad818d1f","modified":1568048266039},{"_id":"source/_posts/【Linux】命令手册.md","hash":"e30cdf1214079489198f10ce295c060b41ca9ad5","modified":1568048266039},{"_id":"source/_posts/【Linux】理解chown命令.md","hash":"1acb30ac5f5f5ade19a627e3ad9824b4452fd5df","modified":1568048266039},{"_id":"source/_posts/【Node】mongose基本使用.md","hash":"d431fcba59dec56463be942aeaf9d1c99099bf0e","modified":1568048266044},{"_id":"source/_posts/【NodeJs】异步IO与EventLoop.md","hash":"2bedea4082b3e59b471d10ff6902be3643ee23d2","modified":1568048266044},{"_id":"source/_posts/【Node】了解koa源码.md","hash":"d34ae407c2169482dcd0335d3d869ea8925bcf62","modified":1568048266044},{"_id":"source/_posts/【PostCss】使用明天的CSS.md","hash":"49e58d072b9c14fd832e2f24a3d13b1299ff8897","modified":1568048266045},{"_id":"source/_posts/【React】Flux架构是什么.md","hash":"99650e4cfdaf9f7fe53ac54662ef0b02e3ec2aea","modified":1568048266045},{"_id":"source/_posts/【React】Fiber架构.md","hash":"4202256658af9ca7b034e17adecf73361fc9bf9e","modified":1568048266045},{"_id":"source/_posts/【React】immutable-内部实现原理.md","hash":"e945bb890f53f83208a58d1a73b2eac27c130a5d","modified":1568048266045},{"_id":"source/_posts/【React】memo为函数组件创造shouldComponentUpdate.md","hash":"2505deb68ae03bb691cec0e01eec8db98a03ae9b","modified":1568048266045},{"_id":"source/_posts/【React】PureComponent解决了什么问题.md","hash":"87609ee2d75f71208dcbd49413fe3609386b6121","modified":1568048266045},{"_id":"source/_posts/【React】react16.6中如何处理异步&&按需加载.md","hash":"f7b95e818d7c7dd07133fd91e3a1e6b88000338d","modified":1568048266045},{"_id":"source/_posts/【React】react16中如何使用ref.md","hash":"bfae69ddbffb009e0e482609e799317868395e5f","modified":1568048266046},{"_id":"source/_posts/【React】react16新增错误处理生命周期.md","hash":"df92ebf60e7b79d6fa09f82a25c9bcadefec0a5e","modified":1568048266046},{"_id":"source/_posts/【React】react、redux与函数式编程.md","hash":"e54ccaa4cba4e826772adce42ae9189b323f24f3","modified":1568048266046},{"_id":"source/_posts/【React】为什么要使用immutableJs.md","hash":"57b5f66cca6eae7aad3f11350c3a4a2777661f64","modified":1568048266046},{"_id":"source/_posts/【React】react生命周期的变化.md","hash":"b6dc08f00b35647a9dd63fae7bbf90086556a7bd","modified":1568048266046},{"_id":"source/_posts/【React】从高阶函数到理解高阶组件.md","hash":"9810c07a5ca65b1bd7ed37846334253045316df7","modified":1568048266046},{"_id":"source/_posts/【React】使用Context避免多层嵌套.md","hash":"b4bf4318bfff173429ac3f824e66b76fb83f93e8","modified":1568048266046},{"_id":"source/_posts/【React】拥抱函数组件的Hooks.md","hash":"ed698962d8aea54be8c6c66c10d16888b4f07d06","modified":1568048266046},{"_id":"source/_posts/【React】革命性的fiber架构.md","hash":"186f5111e5a3ba6d9d81a4e0ec1bcf05abde00f1","modified":1568048266047},{"_id":"source/_posts/【React】高阶用法.md","hash":"1b460c959e00792ad8f3189b3aa5d24cc9d72796","modified":1568048266047},{"_id":"source/_posts/【SSR】nuxt-js体验笔记.md","hash":"37472421288100507591664e95e65e761676e456","modified":1568048266047},{"_id":"source/_posts/【Three】Three-js光源入门之点光源.md","hash":"2b8eebd3f4494166be28701eaf2108731ef1ec01","modified":1568048266047},{"_id":"source/_posts/【Three】Three-js光源入门之环境光.md","hash":"8263951011168a6ed78192dea74cc5aa91f784d4","modified":1568048266047},{"_id":"source/_posts/【Three】Three-js入门之光源.md","hash":"eb302b803a6b3fd9b332fa8582a2c09cbb9e9bf6","modified":1568048266047},{"_id":"source/_posts/【Three】Three-js光源入门之聚光灯.md","hash":"6281872f7a8186382a352cfadba7ebff60c4ea26","modified":1568048266047},{"_id":"source/_posts/【Three】Three-js入门之几何和网格对象.md","hash":"5f1cbf42a697741e1d5f2a0ccd203877f43f8272","modified":1568048266048},{"_id":"source/_posts/【Three】Three-js入门之添加动画.md","hash":"d3175738c9d79ce0ceff355ed7150d54620c8e19","modified":1568048266048},{"_id":"source/_posts/【Three】Three-js入门之相机.md","hash":"9d2365e9d3c70d9c4c40b891e63dd022a23046fb","modified":1568048266049},{"_id":"source/_posts/【Three】Three-js入门之添加材质和灯光.md","hash":"3afdfb0170048d8d70b5fc9234908ae3064752b8","modified":1568048266048},{"_id":"source/_posts/【Three】Three-js入门之绘制三维对象.md","hash":"bed61df148bdf0831e667d1c764875c14cd07939","modified":1568048266049},{"_id":"source/_posts/【Three】Three-js入门学习笔记.md","hash":"6bf28f7f5a1504816f87a84b7acc56fd01217f5b","modified":1568048266049},{"_id":"source/_posts/【canvas】如何处理Retina屏模糊问题.md","hash":"06555882b4e7b429516ff152a73934e13d066e6e","modified":1568048266050},{"_id":"source/_posts/【Vue】源码解析.md","hash":"dcf0bc06725eee14904a3c97e5fd3ec51fd1c063","modified":1568048266050},{"_id":"source/_posts/【css-doodle】css-web-component入门.md","hash":"ed6aad8837c50af632f6310716971248ebe2597c","modified":1568048266050},{"_id":"source/_posts/【imooc】HTML5-CSS3.md","hash":"b2e3950b23e52d130795d13a1e443face6b8258a","modified":1568048266053},{"_id":"source/_posts/【容器】docker命令手册.md","hash":"e6a90f97633bfb438b8b38f9a84ed26a2b94d613","modified":1568048266053},{"_id":"source/_posts/【win10】解决经常性内存爆满100.md","hash":"1d4503b9997a596af88712f0e0b4ba6b90a9bfd2","modified":1568048266053},{"_id":"source/_posts/【imooc】HTML和CSS知识巩固.md","hash":"0bf2d293a00019bb3495190e9601f5666b11462b","modified":1568048266053},{"_id":"source/_posts/【容器】Docker入门教程.md","hash":"3a48d414e0a8e10ae3f4e7f0fa529b0dcb23bd98","modified":1568048266053},{"_id":"source/_posts/【工程化】webpack-编译后文件解析.md","hash":"4dac12b786fb09e0555c769c69c76fc93643e6d1","modified":1568531352853},{"_id":"source/_posts/【容器】搭建第一个docker环境.md","hash":"aec149701caf84ab672b89746fbae082f1da5f39","modified":1568048266054},{"_id":"source/_posts/【工程化】babel简单原理及简单实现.md","hash":"5867be7cf76e9551d08debe8fb5574307128fc22","modified":1568528347591},{"_id":"source/_posts/【数据结构】什么是树.md","hash":"7adf7afbdf6ce8a8e6a5a10667d763cbe575ba7a","modified":1568048266054},{"_id":"source/_posts/【数据结构】什么是图.md","hash":"686340f093083b339231e02bb8af6d95c225abbe","modified":1568048266054},{"_id":"source/_posts/【数据结构】什么是集合.md","hash":"a7c50bca1e7badf9a905afb13142b55b19d7856c","modified":1568048266054},{"_id":"source/_posts/【数据结构】什么是线性表.md","hash":"fbd6b8f90dd6ddc71fa4718a79014626ce0018db","modified":1568048266054},{"_id":"source/_posts/【数据结构】线性表之-串.md","hash":"348cff0e4416496c0b4a1f5c63d7725d467991b1","modified":1568048266054},{"_id":"source/_posts/【数据结构】线性表之'栈'.md","hash":"1a75f4d3dd38b34977a395d10c6169ad3a4c0277","modified":1568048266054},{"_id":"source/_posts/【数据结构】线性表之队列.md","hash":"2f5ad23c310399aef5191fdb8564444c5712ba7d","modified":1568048266055},{"_id":"source/_posts/【工程化】如何编写一个自己的webpack插件.md","hash":"57157f518ab5e3404b566081a5644ceea1d7269f","modified":1568479262283},{"_id":"source/_posts/【数据结构】线性表之链表.md","hash":"99c5bb30cf17710f612360cdd8403fbd2ded2f41","modified":1568048266054},{"_id":"source/_posts/【数据结构】线性表之顺序表.md","hash":"8b45184abf6f0d74204597250ad16bac0fbb4589","modified":1568048266055},{"_id":"source/_posts/【算法】二叉树学习笔记.md","hash":"63a89458d0e0e375771c5d967b7e0682ecfe2cec","modified":1568048266055},{"_id":"source/_posts/【算法】什么是算法.md","hash":"14fd2fabf455d9a85d0ed42c94168b7010336227","modified":1568048266055},{"_id":"source/_posts/【算法】枚举算法基本概念.md","hash":"ff6465c64aefc00ee645a07d2821cf63c5267d1d","modified":1568048266055},{"_id":"source/_posts/【工程化】了解webpack原理.md","hash":"a4173066537d5159f0f9b0d094215dbf42e36dea","modified":1568466548057},{"_id":"source/_posts/【算法】理解Dom-diff.md","hash":"3d37494b4a4ce84ade758599205a8ea75d1efeab","modified":1568048266055},{"_id":"source/_posts/【算法】递归算法.md","hash":"653c2cc86f0d481c13d57b801aef6f97bed17977","modified":1568048266055},{"_id":"source/_posts/【英语学习】基础语法.md","hash":"6bface6ca9c74d0fa47a21c35e6439abdf6f3908","modified":1568048266055},{"_id":"source/_posts/【记录】a-标签下载视频却跳去播放的问题.md","hash":"2aea62ba0689f5267505ff30d5b3325594a5337b","modified":1568117876421},{"_id":"source/_posts/【记录】ios无法播放部分mp4视频怎么办.md","hash":"1f88831dc9116708a7b83128c4c2f8843f09d1d6","modified":1568117646020},{"_id":"source/_posts/【记录】mac-下-ssh-连接gitHub死活不成功的问题.md","hash":"5322130c79649265230178df64bff88440f05ba5","modified":1568117881715},{"_id":"source/_posts/【记录】jest进行单元测试时提示router-view-未注册报错了.md","hash":"8f1e292c798ea37853ca399b7ba327073964a455","modified":1568117869070},{"_id":"source/_posts/【记录】webpack-ts-antd-按需加载无效处理.md","hash":"e937af2a572ba872bb24a3b548d34e89ed264a1b","modified":1568117886758},{"_id":"source/_posts/【记录】vue-cli3-jest单元测试报错（不支持ES6.md","hash":"c24cae7ac5c73314391754b6c5ef6eadaeede302","modified":1568171372883},{"_id":"source/_posts/了解CPU工作原理.md","hash":"3a7b51f322161cbed8b9c1fbe5933e8437487fd9","modified":1568048266056},{"_id":"source/_posts/了解汇编语言.md","hash":"28030321d72bcd1aed4e3e46dbde1f7e44cbf5b6","modified":1568048266056},{"_id":"source/_posts/【记录】记一次优化时间线卡顿处理思路.md","hash":"4706be90158eaf4c17711415e4bef6da9cfc18a9","modified":1568124238676},{"_id":"source/_posts/【记录】工具目录.md","hash":"01131fdd34777ff5bbdd052bc23e9a7ac812cd8d","modified":1568479885649},{"_id":"source/_posts/倪晓磊的个人简历.md","hash":"969eacdc9010462c27bf4962b7eadd2fe3480dda","modified":1568048266056},{"_id":"source/_posts/使用Jenkins构建前端持续集成.md","hash":"763a993c6935b7612b4d5b9e8ef3e88dcd6fbca5","modified":1568048266056},{"_id":"source/_posts/利用CSS混合模式更改图片颜色.md","hash":"166fc0701077ff9751a4d241c7ad48eb1ee8485f","modified":1568048266056},{"_id":"source/_posts/原生实现一个ajax.md","hash":"f279a8fc60e15a7e04e43a8ce5a570a3b7d8e30c","modified":1568048266056},{"_id":"source/_posts/如何在伪元素中使用Iconfont.md","hash":"b9b71442f7a4f876ce295b154dfe10c654b67198","modified":1568048266056},{"_id":"source/_posts/待学书籍.md","hash":"492b5a2175307fd359c07325fc575a397476e6f3","modified":1568048266056},{"_id":"source/_posts/【记录】小程序中如何引入iconfont-字体图标.md","hash":"40086b6111e377b639b54cff12e86c95551bbe1f","modified":1568117621893},{"_id":"source/_posts/手摸手AngularJs入门教程.md","hash":"f256e85a3a46eb74565cef22cb791a4c514db10a","modified":1568048266056},{"_id":"source/_posts/数据结构与算法基础学习笔记.md","hash":"7900e8cb998e3102ea1bbb08bb297b048062bf56","modified":1568048266057},{"_id":"source/_posts/数学基础入门.md","hash":"32444187f97611cb280abdc6d0b5e76b391358e4","modified":1568048266056},{"_id":"source/_posts/模拟实现一个bind.md","hash":"c21a34d50c13e949230e3d9f503da38f36ec6a6a","modified":1568048266057},{"_id":"source/_posts/简单理解微服务架构.md","hash":"696a16da4b57fbdfb3cf1af137323c5acf822e4f","modified":1568048266057},{"_id":"source/_posts/简单理解破解与脱壳.md","hash":"97223d704b936fa3e0ad046bde46f0e2eca1438e","modified":1568048266057},{"_id":"source/_posts/计算机语言的本源与发展.md","hash":"afbffecfcca092c99125ba8a5b2ff82b7a5acd3d","modified":1568048266057},{"_id":"source/_posts/面试题集合.md","hash":"32966f9e6a1771d988c0c7fe6ed363192e1d5089","modified":1568048266057},{"_id":"source/_posts/面向对象设计原则之IOC控制反转.md","hash":"24d085757aaa344add2f4570920647536280b54f","modified":1568048266057},{"_id":"source/_posts/面向对象设计原则之SOLID.md","hash":"37c0ffae507b526274a7e0627a6bc485a0cc8b73","modified":1568048266057},{"_id":"source/_posts/理解Iaas、PaaS、SaaS的区别.md","hash":"68dfdc2ec766d89a51bd440c472ee37b1d6fc9c6","modified":1568048266057},{"_id":"source/categories/index.md","hash":"2de5f843791cc237fc93871d470e69131726404c","modified":1568048266058},{"_id":"source/tags/index.md","hash":"9064f7e5fe91e9cdf9694214e4a62bc1da2d77b9","modified":1568048266058},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1568048266087},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1568048266078},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1568048266079},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1568048266079},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1568048266079},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1568048266079},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1568048266079},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1568048266079},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1568048266079},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1568048266079},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1568048266079},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1568048266080},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1568048266079},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1568048266079},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1568048266080},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1568048266080},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1568048266080},{"_id":"themes/next/layout/_layout.swig","hash":"b7d5d0713c7f9bcfa10e130690020bada3c1c337","modified":1568048266080},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1568048266086},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1568048266086},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1568048266086},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1568048266086},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1568048266086},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1568048266087},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1568048266087},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1568048266129},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1568048266129},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1568048266129},{"_id":"source/_posts/md_imgs/2019-09-14-20-18-39.png","hash":"2df724f2a63f2d81b5509287947f79df13ca1e3f","modified":1568463519464},{"_id":"source/_posts/md_imgs/2019-09-14-20-24-56.png","hash":"30c7da67096e7f11be2c2d8b50db65d03bdc4443","modified":1568463896308},{"_id":"source/_posts/md_imgs/2019-09-14-21-07-23.png","hash":"2d6b0ee9a73dc528bf40bd94afedf400b5acad2f","modified":1568466443341},{"_id":"source/_posts/md_imgs/2019-09-14-22-50-42.png","hash":"4414e6a41a036fe9935ed1e46ab66655b2fe5f0a","modified":1568472642563},{"_id":"source/_posts/md_imgs/2019-09-15-14-23-33.png","hash":"6c7e4d0e33073b56ffe717b0e0b662d4d99570e3","modified":1568528613911},{"_id":"source/_posts/md_imgs/2019-09-15-00-31-59.png","hash":"2237a24e83eece081c21c2fe7561f352f44bfda7","modified":1568478720043},{"_id":"source/_posts/md_imgs/2019-09-15-14-59-15.png","hash":"2555982c8f3727c759d93d46cd4daa6a46b82036","modified":1568530755377},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1568048266087},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568048266102},{"_id":"source/_posts/md_imgs/2019-09-10-20-36-59.png","hash":"41bed9fd3a535b89bce0be2f645cde005375de4c","modified":1568119019463},{"_id":"source/_posts/md_imgs/2019-09-14-19-34-46.png","hash":"4b170f146c61ebb2438a02a2a5d3d2afd3f6ab84","modified":1568460886330},{"_id":"source/_posts/md_imgs/2019-09-14-19-30-43.png","hash":"ca20e9a049a083667267e7f8227005fe0f31a1a6","modified":1568460643753},{"_id":"source/_posts/md_imgs/2019-09-14-23-00-49.png","hash":"2410c810e40fa0fb362ecdbbe01fe880f57c0f39","modified":1568473250112},{"_id":"source/_posts/md_imgs/2019-09-15-14-32-51.png","hash":"6f2ebf06242516133ae7337835721d0b7be2f43f","modified":1568529172038},{"_id":"source/_posts/md_imgs/2019-09-15-14-39-09.png","hash":"d5e19b43bbd5dad76c6a736c0161b820c14e72bd","modified":1568529549874},{"_id":"source/_posts/md_imgs/2019-09-15-14-35-54.png","hash":"2a4679a724abc6ed8a5d79ba99230413024fb4af","modified":1568529355089},{"_id":"source/_posts/md_imgs/2019-09-15-14-26-18.png","hash":"d3172c3f166933ddc65dbd3fb253d3b3ed0f77a4","modified":1568528779171},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1568048266087},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1568048266087},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1568048266087},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1568048266088},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1568048266088},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1568048266088},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1568048266088},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1568048266088},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1568048266088},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1568048266080},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1568048266080},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1568048266080},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1568048266080},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1568048266081},{"_id":"themes/next/layout/_macro/post.swig","hash":"4aa7eda227587e8a33d477c77e7d3ae463c0de18","modified":1568048266080},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"0d1a14a5b99465e015589b709949f7200fc72abe","modified":1568048266081},{"_id":"themes/next/layout/_partials/comments.swig","hash":"c53cdf3d0adfd487b521765957b26a29c6a64608","modified":1568048266081},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1568048266081},{"_id":"themes/next/layout/_partials/footer.swig","hash":"fb1842fd9eed8b38bbd9ffbe02eb4b579e15fb18","modified":1568048266081},{"_id":"themes/next/layout/_partials/head.swig","hash":"d37bbf885e4d52ad81f24842a7803843f860112a","modified":1568048266081},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1568048266081},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1568048266081},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1568048266081},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1568048266082},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1568048266082},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1568048266082},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1568048266083},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1568048266085},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1568048266085},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1568048266085},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1568048266085},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1568048266085},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1568048266085},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1568048266085},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1568048266102},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1568048266102},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1568048266102},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1568048266102},{"_id":"themes/next/source/images/alipay.jpg","hash":"66b14acbff7c07594ab21624b1671ab49deb355f","modified":1568048266102},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1568048266102},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1568048266102},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1568048266103},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1568048266103},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1568048266103},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1568048266103},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1568048266103},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1568048266103},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1568048266103},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1568048266103},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1568048266103},{"_id":"themes/next/source/images/my_favicon.ico","hash":"32d7f41cfc03d1a81346691b4803a3124b7b0b8d","modified":1568048266103},{"_id":"themes/next/source/images/myavatar.jpg","hash":"10545caf74010b6169944a4ff35b84f5ee32c6a2","modified":1568048266104},{"_id":"themes/next/source/images/my_favicon_small.ico","hash":"677e14b2949bd9d9a38bbeaa538fb26792350c17","modified":1568048266103},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1568048266104},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1568048266104},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1568048266104},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1568048266104},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"6bc7e8c08d39c4f18acc22344f5322727160dfe3","modified":1568048266104},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568048266083},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568048266083},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568048266097},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568048266097},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568048266097},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568048266101},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568048266102},{"_id":"source/_posts/md_imgs/2019-09-11-11-08-34.png","hash":"36550b2604c1aed6416925de3abb97f47add378c","modified":1568171314565},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1568048266081},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1568048266081},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1568048266082},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1568048266082},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1568048266082},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1568048266082},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1568048266082},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1568048266082},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1568048266082},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1568048266083},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1568048266082},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1568048266083},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1568048266084},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1568048266084},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1568048266084},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1568048266084},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1568048266084},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"88082e5dcdc11d7f1891a85d177a014549e46139","modified":1568048266084},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"08338cba394ebef11bd9473675237fbb8ba06f04","modified":1568048266084},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1568048266085},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1568048266085},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1568048266085},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1568048266083},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1568048266084},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1568048266084},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1568048266084},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1568048266084},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1568048266086},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1568048266086},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1568048266086},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1568048266086},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1568048266097},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1568048266097},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1568048266101},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1568048266097},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1568048266101},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1568048266097},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1568048266101},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1568048266102},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1568048266109},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1568048266112},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1568048266112},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1568048266113},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1568048266113},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1568048266115},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1568048266115},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1568048266116},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1568048266115},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1568048266117},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1568048266122},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1568048266116},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1568048266117},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1568048266117},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1568048266117},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1568048266123},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1568048266123},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1568048266123},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1568048266123},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1568048266123},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1568048266123},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1568048266128},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1568048266128},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1568048266129},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1568048266104},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1568048266104},{"_id":"themes/next/source/js/src/bai.js","hash":"46561541b1f1d5869ddf6c41d928354e6d8df93b","modified":1568048266104},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1568048266104},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1568048266129},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1568048266129},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1568048266105},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1568048266105},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1568048266105},{"_id":"themes/next/source/js/src/md5.js","hash":"9e95b3d2fad05cd68bbe721bd9fe79e524c47e71","modified":1568048266105},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1568048266105},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1568048266105},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1568048266106},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1568048266106},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1568048266106},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1568048266124},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1568048266124},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1568048266124},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1568048266125},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1568048266125},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1568048266124},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1568048266124},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1568048266125},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1568048266124},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1568048266124},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1568048266124},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1568048266124},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1568048266124},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1568048266124},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1568048266125},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1568048266125},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1568048266125},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1568048266125},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1568048266125},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1568048266125},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1568048266123},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1568048266089},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1568048266085},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1568048266085},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1568048266089},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1568048266089},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1568048266089},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1568048266089},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1568048266094},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1568048266098},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1568048266091},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1568048266098},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1568048266098},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1568048266098},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1568048266098},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1568048266098},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1568048266099},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1568048266099},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1568048266099},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1568048266100},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1568048266100},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1568048266099},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1568048266100},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1568048266101},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1568048266100},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1568048266101},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1568048266101},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1568048266101},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1568048266101},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1568048266096},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1568048266096},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1568048266096},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1568048266096},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1568048266096},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1568048266096},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1568048266097},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1568048266107},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1568048266108},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1568048266108},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1568048266113},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1568048266113},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1568048266113},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1568048266114},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1568048266114},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1568048266114},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1568048266115},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1568048266115},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1568048266115},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1568048266116},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1568048266116},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1568048266118},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1568048266118},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1568048266128},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1568048266105},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1568048266127},{"_id":"source/_posts/md_imgs/2019-09-10-20-52-42.png","hash":"b70115d4364479d6d6cb7fcfd9b3a59336e641e1","modified":1568119962621},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1568048266108},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1568048266117},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1568048266122},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1568048266129},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1568048266090},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1568048266091},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1568048266089},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1568048266090},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1568048266090},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1568048266090},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1568048266090},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1568048266090},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1568048266091},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1568048266089},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1568048266091},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1568048266091},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1568048266091},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1568048266091},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1568048266092},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"c1d001e9932c0ae8ade6ac5a06d184274f20d9ef","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1568048266093},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1568048266094},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1568048266095},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1568048266095},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1568048266099},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1568048266099},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1568048266100},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1568048266106},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1568048266106},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1568048266107},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1568048266107},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1568048266107},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1568048266114},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1568048266114},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1568048266114},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1568048266114},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1568048266114},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1568048266114},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1568048266121},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1568048266120},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1568048266122},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1568048266119},{"_id":"source/_posts/md_imgs/2019-09-15-14-21-44.png","hash":"391828397180a25b4f8f12372a1988cc57da0023","modified":1568528505307},{"_id":"source/_posts/md_imgs/2019-09-15-00-16-21.png","hash":"becf548ea0c8883758f30323c58e833bfc5b86fa","modified":1568477781563},{"_id":"source/_posts/md_imgs/2019-09-14-23-40-14.png","hash":"1a48816a1d9f38060f77e8476a310d9cc1d010e3","modified":1568475614526},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1568048266112},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1568048266127},{"_id":"source/_posts/md_imgs/2019-09-14-23-40-01.png","hash":"1a48816a1d9f38060f77e8476a310d9cc1d010e3","modified":1568475601594},{"_id":"source/_posts/md_imgs/2019-09-14-23-39-43.png","hash":"f398373df8aea90cc664eb38b1de400c8f29431c","modified":1568475584763},{"_id":"source/_posts/md_imgs/2019-09-14-23-39-35.png","hash":"f398373df8aea90cc664eb38b1de400c8f29431c","modified":1568475576594},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1568048266121},{"_id":"source/_posts/md_imgs/2019-09-14-23-39-17.png","hash":"f398373df8aea90cc664eb38b1de400c8f29431c","modified":1568475558744}],"Category":[{"name":"学习技巧","_id":"ck0ksf4ry0004aas60mpqfh19"},{"name":"CSS","_id":"ck0ksf4s10009aas6sf4bxfqb"},{"name":"hexo","_id":"ck0ksf4s8000iaas6akpbet8q"},{"name":"容器技术","_id":"ck0ksf4sd000vaas6he2ob4vt"},{"name":"JavaScript","_id":"ck0ksf4sf0013aas6yi8l4tft"},{"name":"Vue","_id":"ck0ksf4si001daas6zsrdcnxt"},{"name":"编程思想","_id":"ck0ksf4sq0020aas6bv0on24n"},{"name":"C语言","_id":"ck0ksf4ss0028aas6ynfoashn"},{"name":"Linux","_id":"ck0ksf4t0002vaas6iit7fuot"},{"name":"NodeJs","_id":"ck0ksf4t50038aas6l9rzv4dm"},{"name":"React","_id":"ck0ksf4td003qaas6czdemsr3"},{"name":"immutable","_id":"ck0ksf4tg003xaas6txy9k12f"},{"name":"SEO","_id":"ck0ksf4uf006eaas682aplvb3"},{"name":"图形学","_id":"ck0ksf4uh006maas6ps8z9tzn"},{"name":"Canvas","_id":"ck0ksf4ux007xaas6rshpf35s"},{"name":"HTML","_id":"ck0ksf4v00086aas6mxnwtfa0"},{"name":"工程化","_id":"ck0ksf4v4008maas6lksy06kr"},{"name":"数据结构","_id":"ck0ksf4v7008waas6t4969wxj"},{"name":"算法","_id":"ck0ksf4vi00a9aas6qsqf9roh"},{"name":"英语","_id":"ck0ksf4vm00ayaas6y07l5lm2"},{"name":"记录","_id":"ck0ksf4vm00b4aas61eqq98tw"},{"name":"计算机基础","_id":"ck0ksf4vq00braas6oidpkeqw"},{"name":"目录","_id":"ck0ksf4vs00c8aas6wy3drk0y"},{"name":"架构","_id":"ck0ksf4vu00cjaas6l327plt4"},{"name":"面试","_id":"ck0ksf4vw00czaas6482kh5jx"},{"name":"专业术语","_id":"ck0ksf4vw00d5aas6e81zx2te"},{"name":"TypeScript","_id":"ck0ksf4x100gbaas6n7d9fh3b"},{"name":"CI","_id":"ck0ksf4x500gpaas6i3jjby31"}],"Data":[],"Page":[{"_content":"UCp8DVX1mJ","source":"baidu_verify_UCp8DVX1mJ.html","raw":"UCp8DVX1mJ","date":"2019-09-10T12:04:53.636Z","updated":"2019-09-09T16:57:46.058Z","path":"baidu_verify_UCp8DVX1mJ.html","title":"","comments":1,"layout":"page","_id":"ck0ksf4qc0000aas63tsmq1en"},{"_content":"google-site-verification: google0e4fe1e51eb21469.html","source":"google0e4fe1e51eb21469.html","raw":"google-site-verification: google0e4fe1e51eb21469.html","date":"2019-09-10T12:04:53.634Z","updated":"2019-09-09T16:57:46.058Z","path":"google0e4fe1e51eb21469.html","title":"","comments":1,"layout":"page","_id":"ck0ksf4qy0001aas6v6aofl1g"},{"title":"分类","date":"2019-03-15T15:34:34.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-03-15 23:34:34\ntype: \"categories\"   #这部分是新添加的\n---\n","updated":"2019-09-09T16:57:46.058Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck0ksf4wy00g6aas6muvpw10s"},{"title":"标签","date":"2019-03-15T13:54:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-03-15 21:54:26\ntype: \"tags\" #新添加的内容\n---\n","updated":"2019-09-09T16:57:46.058Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck0ksf4wz00g8aas6l3jr3ipv"}],"Post":[{"title":"CSS如何了解新知识","date":"2019-03-16T08:56:22.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n平时闲着无聊的时候多去看看MDN或者一些国外的网站， 多试试一些新特性， 说不定就会有新的发现\n\n并且还可以尝试着参与MDN的文章翻译及国外优质技术文章\n\n\n* MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference \n","source":"_posts/CSS如何了解新知识.md","raw":"---\ntitle: CSS如何了解新知识\ndate: 2019-03-16 16:56:22\ncategories: 学习技巧\ntags: [学习技巧, 学习渠道, css]\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n平时闲着无聊的时候多去看看MDN或者一些国外的网站， 多试试一些新特性， 说不定就会有新的发现\n\n并且还可以尝试着参与MDN的文章翻译及国外优质技术文章\n\n\n* MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference \n","slug":"CSS如何了解新知识","published":1,"updated":"2019-09-09T16:57:46.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4rt0002aas6ddsw20fg"},{"title":"Js与CSS变量操作","date":"2019-03-16T09:47:07.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\n\n就目前来说CSS变量已经不是什么新鲜的东西了， 渐渐的我们可以在浏览器中尝试使用它， 和SCSS、 LESS 等预处理器不同的是， CSS的变量机制是浏览器天生支持的， 并且浏览器还对其做了优化， 减少了我们使用JS 去操作CSS变量造成的重绘和重排\n\n一起来看看如何操作吧~\n> 变量虽好， 不可滥用哦\n\n### 定义一个简单的变量\n```CSS\n/* 定义css 变量 */\n:root {\n  --backgroundColor: pink;\n}\n\nbody {\n  background-color: var(--backgroundColor);\n}\n```\n\n### 创建一个按钮\n```HTML\n<body>\n  <button id=\"btn\">点我改变背景</button>\n</body>\n```\n\n### 获取root元素并绑定按钮的点击事件\n```JavaScript\n<script>\nvar root = document.documentElement\n\nbtn.onclick = function() {\n  // 将变量修改为天蓝色\n  root.style.setProperty('--backgroundColor', 'skyblue')\n}\n</script>\n```\n\n\n### 结果对比\n\n点击前\n![按钮点击前](http://img.nixiaolei.com/2019-03-16-17-52-45.png)\n\n按钮点击后\n![按钮点击后](http://img.nixiaolei.com/2019-03-16-17-53-39.png)\n\n\n\n非常Nice~\n\n\n利用这个特性实现更多的可能吧！","source":"_posts/Js与CSS变量操作.md","raw":"---\ntitle: Js与CSS变量操作\ndate: 2019-03-16 17:47:07\ncategories: CSS\ntags: [JavaScript, css]\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\n\n就目前来说CSS变量已经不是什么新鲜的东西了， 渐渐的我们可以在浏览器中尝试使用它， 和SCSS、 LESS 等预处理器不同的是， CSS的变量机制是浏览器天生支持的， 并且浏览器还对其做了优化， 减少了我们使用JS 去操作CSS变量造成的重绘和重排\n\n一起来看看如何操作吧~\n> 变量虽好， 不可滥用哦\n\n### 定义一个简单的变量\n```CSS\n/* 定义css 变量 */\n:root {\n  --backgroundColor: pink;\n}\n\nbody {\n  background-color: var(--backgroundColor);\n}\n```\n\n### 创建一个按钮\n```HTML\n<body>\n  <button id=\"btn\">点我改变背景</button>\n</body>\n```\n\n### 获取root元素并绑定按钮的点击事件\n```JavaScript\n<script>\nvar root = document.documentElement\n\nbtn.onclick = function() {\n  // 将变量修改为天蓝色\n  root.style.setProperty('--backgroundColor', 'skyblue')\n}\n</script>\n```\n\n\n### 结果对比\n\n点击前\n![按钮点击前](http://img.nixiaolei.com/2019-03-16-17-52-45.png)\n\n按钮点击后\n![按钮点击后](http://img.nixiaolei.com/2019-03-16-17-53-39.png)\n\n\n\n非常Nice~\n\n\n利用这个特性实现更多的可能吧！","slug":"Js与CSS变量操作","published":1,"updated":"2019-09-09T16:57:46.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4rw0003aas6mruvsvmz"},{"title":"css分层&命名规范","date":"2019-03-16T15:32:55.000Z","_content":"\n为什么要分层? \n\n* CSS有语义化的命名约定和CSS层的分离， 将有助于它的可扩展性， 性能的提高和代码的组织管理。\n* 避免大量的样式、 覆盖、 权重和很多！important, 分好层可以让团队命名统一规范， 方便维护。\n* 有责任感地去命名你的选择器\n\n\n有哪些分层理论? \n* SMACSS\n* BEM\n* SUIT\n* ACSS\n* ITCSS\n\n\n\n## BEM\n\nBEM和SMACCS非常类似， 主要用来如何给项目命名。一个简单命名更容易让别人一起工作。 比如选项卡导航是一个块(Block)， 这个块里的元素是其中标签之一（Element）, 而当前选项卡是一个修饰状态( Modifier )\n\n* block - 代表了更高级别的抽象或组件\n* block__element - 代表.block的后代， 用于形成一个完整的.block的整体。\n* block--modifier - 代表.block 的不同状态或不同版本。\n* 修饰符使用的是_, 子模块使用的是__符号。 ( 不同一个-的原因是因为CSS单词连接 )\n\n```HTML\n  <!-- container 是大容器 -->\n  <div class=\"container\">\n    <div class=\"menu\">\n      <div class=\"menu--item menu--item__active\">首页</div>\n      <div class=\"menu--item\">新闻</div>\n      <div class=\"menu--item\">消息</div>\n    </div>\n  </div>\n```","source":"_posts/css分层-命名规范.md","raw":"---\ntitle: css分层&命名规范\ndate: 2019-03-16 23:32:55\ncategories: CSS\ntags: [css, 命名规范]\n---\n\n为什么要分层? \n\n* CSS有语义化的命名约定和CSS层的分离， 将有助于它的可扩展性， 性能的提高和代码的组织管理。\n* 避免大量的样式、 覆盖、 权重和很多！important, 分好层可以让团队命名统一规范， 方便维护。\n* 有责任感地去命名你的选择器\n\n\n有哪些分层理论? \n* SMACSS\n* BEM\n* SUIT\n* ACSS\n* ITCSS\n\n\n\n## BEM\n\nBEM和SMACCS非常类似， 主要用来如何给项目命名。一个简单命名更容易让别人一起工作。 比如选项卡导航是一个块(Block)， 这个块里的元素是其中标签之一（Element）, 而当前选项卡是一个修饰状态( Modifier )\n\n* block - 代表了更高级别的抽象或组件\n* block__element - 代表.block的后代， 用于形成一个完整的.block的整体。\n* block--modifier - 代表.block 的不同状态或不同版本。\n* 修饰符使用的是_, 子模块使用的是__符号。 ( 不同一个-的原因是因为CSS单词连接 )\n\n```HTML\n  <!-- container 是大容器 -->\n  <div class=\"container\">\n    <div class=\"menu\">\n      <div class=\"menu--item menu--item__active\">首页</div>\n      <div class=\"menu--item\">新闻</div>\n      <div class=\"menu--item\">消息</div>\n    </div>\n  </div>\n```","slug":"css分层-命名规范","published":1,"updated":"2019-09-09T16:57:46.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4rz0006aas6wnut34hb"},{"title":"hexo中如何使用本地图片","date":"2019-03-16T03:20:19.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\n首先需要修改`_config.yml`配置文件`post_asset_folder`项为`true`\n\n使用命令创建博客\n```\nhexo new 你的文章名称\n```\n\n他会生成`.md`文件及一个对应的文件夹， 我们将图片放到该文件夹中\n\n\n\n## 方法一\n\n在文章中这样插入图片\n```\n{% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %}\n```\n\n效果如下:\n\n![皮卡皮卡](http://img.nixiaolei.com/pika.png)\n\n\n\n\n\n## 方法二\n> 这个方法在首页无法正常预览图片\n\n\n安装一下这个插件\n\n```shell\nnpm install hexo-asset-image --save\n```\n\n\n在文章中这样插入图片\n```\n![这是一张图片](xxxx.png)\n```\n\n\n效果如下:\n\n![皮卡皮卡](http://img.nixiaolei.com/pika.png)\n\n\n\n参考文献\n> http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/","source":"_posts/hexo中如何使用本地图片.md","raw":"---\ntitle: hexo中如何使用本地图片\ndate: 2019-03-16 11:20:19\ncategories: hexo\ntags: hexo\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\n首先需要修改`_config.yml`配置文件`post_asset_folder`项为`true`\n\n使用命令创建博客\n```\nhexo new 你的文章名称\n```\n\n他会生成`.md`文件及一个对应的文件夹， 我们将图片放到该文件夹中\n\n\n\n## 方法一\n\n在文章中这样插入图片\n```\n{% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %}\n```\n\n效果如下:\n\n![皮卡皮卡](http://img.nixiaolei.com/pika.png)\n\n\n\n\n\n## 方法二\n> 这个方法在首页无法正常预览图片\n\n\n安装一下这个插件\n\n```shell\nnpm install hexo-asset-image --save\n```\n\n\n在文章中这样插入图片\n```\n![这是一张图片](xxxx.png)\n```\n\n\n效果如下:\n\n![皮卡皮卡](http://img.nixiaolei.com/pika.png)\n\n\n\n参考文献\n> http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/","slug":"hexo中如何使用本地图片","published":1,"updated":"2019-09-09T16:57:46.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4s00007aas6iwvwnf0i"},{"title":"css预处理与后处理器","date":"2019-03-16T04:20:43.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n预处理器在前两年是非常流行的技术， 但是这两年发展的却不怎么有起色， 因为人们渐渐发先即使代码经过了预处理的的编译， 还要经过后处理， 并且PostCss 的崛起拥有了预处理器的功能， 可以完美代替预处理的工作， 并且可以做到让人们使用下一个版本的css\n\n一旦预处理器阶段代码出现污染，预处理器的事就算是白干了， 不如直接交给后处理器，  所以使用预处理器的意义越来越小了\n\n## 预处理器具有的能力\n* 变量\n* 混合(Mixin) Extend\n* 嵌套规则\n* 运算\n* 函数\n* Namespaces & Accessors (命名空间和访问器)\n* scope\n* 注释\n\n\n## 后处理器的能力\n\n* CSS 压缩 CLEAN-CSS\n* 自动添加浏览器前缀 Autoprefixer\n* CSS更加美观排序 CSScomb\n* Rework取代stylus 后处理器发热\n* 前后通吃的 PostCss\n\n\n\n\n\n## 他们是如何处理的CSS\n\n### 预处理器\n\n预处理器， 如： `sass` 它会先将他的语法转换成 AST--抽象语法树（Abstract Syntax Tree ）, AST是程序的一种中间表示形式， 然后遍历 AST 这棵树， 将对应想要的结果生成为CSS \n\n### PostCss\n\nPostCss 改变了之前对CSS的处理流程， 它提供了一套插件的机制， 对于PostCss来说，自己是一套空的工程，它为插件提供了CSS数据， 根据配置的不同插件， 产生不同的功能\n\n![PostCss处理流程](http://img.nixiaolei.com/2019-03-16-13-23-52.png)\n\n","source":"_posts/css预处理与后处理器.md","raw":"---\ntitle: css预处理与后处理器\ndate: 2019-03-16 12:20:43\ncategories: CSS\ntags: [css, PostCss]\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n预处理器在前两年是非常流行的技术， 但是这两年发展的却不怎么有起色， 因为人们渐渐发先即使代码经过了预处理的的编译， 还要经过后处理， 并且PostCss 的崛起拥有了预处理器的功能， 可以完美代替预处理的工作， 并且可以做到让人们使用下一个版本的css\n\n一旦预处理器阶段代码出现污染，预处理器的事就算是白干了， 不如直接交给后处理器，  所以使用预处理器的意义越来越小了\n\n## 预处理器具有的能力\n* 变量\n* 混合(Mixin) Extend\n* 嵌套规则\n* 运算\n* 函数\n* Namespaces & Accessors (命名空间和访问器)\n* scope\n* 注释\n\n\n## 后处理器的能力\n\n* CSS 压缩 CLEAN-CSS\n* 自动添加浏览器前缀 Autoprefixer\n* CSS更加美观排序 CSScomb\n* Rework取代stylus 后处理器发热\n* 前后通吃的 PostCss\n\n\n\n\n\n## 他们是如何处理的CSS\n\n### 预处理器\n\n预处理器， 如： `sass` 它会先将他的语法转换成 AST--抽象语法树（Abstract Syntax Tree ）, AST是程序的一种中间表示形式， 然后遍历 AST 这棵树， 将对应想要的结果生成为CSS \n\n### PostCss\n\nPostCss 改变了之前对CSS的处理流程， 它提供了一套插件的机制， 对于PostCss来说，自己是一套空的工程，它为插件提供了CSS数据， 根据配置的不同插件， 产生不同的功能\n\n![PostCss处理流程](http://img.nixiaolei.com/2019-03-16-13-23-52.png)\n\n","slug":"css预处理与后处理器","published":1,"updated":"2019-09-09T16:57:46.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4s10008aas61n3oqry5"},{"title":"k8s学习笔记","date":"2019-04-09T04:13:11.000Z","_content":"\n## 什么是K8s\n* Kubernetes，因为首尾字母中间有8个字符，所以被简写成 K8s。\n* K8s 是底层资源与容器间的一个抽象层，如果和单机架构类比，可以算作是一个分布式时代的 Linux。\n* K8s 是 Google 开源的容器集群管理系统。在 Docker 技术的基础上，为容器化的应用提供`部署运行`、`资源调度`、`服务发现`和`动态伸缩`等一系列完整功能，提高了大规模容器集群管理的便捷性。\n\n\n## K8S的特点\n* k8s是一个管理容器的工具，也是管理应用整个生命周期的一个工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，而且可以做到`故障自愈`。\n* 可移植：支持公有云，私有云，混合云；\n* 可扩展：模块化，热插拨，可组合；\n* 自愈：自动替换，自动重启，自动复制，自动扩展。\n\n> 故障自愈场景比如机房工作人员误操作将某一排服务器断电了， k8s就会认为是故障， 自动扩充备用服务器\n\n## K8S的管理步骤\n在k8s进行管理应用的时候，基本步骤是：\n* 创建集群\n* 部署应用\n* 发布应用\n* 扩展应用\n* 更新应用\n\n## K8S的架构结构\n\n* 生态系统\n  * 外部生态（k8s运行过程中产出的来判断，如：日志、监控、配置功能、自动化发布、工作流）\n  * 内部生态（系统本身所依赖的东西， 如：镜像管理、镜像仓库、集群配置管理）\n* 接口层\n  * 用于开发和管理生态系统层\n* 管理层\n  * 系统层面的调度，比如：自动扩展， 监视、资源状态\n* 应用层\n  * 部署及路由\n    * 处理有状态应用和无状态应用\n    * 路由根据内部的`dns`服务器\n* 核心层\n  * k8s的核心功能， 提供程序内部接口\n* 核心模块及插件\n\n![k8s架构结构](http://img.nixiaolei.com/2019-04-13-13-48-43.png)\n\n\nk8s是和`TCP/IP`协议很像都是不允许跨层的， 当生态系统层的功能不够使用时， 你只能通过接口层来开发，不能使用更下层的东西了\n\n\n\n## k8s相关概念\n* **主机（Master）**：用于控制 `Kubernetes` 节点的计算机。所有任务分配都来自于此。\n* **节点（Node）**：执行请求和分配任务的计算机。由 `Kubernetes` 主机负责对节点进行控制。\n* **容器集（Pod）**：部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将`网络`和`存储`从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。\n* **复制控制器（Replication controller）**： 用于控制应在集群某处运行的完全相同的容器集副本数量。\n* **服务（Service）**：服务可将工作定义与容器集分离。`Kubernetes` 服务代理会自动将服务请求分配到正确的容器集——无论这个容器集会移到集群中的哪个位置，即使它已被替换。\n* **Kubelet**： 这是一个在节点上运行的服务，可读取容器清单，确保指定的容器启动并运行。\n* **kubectl**： `Kubernetes` 的命令行配置工具\n\n> 如果数据库安装于容器内部， 则在数据膨胀后，想要升级数据库就变得十分的困难， 容器集将他从容器中抽象出来便于移动管理容器\n\n## k8s整体流程\n\n* 容器间都由`Master`统一管理， 一个容器想知道另一个容器的服务， 就必须询问`master`, 由`master`引导调度 \n* `Linux` 的`etc`相当于`window`的注册表, `Linux`中的配置文件和`window`不一样， `window`是集中管理 ，`Linux`是分散管理,  `etcd`就是为了解决多集群时配置文件难以维护的问题\n\n![k8s架构结构](http://img.nixiaolei.com/2019-04-13-14-57-25.png)\n\n\n\n\n\n\n\n## 安装K8S\n\n在`Linux`下安装单机版的集群环境\n以root身份执行以下操作：\n\n### 1. **关闭`Linux`防火墙**\n> 如果不关闭可能会在`SELinux` 安全模块上出问题\n\n```shell\nsystemctl stop firewalld\n\nsystemctl disable firewalld\n```\n### 2. **安装`Kubernetes`和依赖组件`etcd`**\n\n```shell\nyum install -y etcd kubernetes\n```\n\n### 3. **修改配置**\n> docker 中的 `SElinux`安全模块也要关闭\n\n* Docker配置文件/etc/sysconfig/docker, OPTIONS='--selinux-enabled=false --insecure-registry gcr.io'\n* Kubernetes apiservce配置文件/etc/kubernetes/apiserver,把--admission-control参数中的ServiceAccount删除\n\n\n### 4. **按顺序启动所有的服务**\n* 提供配置存储: `systemctl start etcd`\n* k8s node的重要服务: `systemctl start docker`\n* 提供客户端接口: `systemctl start kube-apiserver`\n* systemctl start kube-controller-manager\n* 提供管理功能： `systemctl start kube-scheduler`\n* 提供pod功能: `systemctl start kubelet`\n* 提供路由请求: `systemctl start kube-proxy`\n\n\n## K8S相关资源\n1、官网\n> https://kubernetes.io\n\n2、Chart 应用仓库\n> https://hub.kubeapps.com/\n\n3、中文手册\n> https://www.kubernetes.org.cn/docs","source":"_posts/k8s学习笔记.md","raw":"---\ntitle: k8s学习笔记\ndate: 2019-04-09 12:13:11\ncategories: 容器技术\ntags: [Kubernetes, 容器技术]\n---\n\n## 什么是K8s\n* Kubernetes，因为首尾字母中间有8个字符，所以被简写成 K8s。\n* K8s 是底层资源与容器间的一个抽象层，如果和单机架构类比，可以算作是一个分布式时代的 Linux。\n* K8s 是 Google 开源的容器集群管理系统。在 Docker 技术的基础上，为容器化的应用提供`部署运行`、`资源调度`、`服务发现`和`动态伸缩`等一系列完整功能，提高了大规模容器集群管理的便捷性。\n\n\n## K8S的特点\n* k8s是一个管理容器的工具，也是管理应用整个生命周期的一个工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，而且可以做到`故障自愈`。\n* 可移植：支持公有云，私有云，混合云；\n* 可扩展：模块化，热插拨，可组合；\n* 自愈：自动替换，自动重启，自动复制，自动扩展。\n\n> 故障自愈场景比如机房工作人员误操作将某一排服务器断电了， k8s就会认为是故障， 自动扩充备用服务器\n\n## K8S的管理步骤\n在k8s进行管理应用的时候，基本步骤是：\n* 创建集群\n* 部署应用\n* 发布应用\n* 扩展应用\n* 更新应用\n\n## K8S的架构结构\n\n* 生态系统\n  * 外部生态（k8s运行过程中产出的来判断，如：日志、监控、配置功能、自动化发布、工作流）\n  * 内部生态（系统本身所依赖的东西， 如：镜像管理、镜像仓库、集群配置管理）\n* 接口层\n  * 用于开发和管理生态系统层\n* 管理层\n  * 系统层面的调度，比如：自动扩展， 监视、资源状态\n* 应用层\n  * 部署及路由\n    * 处理有状态应用和无状态应用\n    * 路由根据内部的`dns`服务器\n* 核心层\n  * k8s的核心功能， 提供程序内部接口\n* 核心模块及插件\n\n![k8s架构结构](http://img.nixiaolei.com/2019-04-13-13-48-43.png)\n\n\nk8s是和`TCP/IP`协议很像都是不允许跨层的， 当生态系统层的功能不够使用时， 你只能通过接口层来开发，不能使用更下层的东西了\n\n\n\n## k8s相关概念\n* **主机（Master）**：用于控制 `Kubernetes` 节点的计算机。所有任务分配都来自于此。\n* **节点（Node）**：执行请求和分配任务的计算机。由 `Kubernetes` 主机负责对节点进行控制。\n* **容器集（Pod）**：部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将`网络`和`存储`从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。\n* **复制控制器（Replication controller）**： 用于控制应在集群某处运行的完全相同的容器集副本数量。\n* **服务（Service）**：服务可将工作定义与容器集分离。`Kubernetes` 服务代理会自动将服务请求分配到正确的容器集——无论这个容器集会移到集群中的哪个位置，即使它已被替换。\n* **Kubelet**： 这是一个在节点上运行的服务，可读取容器清单，确保指定的容器启动并运行。\n* **kubectl**： `Kubernetes` 的命令行配置工具\n\n> 如果数据库安装于容器内部， 则在数据膨胀后，想要升级数据库就变得十分的困难， 容器集将他从容器中抽象出来便于移动管理容器\n\n## k8s整体流程\n\n* 容器间都由`Master`统一管理， 一个容器想知道另一个容器的服务， 就必须询问`master`, 由`master`引导调度 \n* `Linux` 的`etc`相当于`window`的注册表, `Linux`中的配置文件和`window`不一样， `window`是集中管理 ，`Linux`是分散管理,  `etcd`就是为了解决多集群时配置文件难以维护的问题\n\n![k8s架构结构](http://img.nixiaolei.com/2019-04-13-14-57-25.png)\n\n\n\n\n\n\n\n## 安装K8S\n\n在`Linux`下安装单机版的集群环境\n以root身份执行以下操作：\n\n### 1. **关闭`Linux`防火墙**\n> 如果不关闭可能会在`SELinux` 安全模块上出问题\n\n```shell\nsystemctl stop firewalld\n\nsystemctl disable firewalld\n```\n### 2. **安装`Kubernetes`和依赖组件`etcd`**\n\n```shell\nyum install -y etcd kubernetes\n```\n\n### 3. **修改配置**\n> docker 中的 `SElinux`安全模块也要关闭\n\n* Docker配置文件/etc/sysconfig/docker, OPTIONS='--selinux-enabled=false --insecure-registry gcr.io'\n* Kubernetes apiservce配置文件/etc/kubernetes/apiserver,把--admission-control参数中的ServiceAccount删除\n\n\n### 4. **按顺序启动所有的服务**\n* 提供配置存储: `systemctl start etcd`\n* k8s node的重要服务: `systemctl start docker`\n* 提供客户端接口: `systemctl start kube-apiserver`\n* systemctl start kube-controller-manager\n* 提供管理功能： `systemctl start kube-scheduler`\n* 提供pod功能: `systemctl start kubelet`\n* 提供路由请求: `systemctl start kube-proxy`\n\n\n## K8S相关资源\n1、官网\n> https://kubernetes.io\n\n2、Chart 应用仓库\n> https://hub.kubeapps.com/\n\n3、中文手册\n> https://www.kubernetes.org.cn/docs","slug":"k8s学习笔记","published":1,"updated":"2019-09-09T16:57:46.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4s2000baas68tawhxbj"},{"title":"this的软绑定和硬绑定","date":"2019-03-30T06:11:56.000Z","_content":"\n被调用的函数示例\n```JavaScript\nfunction fn() {\n  // 如果严格模式， \"use strict\"加在此处\n  console.log(this)\n}\n```\n\n## 软绑定\n```JavaScript\nfn() // window\n```\n\"use strict\" 严格模式的软绑定\n\n```JavaScript\nfn()  // undefined\n```\n\n## 硬绑定\n```JavaScript\nfn.apply({},['a'])  // {}\n```\n\n忽略硬绑定， 使用软绑定\n```JavaScript\nfn.apply(null,['a'])  // window\n```\n\n\"use strict\" 严格模式\n```JavaScript\nfn.apply({},['a'])  // {}\nfn.apply(null,['a'])  // null\n```\n\n\n\n\n\n","source":"_posts/this的软绑定和硬绑定.md","raw":"---\ntitle: this的软绑定和硬绑定\ndate: 2019-03-30 14:11:56\ncategories: JavaScript\ntags: JavaScript\n---\n\n被调用的函数示例\n```JavaScript\nfunction fn() {\n  // 如果严格模式， \"use strict\"加在此处\n  console.log(this)\n}\n```\n\n## 软绑定\n```JavaScript\nfn() // window\n```\n\"use strict\" 严格模式的软绑定\n\n```JavaScript\nfn()  // undefined\n```\n\n## 硬绑定\n```JavaScript\nfn.apply({},['a'])  // {}\n```\n\n忽略硬绑定， 使用软绑定\n```JavaScript\nfn.apply(null,['a'])  // window\n```\n\n\"use strict\" 严格模式\n```JavaScript\nfn.apply({},['a'])  // {}\nfn.apply(null,['a'])  // null\n```\n\n\n\n\n\n","slug":"this的软绑定和硬绑定","published":1,"updated":"2019-09-09T16:57:46.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4s3000caas6ydookfif"},{"title":"vue-cli3脚手架配置px2rem适配方案","date":"2019-04-24T06:26:51.000Z","_content":"\n## 安装\n```\nnpm i lib-flexible --save\nnpm install px2rem-loader\n```\n\n## 引入\n> main.js\n\n```\nimport 'lib-flexible/flexible'\n```\n> index.html\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n```\n\n\n## 根目录新建 vue.config.js 文件\n> 复制如下代码， 重启， 搞定\n\n```\n// vue.config.js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule('css')\n        .test(/\\.css$/)\n        .oneOf('vue')\n        .resourceQuery(/\\?vue/)\n        .use('px2rem')\n          .loader('px2rem-loader')\n          .options({\n            remUnit: 75\n          })\n  }\n}\n```\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue-cli3脚手架配置px2rem适配方案.md","raw":"---\ntitle: vue-cli3脚手架配置px2rem适配方案\ndate: 2019-04-24 14:26:51\ncategories: Vue\ntags: [适配, Vue]\n---\n\n## 安装\n```\nnpm i lib-flexible --save\nnpm install px2rem-loader\n```\n\n## 引入\n> main.js\n\n```\nimport 'lib-flexible/flexible'\n```\n> index.html\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n```\n\n\n## 根目录新建 vue.config.js 文件\n> 复制如下代码， 重启， 搞定\n\n```\n// vue.config.js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule('css')\n        .test(/\\.css$/)\n        .oneOf('vue')\n        .resourceQuery(/\\?vue/)\n        .use('px2rem')\n          .loader('px2rem-loader')\n          .options({\n            remUnit: 75\n          })\n  }\n}\n```\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vue-cli3脚手架配置px2rem适配方案","published":1,"updated":"2019-09-09T16:57:46.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4s6000gaas6j2dcog4k"},{"title":"vue的add命令与npm的小区别","date":"2019-04-24T06:42:25.000Z","_content":"\n## add\n如果你下载的库, 特别是 Ui 库, 希望对脚手架结构产生影响,\n\n那就选择 \n> vue add xxx\n\n## npm\n如果不希望对脚手架结构产生影响, 只是单纯的使用, 比如 axios 这个插件\n那就选择 \n> npm install xxx\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue的add命令与npm的小区别.md","raw":"---\ntitle: vue的add命令与npm的小区别\ndate: 2019-04-24 14:42:25\ncategories: Vue\ntags: Vue\n---\n\n## add\n如果你下载的库, 特别是 Ui 库, 希望对脚手架结构产生影响,\n\n那就选择 \n> vue add xxx\n\n## npm\n如果不希望对脚手架结构产生影响, 只是单纯的使用, 比如 axios 这个插件\n那就选择 \n> npm install xxx\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vue的add命令与npm的小区别","published":1,"updated":"2019-09-09T16:57:46.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4s7000haas6g99q9ywe"},{"title":"vuecli3脚手架环境变量","date":"2019-04-24T06:44:02.000Z","_content":"\n## 环境变量\n> 环境变量, 在开发和生产环境中会经常使用到\n\n### 举一个例子\n> 在开发过程中我们使用一个本地的接口      \n> 但是在我们打包上线的时候, 我们会使用线上的接口      \n> 这时候我们就可以通过环境变量来配置\n\n\n### 如何创建环境变量\n> 进入脚手架根目录 , 新建一个 .env 文件  , 这就是一个环境变量文件     \n\n**.env**              优先级最低的配置文件, 两种环境都可以用     \n**.env.development**  开发环境, 时优先使用的环境变量     \n**.env.production**   生产环节, 打包时使用的环境变量     \n\n\n#### 环境变量语法\n> VUE_APP_衔接上一个名字='你的变量'\n\n如: \n> VUE_APP_URL='https://baidu.com'\n\n\n\n### 如何在组件中获取环境变量\n> process.env.VUE_APP_URL     \n> 然后挂载到当前组件的data 上 ,如下\n\n```\ndata(){\n    return {\n        url: process.env.VUE_APP_URL\n    }\n}\n\n```\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vuecli3脚手架环境变量.md","raw":"---\ntitle: vuecli3脚手架环境变量\ndate: 2019-04-24 14:44:02\ncategories: Vue\ntags: Vue\n---\n\n## 环境变量\n> 环境变量, 在开发和生产环境中会经常使用到\n\n### 举一个例子\n> 在开发过程中我们使用一个本地的接口      \n> 但是在我们打包上线的时候, 我们会使用线上的接口      \n> 这时候我们就可以通过环境变量来配置\n\n\n### 如何创建环境变量\n> 进入脚手架根目录 , 新建一个 .env 文件  , 这就是一个环境变量文件     \n\n**.env**              优先级最低的配置文件, 两种环境都可以用     \n**.env.development**  开发环境, 时优先使用的环境变量     \n**.env.production**   生产环节, 打包时使用的环境变量     \n\n\n#### 环境变量语法\n> VUE_APP_衔接上一个名字='你的变量'\n\n如: \n> VUE_APP_URL='https://baidu.com'\n\n\n\n### 如何在组件中获取环境变量\n> process.env.VUE_APP_URL     \n> 然后挂载到当前组件的data 上 ,如下\n\n```\ndata(){\n    return {\n        url: process.env.VUE_APP_URL\n    }\n}\n\n```\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vuecli3脚手架环境变量","published":1,"updated":"2019-09-09T16:57:46.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4s9000laas6s8scbm05"},{"title":"【AOP】面向切面编程","date":"2019-03-24T05:53:14.000Z","_content":"\n> Aspect Oriented Programming\n\n面向切面编程（aop）是对面向对象编程（oop）的补充\n\n## 面向切面编程\n\n在软件业， AOP为 `Aspect Oriented Programming` 的缩写， 意为: 面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续， 是软件开发中的一个热点， 也是Spring 框架中的一个重要内容， 是函数式编程的一种衍生范式。 利用AOP可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低， 提高程序的可重用性， 同时提高了开发效率。\n\n\n### 基础概念\nAOP 完善Spring 的依赖注入(DI) 面向对象编程将程序分解成各个层次的对象， 面向切面编程将程序运行过程分解成各个切面。\n\n### Filter \nFilter(过滤器) 也是一种AOPA， 他利用一种称为“横切”的技术， 刨解开封装的对象内部， 并将那些影响了多个类的公共行为封装到一个可重用的模块， 并将其命名为\"Aspect\"， 即切面。 所谓“切面”。\n\n### 优点\nAOP的好处就是你只需要干你的正事， 其他事情别人帮你干。 在你访问数据库之前， 自动帮你开启事务， 当你访问数据库结束之后， 自动帮你提交/回滚事务！\n\n就像函数的`before`和 `after`\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【AOP】面向切面编程.md","raw":"---\ntitle: 【AOP】面向切面编程\ndate: 2019-03-24 13:53:14\ncategories: [编程思想]\ntags: [AOP, 编程范式]\n---\n\n> Aspect Oriented Programming\n\n面向切面编程（aop）是对面向对象编程（oop）的补充\n\n## 面向切面编程\n\n在软件业， AOP为 `Aspect Oriented Programming` 的缩写， 意为: 面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续， 是软件开发中的一个热点， 也是Spring 框架中的一个重要内容， 是函数式编程的一种衍生范式。 利用AOP可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低， 提高程序的可重用性， 同时提高了开发效率。\n\n\n### 基础概念\nAOP 完善Spring 的依赖注入(DI) 面向对象编程将程序分解成各个层次的对象， 面向切面编程将程序运行过程分解成各个切面。\n\n### Filter \nFilter(过滤器) 也是一种AOPA， 他利用一种称为“横切”的技术， 刨解开封装的对象内部， 并将那些影响了多个类的公共行为封装到一个可重用的模块， 并将其命名为\"Aspect\"， 即切面。 所谓“切面”。\n\n### 优点\nAOP的好处就是你只需要干你的正事， 其他事情别人帮你干。 在你访问数据库之前， 自动帮你开启事务， 当你访问数据库结束之后， 自动帮你提交/回滚事务！\n\n就像函数的`before`和 `after`\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【AOP】面向切面编程","published":1,"updated":"2019-09-09T16:57:46.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4s9000naas6f32vivyf"},{"title":"【CSS全景】淘宝造物节H5原理","date":"2019-03-18T07:49:50.000Z","_content":"\n\n![](http://img.nixiaolei.com/zaowu.gif)\n\n2016年的淘宝造物节邀请函， 太牛了， 不过，我们这回先不研究他的入场特效，先研究下它的全景是如何实现的\n\n\n## 一、 载入图片, 定位至统一位置\n>因为20张图片被定位到统一地方, 所以所有图片都叠在一起了\n\n>此时效果\n\n\n![](http://img.nixiaolei.com/taobao01.png)\n\n## 二、依照Y轴旋转图片\n>先说下为什么要依照y轴:  我们需要把图片围绕成一个环形, 类似于 木桶的每一块木板,   图片就是木板, 按图片的顺序旋转自各自的角度, 目前也是原地旋转, 所以图片依旧叠加在一起\n\n>素材有20张图片, 那每张的旋转角度就是 360 / 20 = 18度, 每张旋转的度数在前一张的基础上累加 18 度, \n\n>这里注意注意注意: 因为是按图片中心的Y轴旋转, 所以同一个度数会有两张图片,  比如: 0度的图片, 头在0度, 尾在90度,    然后当轮到头在90度的图片时, 他的尾在 0 度, 所以会有同一个度数两张图片的现象\n\n\n>此时效果\n\n![](http://img.nixiaolei.com/taobao02.png)\n\n\n>为了方便理解, 切换成上帝视角, ,  所有图片围绕中心点旋转\n\n![](http://img.nixiaolei.com/taobao03.png)\n\n![](http://img.nixiaolei.com/taobao04.png)\n\n\n\n## 三、将图片沿着各自Z轴向外推\n>现在木板(也就是每一张图片)是穿插在一起的, 我们需要让他们远离中心点, 拉开距离, 让他,们边缘连接而不是这样交叉在一起,  才能形成一个圆\n\n### 先了解每一块木板怎么推\n>简单的画了个前后的效果图,  用的是上帝视角, 也就是你低头看一个木桶的视角\n\n\n\n![](http://img.nixiaolei.com/taobao05.png)\n\n\n### 如何计算该推多少距离\n>做一道三角函数数学题\n>\n>画的角度不太对别介意\n\n![](http://img.nixiaolei.com/taobao06.png)\n\n>设一共12条线,  每条长200px(此时的长就对应图片的宽) ,  求将橙线移动到图中最终位置的距离 \"黑线\",\n```JavaScript\n// 先求旋转度数\n// 然后取度数的一半\n360 / 12 / 2 = 15 度\n// 得知直角底边长度\n200 / 2 = 100px\n// 根据度数得知 tan, 顺便说下, tan是对边比邻边\ntan15°= 0.26794\n// 求出黑线\n100PX / 黑线 = 0.26794\n黑线约等于 373.2px\n```\n\n## js计算时注意\n1. Math.tan 接收的是弧度单位\n2. Math.PI 表示的是一个 Π\n3. 360度 = 2Π \n>计算出每张图片之间的形成的弧度\n```JavaScript\n // 假设图片数量是 8 张\n// 因为 360 = 2Π\n// 1度 = Π / 180\n// 每份的角度是\nconst deg = 360 / 8 // 此时为 45\n// 一份的弧度就是 每份弧度 * 旋转角度的一半\n// 最后结果就等于 Π / 图片数量\n( Math.PI / 180 ) * ( 45 / 2 )  ==>  Math.PI / 8\n```\n\n\n\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【CSS全景】淘宝造物节H5原理.md","raw":"---\ntitle: 【CSS全景】淘宝造物节H5原理\ndate: 2019-03-18 15:49:50\ncategories: CSS\ntags: [css, 3D]\n---\n\n\n![](http://img.nixiaolei.com/zaowu.gif)\n\n2016年的淘宝造物节邀请函， 太牛了， 不过，我们这回先不研究他的入场特效，先研究下它的全景是如何实现的\n\n\n## 一、 载入图片, 定位至统一位置\n>因为20张图片被定位到统一地方, 所以所有图片都叠在一起了\n\n>此时效果\n\n\n![](http://img.nixiaolei.com/taobao01.png)\n\n## 二、依照Y轴旋转图片\n>先说下为什么要依照y轴:  我们需要把图片围绕成一个环形, 类似于 木桶的每一块木板,   图片就是木板, 按图片的顺序旋转自各自的角度, 目前也是原地旋转, 所以图片依旧叠加在一起\n\n>素材有20张图片, 那每张的旋转角度就是 360 / 20 = 18度, 每张旋转的度数在前一张的基础上累加 18 度, \n\n>这里注意注意注意: 因为是按图片中心的Y轴旋转, 所以同一个度数会有两张图片,  比如: 0度的图片, 头在0度, 尾在90度,    然后当轮到头在90度的图片时, 他的尾在 0 度, 所以会有同一个度数两张图片的现象\n\n\n>此时效果\n\n![](http://img.nixiaolei.com/taobao02.png)\n\n\n>为了方便理解, 切换成上帝视角, ,  所有图片围绕中心点旋转\n\n![](http://img.nixiaolei.com/taobao03.png)\n\n![](http://img.nixiaolei.com/taobao04.png)\n\n\n\n## 三、将图片沿着各自Z轴向外推\n>现在木板(也就是每一张图片)是穿插在一起的, 我们需要让他们远离中心点, 拉开距离, 让他,们边缘连接而不是这样交叉在一起,  才能形成一个圆\n\n### 先了解每一块木板怎么推\n>简单的画了个前后的效果图,  用的是上帝视角, 也就是你低头看一个木桶的视角\n\n\n\n![](http://img.nixiaolei.com/taobao05.png)\n\n\n### 如何计算该推多少距离\n>做一道三角函数数学题\n>\n>画的角度不太对别介意\n\n![](http://img.nixiaolei.com/taobao06.png)\n\n>设一共12条线,  每条长200px(此时的长就对应图片的宽) ,  求将橙线移动到图中最终位置的距离 \"黑线\",\n```JavaScript\n// 先求旋转度数\n// 然后取度数的一半\n360 / 12 / 2 = 15 度\n// 得知直角底边长度\n200 / 2 = 100px\n// 根据度数得知 tan, 顺便说下, tan是对边比邻边\ntan15°= 0.26794\n// 求出黑线\n100PX / 黑线 = 0.26794\n黑线约等于 373.2px\n```\n\n## js计算时注意\n1. Math.tan 接收的是弧度单位\n2. Math.PI 表示的是一个 Π\n3. 360度 = 2Π \n>计算出每张图片之间的形成的弧度\n```JavaScript\n // 假设图片数量是 8 张\n// 因为 360 = 2Π\n// 1度 = Π / 180\n// 每份的角度是\nconst deg = 360 / 8 // 此时为 45\n// 一份的弧度就是 每份弧度 * 旋转角度的一半\n// 最后结果就等于 Π / 图片数量\n( Math.PI / 180 ) * ( 45 / 2 )  ==>  Math.PI / 8\n```\n\n\n\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【CSS全景】淘宝造物节H5原理","published":1,"updated":"2019-09-09T16:57:46.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sb000saas61s4lj2up"},{"title":"你不知道的Css矩阵","date":"2019-03-18T07:54:33.000Z","_content":"\n\n# 矩阵\n1. matrix(a,b,c,d,e,f);        \n2. a c e 分别和 X, Y, 1 相乘得出线性方程\n3. b d f 分别和 X, Y, 1 相乘得出线性方程\n\n\n这是很清楚的计算公式\n\n![](http://img.nixiaolei.com/matrix.png)\n\n\n\n\n\n\n## rotateZ矩阵推理\n推理过程\n\n\n![](http://img.nixiaolei.com/note.png)\n\n\n\n\n## 参考同学的笔记\n同学写的很不错👍\n\n![](http://img.nixiaolei.com/classmate-note01.png)\n\n![](http://img.nixiaolei.com/classmate-note02.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【CSS矩阵】你不知道的Css矩阵.md","raw":"---\ntitle: 你不知道的Css矩阵\ndate: 2019-03-18 15:54:33\ncategories: CSS\ntags: [css, 矩阵]\n---\n\n\n# 矩阵\n1. matrix(a,b,c,d,e,f);        \n2. a c e 分别和 X, Y, 1 相乘得出线性方程\n3. b d f 分别和 X, Y, 1 相乘得出线性方程\n\n\n这是很清楚的计算公式\n\n![](http://img.nixiaolei.com/matrix.png)\n\n\n\n\n\n\n## rotateZ矩阵推理\n推理过程\n\n\n![](http://img.nixiaolei.com/note.png)\n\n\n\n\n## 参考同学的笔记\n同学写的很不错👍\n\n![](http://img.nixiaolei.com/classmate-note01.png)\n\n![](http://img.nixiaolei.com/classmate-note02.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【CSS矩阵】你不知道的Css矩阵","published":1,"updated":"2019-09-09T16:57:46.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sc000uaas6huzvimqb"},{"title":"【C语言】入门知识","date":"2019-03-23T14:07:29.000Z","_content":"\n![C语言](http://img.nixiaolei.com/2019-04-04-22-39-41.png)\nC语言的诞生要比JavaScript早很多, 属于低级语言，比较擅长和系统交互写底层应用。\n\nC语言的编译工具就是gcc\n\n\n## 🤯前端不限端\n作为一名优质的前端切图仔， 不应该把自己困死在前端中， 更应该多开阔视野， 朝较底层的方向探索\n\n当然， 这只是鸡汤， 我们来看看前端学习C语言的必要性\n\n* 编译开源软件的源代码\n* C语言基本语法，要看得懂代码\n* 指针和C语言的坑\n* 从内存层面理解数据结构\n* 搞懂V8的内存管理机制\n* 分析webkit引擎代码\n* 用C语言编写Node.js和PHP扩展模块\n\n\n\n## C语言沉浮录\nC语言的前身是B语言\n\n\n* 天生的系统级语言\n* 最早用来编写Unix内核\n* 曾经最流行的语言\n* 至今仍在不断发展\n\n![语言发展史](http://img.nixiaolei.com/2019-04-06-13-46-58.png)\n\n\n## C语言和JavaScript的异同\n\n* C语言是编译型语言\n* C语言要借助编译器转换成可执行程序\n* JavaScript是解释型语言\n* JavaScript要借助解释引擎运行\n\n![语言编译过程](http://img.nixiaolei.com/2019-04-06-13-58-53.png)\n\n需要编译的语言经过编译后生成目标程序， 其实生成目标程序时已经是机器指令了， 但是计算机仍旧无法直接运行它，因为操作系统有他自己的规则， 想要符合操作系统的规则， 这时候就要走链接， 那链接做了哪些事让操作系统能够识别到该程序呢：\n\n1. 给操作系统一个识别块，操作系统先读识别块再运行程序\n2. 把生成的很多`.obj`文件串起来， 连成一块\n\n\n\n\n\n## C语言与C++语言的区别\n1. C++是新的编程语言，并不是C的扩展\n2. C语言是面向过程的，C＋＋是面向对象的\n3. C和C++语言都有标准库【standard.io】\n4. 目前C大多用在网络相关和嵌入式等方面【不管Python、还是JS，底层都需要C语言基本环境】\n5. 目前C++大多用在复杂引擎和应用软件方面\n\n\n\n\n## 理解内存与指针\n* 内存与内存地址\n* 指针、地址与引用\n* 指向变量的指针\n* 指向指针的指针\n* 指向函数的指针\n* 动态内存分配\n\n\n要理解内存和指针首先我们应该知道内存在计算机中是什么样子的， 我们可以把内存看作是一个打了很多格子的小纸条，**每个格子就是内存的基本存储单位**, 1个单位是一个字节，也就是一个`byte`, 而一个`byte`等于8个`bit`，那我们该如何找到对应的内存呢， 实际上内存是有编号的，这个编号从0开始， 作为内存的地址（门牌）\n\n![内存地址](http://img.nixiaolei.com/2019-04-06-14-38-20.png)\n\n### 指针\n> 指针其实也是可以运算的，但大多数情况没有意义，  一般用在计算存储空间\n\n容纳内存地址的变量就是指针\n\nC语言中， 指针也是有类型的， 因为不同的数据类型对应内存中的所占的大小不一样， 定义类型是为了从内存中拿出正确长度的数据， 比如： 短整型只占两个字节、 长整型占4个字节、  超长整型占8个字节、单精度浮点型占6个字节、 双精度浮点型占8个字节\n\n如果不正确定义指针的类型，就会导致从内存中拿出来的长度是错的， 也就是导致得到的值是错的\n\n\n![理解指针](http://img.nixiaolei.com/2019-04-06-15-09-10.png)\n\n#### 🕵️‍一级指针结构\n![一级指针结构](http://img.nixiaolei.com/2019-04-06-15-13-36.png)\n\n\n\n\n\n#### 🕵️‍二级指针结构\n![二级指针结构](http://img.nixiaolei.com/2019-04-06-15-14-35.png)\n\n\n#### 🤒声明指针\n> 一开始声明的指针我们只能给他一个Null或是 内存地址, 因为一个具体的值对于指针是没有意义的，\n\n声明一个整型的指针\n```C\n// 声明一个变量， 会自动分配内存\nint a = 10;\n\n// 声明一个指向变量a的指针\nint * p_a = &a;\n```\n#### 🧐直接寻址和间接寻址\n直接使用变量和利用指针访问的结构是一样的\n```C\nprintf(a);  // 10\nprintf( *p );  // 10\n```\n\n\n#### 🤒二级指针及多级指针\n> 不管是几级指针编译器都是能够通过的\n\n\n```C\n// 声明一个变量， 会自动分配内存\nint a = 10;\n\n// 声明一个指向变量a的指针\nint * p_a = &a;\n\n// 声明一个指向指针的指针\nint ** pp_a = &p_a;\n```\n\n\n#### 指向函数的指针\n> 函数它本身也在内存当中, 当我们看到一个指向函数的指针时就代表着函数调用， 回调函数就是基于指针的\n\nC语言的函数是有原型的\n\n声明一个两数相加函数的原型\n```C\n// 函数返回类型及参数类型\nint add( int, int );\n```\n\n实现函数\n```C\nint add(int v1, int v2) \n{\n  return v1 + v2;\n}\n```\n\n创建指向函数的指针\n```C\nint*(int, int) p_func;\np_func = add;\n```\n\n\n\n\n\n### 引用\n\n引用是对指针的封装， 现代语言不允许你直接去操作地址  因为现代语言都自带着垃圾回收机制， 在垃圾回收的过程中， 地址会经常改变，  改变地址的目的是为了提高内存的利用效率， 使内存连续\n\n\n\n\n## 内存动态分配\n\nC语言主要分如下四个区\n\n\n内存    | 描述  | 特性 \n:--------------:|:-----:|:-----:\n栈区    | 是一个确定的常数(1~2M) 不同平台会有不同大小，超出会提示stackoverflow |  自动分配, 自动释放\n堆区   | 用于动态内存分配 | 手动分配和释放 ， 可占用80%内存\n全局区或静态区  | 在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量） | 只初始化一次 \n程序代码区  | 代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。 | 代码区的指令中包括操作码和要操作的对象（或对象地址引用）\n\n\n\n\n* 栈区： 还用来保存当前函数的局部变量\n* 堆区： 存放new出来的变量\n* 全局区或静态区: 存放全局变量及对象的静态变量\n* 程序代码区:  存放指令、代码， 以前的金山游侠修改器就是专门改程序代码区的\n\n\n\n\n### 分配内存代码\n```C\nint * p;\n\n// size_t 表示一个无符号整型\n// p = malloc( size_t );\n\n// 给整型分配空间必须 传入整型长度的倍数（ 整型长度是 4个字节）\n// 这样我就申请了40个字节的内存空间， 它能容纳10个整型的数字\np = malloc(40);\n\n// 实际上 malloc 申请到的是一个数组， 下面这样是对前4个字节进行赋值\n*p = 1;\n// 实际等价于\np[0] = 1;\n\n// 如果你要给其他位置的字节赋值, 这样表示向后移动一个元素单位的位置\n*(p+1) = 2; \n// 等价于\np[1] = 2;\n```\n\n### 释放内存\n```C\nfree(p)\n```\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【C语言】入门知识.md","raw":"---\ntitle: 【C语言】入门知识\ndate: 2019-03-23 22:07:29\ncategories: C语言\ntags: C语言\n---\n\n![C语言](http://img.nixiaolei.com/2019-04-04-22-39-41.png)\nC语言的诞生要比JavaScript早很多, 属于低级语言，比较擅长和系统交互写底层应用。\n\nC语言的编译工具就是gcc\n\n\n## 🤯前端不限端\n作为一名优质的前端切图仔， 不应该把自己困死在前端中， 更应该多开阔视野， 朝较底层的方向探索\n\n当然， 这只是鸡汤， 我们来看看前端学习C语言的必要性\n\n* 编译开源软件的源代码\n* C语言基本语法，要看得懂代码\n* 指针和C语言的坑\n* 从内存层面理解数据结构\n* 搞懂V8的内存管理机制\n* 分析webkit引擎代码\n* 用C语言编写Node.js和PHP扩展模块\n\n\n\n## C语言沉浮录\nC语言的前身是B语言\n\n\n* 天生的系统级语言\n* 最早用来编写Unix内核\n* 曾经最流行的语言\n* 至今仍在不断发展\n\n![语言发展史](http://img.nixiaolei.com/2019-04-06-13-46-58.png)\n\n\n## C语言和JavaScript的异同\n\n* C语言是编译型语言\n* C语言要借助编译器转换成可执行程序\n* JavaScript是解释型语言\n* JavaScript要借助解释引擎运行\n\n![语言编译过程](http://img.nixiaolei.com/2019-04-06-13-58-53.png)\n\n需要编译的语言经过编译后生成目标程序， 其实生成目标程序时已经是机器指令了， 但是计算机仍旧无法直接运行它，因为操作系统有他自己的规则， 想要符合操作系统的规则， 这时候就要走链接， 那链接做了哪些事让操作系统能够识别到该程序呢：\n\n1. 给操作系统一个识别块，操作系统先读识别块再运行程序\n2. 把生成的很多`.obj`文件串起来， 连成一块\n\n\n\n\n\n## C语言与C++语言的区别\n1. C++是新的编程语言，并不是C的扩展\n2. C语言是面向过程的，C＋＋是面向对象的\n3. C和C++语言都有标准库【standard.io】\n4. 目前C大多用在网络相关和嵌入式等方面【不管Python、还是JS，底层都需要C语言基本环境】\n5. 目前C++大多用在复杂引擎和应用软件方面\n\n\n\n\n## 理解内存与指针\n* 内存与内存地址\n* 指针、地址与引用\n* 指向变量的指针\n* 指向指针的指针\n* 指向函数的指针\n* 动态内存分配\n\n\n要理解内存和指针首先我们应该知道内存在计算机中是什么样子的， 我们可以把内存看作是一个打了很多格子的小纸条，**每个格子就是内存的基本存储单位**, 1个单位是一个字节，也就是一个`byte`, 而一个`byte`等于8个`bit`，那我们该如何找到对应的内存呢， 实际上内存是有编号的，这个编号从0开始， 作为内存的地址（门牌）\n\n![内存地址](http://img.nixiaolei.com/2019-04-06-14-38-20.png)\n\n### 指针\n> 指针其实也是可以运算的，但大多数情况没有意义，  一般用在计算存储空间\n\n容纳内存地址的变量就是指针\n\nC语言中， 指针也是有类型的， 因为不同的数据类型对应内存中的所占的大小不一样， 定义类型是为了从内存中拿出正确长度的数据， 比如： 短整型只占两个字节、 长整型占4个字节、  超长整型占8个字节、单精度浮点型占6个字节、 双精度浮点型占8个字节\n\n如果不正确定义指针的类型，就会导致从内存中拿出来的长度是错的， 也就是导致得到的值是错的\n\n\n![理解指针](http://img.nixiaolei.com/2019-04-06-15-09-10.png)\n\n#### 🕵️‍一级指针结构\n![一级指针结构](http://img.nixiaolei.com/2019-04-06-15-13-36.png)\n\n\n\n\n\n#### 🕵️‍二级指针结构\n![二级指针结构](http://img.nixiaolei.com/2019-04-06-15-14-35.png)\n\n\n#### 🤒声明指针\n> 一开始声明的指针我们只能给他一个Null或是 内存地址, 因为一个具体的值对于指针是没有意义的，\n\n声明一个整型的指针\n```C\n// 声明一个变量， 会自动分配内存\nint a = 10;\n\n// 声明一个指向变量a的指针\nint * p_a = &a;\n```\n#### 🧐直接寻址和间接寻址\n直接使用变量和利用指针访问的结构是一样的\n```C\nprintf(a);  // 10\nprintf( *p );  // 10\n```\n\n\n#### 🤒二级指针及多级指针\n> 不管是几级指针编译器都是能够通过的\n\n\n```C\n// 声明一个变量， 会自动分配内存\nint a = 10;\n\n// 声明一个指向变量a的指针\nint * p_a = &a;\n\n// 声明一个指向指针的指针\nint ** pp_a = &p_a;\n```\n\n\n#### 指向函数的指针\n> 函数它本身也在内存当中, 当我们看到一个指向函数的指针时就代表着函数调用， 回调函数就是基于指针的\n\nC语言的函数是有原型的\n\n声明一个两数相加函数的原型\n```C\n// 函数返回类型及参数类型\nint add( int, int );\n```\n\n实现函数\n```C\nint add(int v1, int v2) \n{\n  return v1 + v2;\n}\n```\n\n创建指向函数的指针\n```C\nint*(int, int) p_func;\np_func = add;\n```\n\n\n\n\n\n### 引用\n\n引用是对指针的封装， 现代语言不允许你直接去操作地址  因为现代语言都自带着垃圾回收机制， 在垃圾回收的过程中， 地址会经常改变，  改变地址的目的是为了提高内存的利用效率， 使内存连续\n\n\n\n\n## 内存动态分配\n\nC语言主要分如下四个区\n\n\n内存    | 描述  | 特性 \n:--------------:|:-----:|:-----:\n栈区    | 是一个确定的常数(1~2M) 不同平台会有不同大小，超出会提示stackoverflow |  自动分配, 自动释放\n堆区   | 用于动态内存分配 | 手动分配和释放 ， 可占用80%内存\n全局区或静态区  | 在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量） | 只初始化一次 \n程序代码区  | 代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。 | 代码区的指令中包括操作码和要操作的对象（或对象地址引用）\n\n\n\n\n* 栈区： 还用来保存当前函数的局部变量\n* 堆区： 存放new出来的变量\n* 全局区或静态区: 存放全局变量及对象的静态变量\n* 程序代码区:  存放指令、代码， 以前的金山游侠修改器就是专门改程序代码区的\n\n\n\n\n### 分配内存代码\n```C\nint * p;\n\n// size_t 表示一个无符号整型\n// p = malloc( size_t );\n\n// 给整型分配空间必须 传入整型长度的倍数（ 整型长度是 4个字节）\n// 这样我就申请了40个字节的内存空间， 它能容纳10个整型的数字\np = malloc(40);\n\n// 实际上 malloc 申请到的是一个数组， 下面这样是对前4个字节进行赋值\n*p = 1;\n// 实际等价于\np[0] = 1;\n\n// 如果你要给其他位置的字节赋值, 这样表示向后移动一个元素单位的位置\n*(p+1) = 2; \n// 等价于\np[1] = 2;\n```\n\n### 释放内存\n```C\nfree(p)\n```\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【C语言】入门知识","published":1,"updated":"2019-09-09T16:57:46.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sd000yaas61lhfyy8t"},{"title":"【JS】MessageChannel消息通道","date":"2019-06-30T13:49:45.000Z","_content":"\n## 介绍\n宏任务! 点对点之间的通信\n\nChannel Messaging API的Channel Messaging接口允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据。\n\n\n它会返回两个端口 `Port1`和 `Port2`\n\n![2019-06-30-21-51-18](http://img.nixiaolei.com/2019-06-30-21-51-18.png)\n\n\n\n## 使用场景思考\n1. Vue 中用作与 $nextTick 的备选方案,  是宏任务\n2. 用作与Fiber 的进程调度中\n3. 可以用在组件之间的通信\n4. 利用参数传递默认深拷贝的特性来做深拷贝.\n5. 与Iframe 通信\n\n\n\n## 一段Demo\n\n```JS\nvar channel = new MessageChannel();\nvar para = document.querySelector('p');\n    \nvar ifr = document.querySelector('iframe');\nvar otherWindow = ifr.contentWindow;\n\nifr.addEventListener(\"load\", iframeLoaded, false);\n    \nfunction iframeLoaded() {\n  otherWindow.postMessage('Hello from the main page!', '*', [channel.port2]);\n}\n\nchannel.port1.onmessage = handleMessage;\nfunction handleMessage(e) {\n  para.innerHTML = e.data;\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/【JS】MessageChannel消息通道.md","raw":"---\ntitle: 【JS】MessageChannel消息通道\ndate: 2019-06-30 21:49:45\ncategories: JavaScript\ntags: [JavaScript]\n---\n\n## 介绍\n宏任务! 点对点之间的通信\n\nChannel Messaging API的Channel Messaging接口允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据。\n\n\n它会返回两个端口 `Port1`和 `Port2`\n\n![2019-06-30-21-51-18](http://img.nixiaolei.com/2019-06-30-21-51-18.png)\n\n\n\n## 使用场景思考\n1. Vue 中用作与 $nextTick 的备选方案,  是宏任务\n2. 用作与Fiber 的进程调度中\n3. 可以用在组件之间的通信\n4. 利用参数传递默认深拷贝的特性来做深拷贝.\n5. 与Iframe 通信\n\n\n\n## 一段Demo\n\n```JS\nvar channel = new MessageChannel();\nvar para = document.querySelector('p');\n    \nvar ifr = document.querySelector('iframe');\nvar otherWindow = ifr.contentWindow;\n\nifr.addEventListener(\"load\", iframeLoaded, false);\n    \nfunction iframeLoaded() {\n  otherWindow.postMessage('Hello from the main page!', '*', [channel.port2]);\n}\n\nchannel.port1.onmessage = handleMessage;\nfunction handleMessage(e) {\n  para.innerHTML = e.data;\n}\n```\n\n\n\n\n\n\n\n","slug":"【JS】MessageChannel消息通道","published":1,"updated":"2019-09-09T16:57:46.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sf0010aas6upya3h1d"},{"title":"【JS】Object、Array与Map的比较","date":"2019-06-30T15:16:21.000Z","_content":"\n## Object 与 Map\n> Object 在V8中的实现是 key - value 分别作为一个数组存储, 所以存储空间是元素的两倍\n\n![2019-06-30-23-22-24](http://img.nixiaolei.com/2019-06-30-23-22-24.png)\n\n\n## 和Array对比\n![2019-06-30-23-26-13](http://img.nixiaolei.com/2019-06-30-23-26-13.png)\n\n\n\n\n\n\n","source":"_posts/【JS】Object、Array与Map的比较.md","raw":"---\ntitle: 【JS】Object、Array与Map的比较\ndate: 2019-06-30 23:16:21\ncategories: JavaScript\ntags: JavaScript\n---\n\n## Object 与 Map\n> Object 在V8中的实现是 key - value 分别作为一个数组存储, 所以存储空间是元素的两倍\n\n![2019-06-30-23-22-24](http://img.nixiaolei.com/2019-06-30-23-22-24.png)\n\n\n## 和Array对比\n![2019-06-30-23-26-13](http://img.nixiaolei.com/2019-06-30-23-26-13.png)\n\n\n\n\n\n\n","slug":"【JS】Object、Array与Map的比较","published":1,"updated":"2019-09-09T16:57:46.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sg0015aas6h295emh7"},{"title":"【JS】Set是如何实现的","date":"2019-06-30T14:21:49.000Z","_content":"\n\n## 一般情况\nSet一般是使用红黑树实现的, 红黑树是一种平衡查找二叉树, 它的查找时间复杂度为O(logN). 从O(N)变成O(logN), 而总体时间从O(N2)变成O(NlogN)\n\n\n\n## V8中的实现(哈希实现)\n\nChrome V8的Set是哈希实现的, 他是一个哈希Set, 哈希的查找复杂度为O(1), 因此总的时间复杂度为O(N), Set/ Map都是这样\n\n\n哈希的存储空间通常为数据大小的两倍. 典型的用空间换时间的算法.\n\n\n## for 、Set和Map如何选型\n![2019-06-30-22-30-29](http://img.nixiaolei.com/2019-06-30-22-30-29.png)\n\n\n\n## 面试标准回答\n一般情况是使用 红黑树实现的, 复杂度是 O(logN)\n\nV8进行了优化, 复杂度降低至 O(1)\n\n\n\n\n\n\n\n\n\n","source":"_posts/【JS】Set是如何实现的.md","raw":"---\ntitle: 【JS】Set是如何实现的\ndate: 2019-06-30 22:21:49\ncategories: JavaScript\ntags: JavaScript\n---\n\n\n## 一般情况\nSet一般是使用红黑树实现的, 红黑树是一种平衡查找二叉树, 它的查找时间复杂度为O(logN). 从O(N)变成O(logN), 而总体时间从O(N2)变成O(NlogN)\n\n\n\n## V8中的实现(哈希实现)\n\nChrome V8的Set是哈希实现的, 他是一个哈希Set, 哈希的查找复杂度为O(1), 因此总的时间复杂度为O(N), Set/ Map都是这样\n\n\n哈希的存储空间通常为数据大小的两倍. 典型的用空间换时间的算法.\n\n\n## for 、Set和Map如何选型\n![2019-06-30-22-30-29](http://img.nixiaolei.com/2019-06-30-22-30-29.png)\n\n\n\n## 面试标准回答\n一般情况是使用 红黑树实现的, 复杂度是 O(logN)\n\nV8进行了优化, 复杂度降低至 O(1)\n\n\n\n\n\n\n\n\n\n","slug":"【JS】Set是如何实现的","published":1,"updated":"2019-09-09T16:57:46.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sh0018aas6n9i0iuab"},{"title":"【JS】什么是AO-VO","date":"2019-06-10T13:34:38.000Z","_content":"\n\n\n## GO\n> glbal Context 全局执行上下文\n\n首先在js执行的时候会创建一个GO， 被压入 ESC Stack 栈底\n\n\n## EC\n> execution 执行上下文\n\n在每个函数执行的时候会创建一个EC（执行上下文）\n\n在函数执行上下文中， 还会有两个东西被创建出来： AO、VO\n\n### AO\n> Activation Object 活动对象\n\nAO是在函数执行的阶段\n1. arguments的callee length\n2. 内部定义的函数\n3. 绑定对应环境变量\n4. 内部定义的变量\n\nAO的阶段又可以细分为:\n1. 定义阶段\n2. 执行阶段\n\n\n#### 浏览器解析阶段\n这就是浏览器解析js的时候， 当v8拿到函数的时候， 都给你先编译成比较慢的字节码， 然后对字节码进行优化， 接着经过`静态分析`进行本地替换那些频繁使用到的字节码段， 替换成优化后的字节码，为什么不都进行优化， 因为优化后的字节码体积会比较大。\n\n#### 初始化阶段\n创建作用域链（Scope Chain）\n创建变量，函数和参数。\n定义`this`但不确认\n\n\n\n\n\n让我们通过这段代码看一下AO的具体情况:\n```Js\nfunction test(a, b) {\n  var c = 10\n  function d() {}\n  var e = function _e(){};\n  (function x() {})\n}\n\ntest(10)\n```\n那此时这个 test 函数的AO情况如下\n\n```Js\nEC(test) = {\n  // 自己维护的scopeChain 作用域链\n  scopeChain: { Scope }, // 指向下面的Scope\n\n  // 预解析的原理\n  AO(test): {\n    a: 10,\n    b: undefind,\n    c: undefind,\n    e: undefind\n  },\n  this: '先定义但不确认',\n  Scope: [AO, glbalContext.vo]\n}\n\n\n```\n\n#### 执行阶段\n\n```Js\nEC(test) = {\n  scopeChain: { Scope },\n\n  // 预解析的原理\n  AO(test): {\n    arguments: {\n      0: 11,\n      1: 22,\n      length: 3\n    },\n    a: 10,\n    b: undefind,\n    c: undefind,\n    e: undefind\n  },\n  this: 'this指向函数执行栈栈顶',\n  Scope: [AO, glbalContext.vo]\n}\n\n```\n\n\n\n\n\n### VO\n> Variable object 变量对象\n\n每个函数都有自己的VO对象， 存储着这些\n1. 函数声明（不包含函数表达式）\n2. 函数的形参\n3. 变量的声明\n\n\n总的来说篇， VO要比AO的范围大得多， VO是负责把各个调用的函数串联起来的。 他是外部的， 而AO是函数自身内部的\n\n距离， 当执行 `fun1`:\n```js\nVO(fun1) = AO // 执行到fun1 时可以在VO中的fun1就是此时的AO\n```\n\n又或者再举个例子，有这样一段代码要执行\n```Js\nvar a = 10\nfunction test(x) {\n  var b = 20 \n}\n\ntest(30)\n```\n\n此时我们来看一下VO的状态\n\n```Js\n// VO中的 GO \nVO(globalContext) = {\n  a: 1,\n  test: '<reference to function>'\n};\n\n// VO 中的 test函数\n\nVO(test) = {\n  x: 30, // 传入的参数\n  b: 20\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n***\n上面的这些也就构成了 ECS Stack 函数执行栈\n\n### ESC Stack\n> executions statck  执行上下文栈\n\n很多个函数存在一起的时候会存在一个ESC Stack\n\n所谓的 stack 它就是一个栈， 先进入\n\n当js开始运行时就创建一个 `globalContext` 压入栈底， 也就是单体内置对象`Global`, 在浏览器中通常是 `window`\n\n被压入栈的情况大致如下\n```Js\nECStatck = [\n  globalContext\n]\n```\n\n当一段代码执行了好多函数时， 比如这样一段代码: \n```js\nfunction fun3() {}\n\nfunction fun2() {\n  fun3()\n}\n\nfunction fun1() {\n  fun2()\n}\nfun1()\n```\n\n实际入栈过程是这样的:\n```Js\nECStatck = [\n  fun3,\n  fun2,\n  fun1,\n  globalContext\n]\n```\n\n当一个函数入栈， 它所属的变量也随之入栈， 当函数出栈， 变量也就跟着出栈了， 每个函数都会拥有各自的 EC（函数执行上下文）， 也就有各自的 AO、VO, \n\n> 你肯定会疑惑闭包呢， 函数出栈了， 那闭包去哪了\n> 其实，js的闭包是存在堆里的， 跟普通函数不一样， 所以不会跟着出栈函数一起被回收\n\n\n","source":"_posts/【JS】什么是AO-VO-GO.md","raw":"---\ntitle: 【JS】什么是AO-VO\ndate: 2019-06-10 21:34:38\ncategories: JavaScript\ntags: [JavaScript, js执行机制]\n---\n\n\n\n## GO\n> glbal Context 全局执行上下文\n\n首先在js执行的时候会创建一个GO， 被压入 ESC Stack 栈底\n\n\n## EC\n> execution 执行上下文\n\n在每个函数执行的时候会创建一个EC（执行上下文）\n\n在函数执行上下文中， 还会有两个东西被创建出来： AO、VO\n\n### AO\n> Activation Object 活动对象\n\nAO是在函数执行的阶段\n1. arguments的callee length\n2. 内部定义的函数\n3. 绑定对应环境变量\n4. 内部定义的变量\n\nAO的阶段又可以细分为:\n1. 定义阶段\n2. 执行阶段\n\n\n#### 浏览器解析阶段\n这就是浏览器解析js的时候， 当v8拿到函数的时候， 都给你先编译成比较慢的字节码， 然后对字节码进行优化， 接着经过`静态分析`进行本地替换那些频繁使用到的字节码段， 替换成优化后的字节码，为什么不都进行优化， 因为优化后的字节码体积会比较大。\n\n#### 初始化阶段\n创建作用域链（Scope Chain）\n创建变量，函数和参数。\n定义`this`但不确认\n\n\n\n\n\n让我们通过这段代码看一下AO的具体情况:\n```Js\nfunction test(a, b) {\n  var c = 10\n  function d() {}\n  var e = function _e(){};\n  (function x() {})\n}\n\ntest(10)\n```\n那此时这个 test 函数的AO情况如下\n\n```Js\nEC(test) = {\n  // 自己维护的scopeChain 作用域链\n  scopeChain: { Scope }, // 指向下面的Scope\n\n  // 预解析的原理\n  AO(test): {\n    a: 10,\n    b: undefind,\n    c: undefind,\n    e: undefind\n  },\n  this: '先定义但不确认',\n  Scope: [AO, glbalContext.vo]\n}\n\n\n```\n\n#### 执行阶段\n\n```Js\nEC(test) = {\n  scopeChain: { Scope },\n\n  // 预解析的原理\n  AO(test): {\n    arguments: {\n      0: 11,\n      1: 22,\n      length: 3\n    },\n    a: 10,\n    b: undefind,\n    c: undefind,\n    e: undefind\n  },\n  this: 'this指向函数执行栈栈顶',\n  Scope: [AO, glbalContext.vo]\n}\n\n```\n\n\n\n\n\n### VO\n> Variable object 变量对象\n\n每个函数都有自己的VO对象， 存储着这些\n1. 函数声明（不包含函数表达式）\n2. 函数的形参\n3. 变量的声明\n\n\n总的来说篇， VO要比AO的范围大得多， VO是负责把各个调用的函数串联起来的。 他是外部的， 而AO是函数自身内部的\n\n距离， 当执行 `fun1`:\n```js\nVO(fun1) = AO // 执行到fun1 时可以在VO中的fun1就是此时的AO\n```\n\n又或者再举个例子，有这样一段代码要执行\n```Js\nvar a = 10\nfunction test(x) {\n  var b = 20 \n}\n\ntest(30)\n```\n\n此时我们来看一下VO的状态\n\n```Js\n// VO中的 GO \nVO(globalContext) = {\n  a: 1,\n  test: '<reference to function>'\n};\n\n// VO 中的 test函数\n\nVO(test) = {\n  x: 30, // 传入的参数\n  b: 20\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n***\n上面的这些也就构成了 ECS Stack 函数执行栈\n\n### ESC Stack\n> executions statck  执行上下文栈\n\n很多个函数存在一起的时候会存在一个ESC Stack\n\n所谓的 stack 它就是一个栈， 先进入\n\n当js开始运行时就创建一个 `globalContext` 压入栈底， 也就是单体内置对象`Global`, 在浏览器中通常是 `window`\n\n被压入栈的情况大致如下\n```Js\nECStatck = [\n  globalContext\n]\n```\n\n当一段代码执行了好多函数时， 比如这样一段代码: \n```js\nfunction fun3() {}\n\nfunction fun2() {\n  fun3()\n}\n\nfunction fun1() {\n  fun2()\n}\nfun1()\n```\n\n实际入栈过程是这样的:\n```Js\nECStatck = [\n  fun3,\n  fun2,\n  fun1,\n  globalContext\n]\n```\n\n当一个函数入栈， 它所属的变量也随之入栈， 当函数出栈， 变量也就跟着出栈了， 每个函数都会拥有各自的 EC（函数执行上下文）， 也就有各自的 AO、VO, \n\n> 你肯定会疑惑闭包呢， 函数出栈了， 那闭包去哪了\n> 其实，js的闭包是存在堆里的， 跟普通函数不一样， 所以不会跟着出栈函数一起被回收\n\n\n","slug":"【JS】什么是AO-VO-GO","published":1,"updated":"2019-09-09T16:57:46.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sh001baas6851gy5dh"},{"title":"【JS】V8引擎里for和forEach","date":"2019-05-11T14:13:30.000Z","_content":"\n\n一般是for 循环比较快,  但是V8中每个数组自带的方法一定程度上是对数组数量级的优化, 在一定数量的数据下, forEach 要优于 for 循环, 所以看场景选择吧, 具体请看v8源码\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【JS】V8引擎里for和forEach.md","raw":"---\ntitle: 【JS】V8引擎里for和forEach\ndate: 2019-05-11 22:13:30\ncategories: JavaScript\ntags: JavaScript\n---\n\n\n一般是for 循环比较快,  但是V8中每个数组自带的方法一定程度上是对数组数量级的优化, 在一定数量的数据下, forEach 要优于 for 循环, 所以看场景选择吧, 具体请看v8源码\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【JS】V8引擎里for和forEach","published":1,"updated":"2019-09-09T16:57:46.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4si001gaas62x4cuqop"},{"title":"【JS】如何测试Js代码性能","date":"2019-05-11T14:37:19.000Z","_content":"\n\n使用 benchmark.js 进行前端代码基准测试\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【JS】如何测试Js代码性能.md","raw":"---\ntitle: 【JS】如何测试Js代码性能\ndate: 2019-05-11 22:37:19\ncategories: JavaScript\ntags: JavaScript\n---\n\n\n使用 benchmark.js 进行前端代码基准测试\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【JS】如何测试Js代码性能","published":1,"updated":"2019-09-09T16:57:46.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sj001iaas60t6424dg"},{"title":"【JS】关于requestIdleCallback函数的作用","date":"2019-06-30T04:25:42.000Z","_content":"\n\nrequestIdleCallback 会在浏览器每一帧的空闲时期依次调用函数， \n\n如果说， 一个浏览器的效率很高，有60fps的刷新频率， 也就是说该浏览器每一帧的刷新时间是16.6s， 如果说电脑比较卡， 那刷新频率可能就会下降， 会是 30fps(原则上30fps是肉眼能接收的最低频率)。 此时，每一帧也就是33.3s， 该函数的出发场景就是在帧与帧之间， 也可以是说帧的末尾， 实际上每一帧并不一定会完全消耗完 16.6s 甚至是 33.3s， 他会有剩余的时间留给浏览器去执行js，  requestIdleCallback 就是如此， 用它调用的函数会在浏览器的该帧期间，渲染过后的剩余时间内调用该回调，\n\n这也是react 16 fiber架构的调度算法核心\n\n\n## 基本语法\n> https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\n\n\n![2019-06-30-12-36-16](http://img.nixiaolei.com/2019-06-30-12-36-16.png)\n\n\n并且我们还可以通过 `deadline.timeRemaining`方法来查看该帧期间的剩余时间\n\n\n## Demo\n首先尝试搭建一个最简单的demo ,打印一下 deadline 、剩余时间 和 该函数的返回值\n```Js\nconst id = window.requestIdleCallback((deadline) => {\n  // 剩余时间， 单位ms, 指的是该帧的剩余时间\n  console.log(deadline.timeRemaining())\n  // 表示该帧里面没有执行回调， 超时了\n  console.log(deadline)\n}, {\n  // 1. 即超时时间， 不提供的话浏览器会自己去算\n  // 2. 如果给定 timeout ， 那到了时间， 都会立刻执行回调 callback\n  timeout: 1000\n})\n\nconsole.log(id)\n```\n\n返回结果:\n\n![2019-06-30-12-48-25](http://img.nixiaolei.com/2019-06-30-12-48-25.png)\n\n我们可以看到：\n1. 该函数的返回结果(id)的值： 1\n2. 浏览器本帧的剩余空闲时间: 1.2750000000000001\n3. 回调接收的 `deadline`方法， 里面有一个 didTimeout 属性\n\n\n\n## 如何取消requestIdleCallback\n\n将 requestIdleCallback 的返回值（一个无符号长整数），可以把它传入 Window.cancelIdleCallback() 方法，来结束回调\n\n\n## 如何实现 polyfill\nrequestIdleCallback 这个方法浏览器的兼容相当差， 那怎么办， React16 Fiber中也使用了， 别人是如何解决的呢？\n\n答案是： `requestAnimationFrame`\n\n![2019-06-30-12-59-21](http://img.nixiaolei.com/2019-06-30-12-59-21.png)\n\n利用回调接收的 DOMHighResTimeStamp 参数， 计算出每一帧所花费的时间， 自己去实现一个 `requestIdleCallback` 的polyfill ,  简直完美","source":"_posts/【JS】关于requestIdleCallback函数的作用.md","raw":"---\ntitle: 【JS】关于requestIdleCallback函数的作用\ndate: 2019-06-30 12:25:42\ncategories: JavaScript\ntags: JavaScript\n---\n\n\nrequestIdleCallback 会在浏览器每一帧的空闲时期依次调用函数， \n\n如果说， 一个浏览器的效率很高，有60fps的刷新频率， 也就是说该浏览器每一帧的刷新时间是16.6s， 如果说电脑比较卡， 那刷新频率可能就会下降， 会是 30fps(原则上30fps是肉眼能接收的最低频率)。 此时，每一帧也就是33.3s， 该函数的出发场景就是在帧与帧之间， 也可以是说帧的末尾， 实际上每一帧并不一定会完全消耗完 16.6s 甚至是 33.3s， 他会有剩余的时间留给浏览器去执行js，  requestIdleCallback 就是如此， 用它调用的函数会在浏览器的该帧期间，渲染过后的剩余时间内调用该回调，\n\n这也是react 16 fiber架构的调度算法核心\n\n\n## 基本语法\n> https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\n\n\n![2019-06-30-12-36-16](http://img.nixiaolei.com/2019-06-30-12-36-16.png)\n\n\n并且我们还可以通过 `deadline.timeRemaining`方法来查看该帧期间的剩余时间\n\n\n## Demo\n首先尝试搭建一个最简单的demo ,打印一下 deadline 、剩余时间 和 该函数的返回值\n```Js\nconst id = window.requestIdleCallback((deadline) => {\n  // 剩余时间， 单位ms, 指的是该帧的剩余时间\n  console.log(deadline.timeRemaining())\n  // 表示该帧里面没有执行回调， 超时了\n  console.log(deadline)\n}, {\n  // 1. 即超时时间， 不提供的话浏览器会自己去算\n  // 2. 如果给定 timeout ， 那到了时间， 都会立刻执行回调 callback\n  timeout: 1000\n})\n\nconsole.log(id)\n```\n\n返回结果:\n\n![2019-06-30-12-48-25](http://img.nixiaolei.com/2019-06-30-12-48-25.png)\n\n我们可以看到：\n1. 该函数的返回结果(id)的值： 1\n2. 浏览器本帧的剩余空闲时间: 1.2750000000000001\n3. 回调接收的 `deadline`方法， 里面有一个 didTimeout 属性\n\n\n\n## 如何取消requestIdleCallback\n\n将 requestIdleCallback 的返回值（一个无符号长整数），可以把它传入 Window.cancelIdleCallback() 方法，来结束回调\n\n\n## 如何实现 polyfill\nrequestIdleCallback 这个方法浏览器的兼容相当差， 那怎么办， React16 Fiber中也使用了， 别人是如何解决的呢？\n\n答案是： `requestAnimationFrame`\n\n![2019-06-30-12-59-21](http://img.nixiaolei.com/2019-06-30-12-59-21.png)\n\n利用回调接收的 DOMHighResTimeStamp 参数， 计算出每一帧所花费的时间， 自己去实现一个 `requestIdleCallback` 的polyfill ,  简直完美","slug":"【JS】关于requestIdleCallback函数的作用","published":1,"updated":"2019-09-09T16:57:46.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sl001naas6mimk3kkn"},{"title":"【JS】递归、尾递归与尾调用","date":"2019-06-16T11:04:41.000Z","_content":"\n\n## 尾调用\n所谓的尾调用， 尾调用是我们平时实现递归操作的一种方式, 通过在函数末尾调用另一个函数， 来抹除上一个函数的堆栈记录， 可以理解为是一种任务承接的方式\n\ndemo:\n```js\nfunction f(index, total) {\n  if(index-- === 1) {\n    return total\n  }\n  g(index, total + index)\n}\n\nfunction g( index, total ) {\n  f( index, total )\n}\n```\n\n\n\n## 尾递归\n尾递归和普通递归的区别就是， 尾递归的递归方式是在函数最后一步操作调用自身， 并将本轮计算结果以参数形式传入\n\ndemo:\n```js\nfunction loop(index, total) {\n  if(index-- === 1) {\n    return total\n  }\n  return loop(index, total + index)\n}\n\nloop(100, 0)\n```\n\n### 尾调用优化\n\n在ES6中， 我们将迎来尾递归优化， 通过尾递归优化， javascript代码在解释成机器码的时候， 将会向while看齐， 也就是说， 同时拥有数学表达能力和`while`的效能。\n\n\nES6的“尾调用优化”的原理就是覆盖掉自身的函数执行记录， 也就是将递归变为循环， 只保存一个调用记录，这样就不会发生爆栈的情况了\n\n\n\n\n### 浏览器的实现情况\n虽然是ES6的规范， 浏览器也实现了， 但实际上平时使用时“尾调用优化”是默认关闭的。 为什么！因为浏览器不敢开哦。 因为一旦开了尾调用优化， 就等于放弃了存留函数的堆栈信息， 当开发者调错时会十分困难， 找不到正确的堆栈信息， 当然可以利用js的元编程强行开启\n\n### 其他避免爆栈手段\n* 使用`蹦床函数`， 将递归拉平\n* 直接将递归改写成循环\n* 使用元编程强行开启浏览器的“尾递归优化”\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【JS】递归、尾递归与尾调用.md","raw":"---\ntitle: 【JS】递归、尾递归与尾调用\ndate: 2019-06-16 19:04:41\ncategories: JavaScript\ntags: [JavaScript, 尾递归, 尾调用]\n---\n\n\n## 尾调用\n所谓的尾调用， 尾调用是我们平时实现递归操作的一种方式, 通过在函数末尾调用另一个函数， 来抹除上一个函数的堆栈记录， 可以理解为是一种任务承接的方式\n\ndemo:\n```js\nfunction f(index, total) {\n  if(index-- === 1) {\n    return total\n  }\n  g(index, total + index)\n}\n\nfunction g( index, total ) {\n  f( index, total )\n}\n```\n\n\n\n## 尾递归\n尾递归和普通递归的区别就是， 尾递归的递归方式是在函数最后一步操作调用自身， 并将本轮计算结果以参数形式传入\n\ndemo:\n```js\nfunction loop(index, total) {\n  if(index-- === 1) {\n    return total\n  }\n  return loop(index, total + index)\n}\n\nloop(100, 0)\n```\n\n### 尾调用优化\n\n在ES6中， 我们将迎来尾递归优化， 通过尾递归优化， javascript代码在解释成机器码的时候， 将会向while看齐， 也就是说， 同时拥有数学表达能力和`while`的效能。\n\n\nES6的“尾调用优化”的原理就是覆盖掉自身的函数执行记录， 也就是将递归变为循环， 只保存一个调用记录，这样就不会发生爆栈的情况了\n\n\n\n\n### 浏览器的实现情况\n虽然是ES6的规范， 浏览器也实现了， 但实际上平时使用时“尾调用优化”是默认关闭的。 为什么！因为浏览器不敢开哦。 因为一旦开了尾调用优化， 就等于放弃了存留函数的堆栈信息， 当开发者调错时会十分困难， 找不到正确的堆栈信息， 当然可以利用js的元编程强行开启\n\n### 其他避免爆栈手段\n* 使用`蹦床函数`， 将递归拉平\n* 直接将递归改写成循环\n* 使用元编程强行开启浏览器的“尾递归优化”\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【JS】递归、尾递归与尾调用","published":1,"updated":"2019-09-09T16:57:46.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sn001qaas6ml33s9dg"},{"title":"【Linux】命令手册","date":"2019-04-02T12:35:33.000Z","_content":"\n\nlinux 只有区的概念\n\n## 终端快捷键\n| 命令 | 功能 | \n| ------ | ------ | \n| ctrl + c | 结束正在运行的程序 【 ping 、 teInet等】 | \n| ctrl + d | 结束输入或退出shell |\n| ctrl + s |  暂停屏幕输出 |\n| ctrl + q |  恢复屏幕输出 |\n| ctrl + l |  清屏， 等同于Clear |\n| ctrl + a / ctrl + e | 快速移动光标到行首 / 行尾 |\n\n\n\n## 身份命令\n| 命令 | 功能 | \n| ------ | ------ | \n| sudo | 暂时以root 用户身份运行命令 | \n| su | 切换用户身份, root身份切换不需要密码 |\n| exit |  退出当前身份或退出连接 |\n| w | 查看正在登录用户|\n\n### 路径知识\n* Linux下文件前带`.`表示隐藏文件\n* 一个`.`代表当前目录, 两个`..`代表上级目录\n\n\n## 资源目录相关命令\n> a是显示隐藏文件, l是显示长列表格\n\n命令 | 说明\n---|---\nls 或 dir | 查看当前目录内容\nls -l  | 显示长格式目录, 有创建时间,修改信息, 文件大小\nls -a | 显示隐藏文件\nls -al | 查看目录所有对应的权限( )\npwd | 宣誓当前目录的全部路径\ncd ~ | 进入到当前分配`home`目录下的用户区域, 比如`/home/nxl`\ncd / | 进入系统的根目录\n\n\n## 文件命令\n* [old] 表示旧文件       \n* [new] 表示操作后的文件     \n* [target] 目标文件        \n* [targetDir] 目标目录\n\n命令 | 说明\n---|---\nmkdir | 创建文件夹\nrmdir | 删除文件\ntouch [new] | 创建文件\nrm [target] | 删除文件\nrm -r [targetDir] | 删除文件夹\nrm -rf * | 删除所有内容(r递归, f强制)\ncp [old] [test/new] | 复制文件\ncp [old] -R [test/new] | 复制目录 \nln -s old new  | 建立软链\n\n\n## 界面切换命令 init [number]\n命令 | 说明\n---|---\n0  | 关机\n1 | 单用户\n2 | 多用户状态没有网络服务\n3 | 多用户状态有网络服务(就是平时的小黑窗)\n4 |  系统未使用保留给用户\n5 | 图形界面\n6 | 系统重启\n\n## 服务 / 进程管理命令\n\n命令 | 说明\n---|---\nsystemctl  | 查看进程\nststemctl [ status , start , stop , restart ] nginx |  如对 nginx 执行相关命令 \ntop  | 进程资源实时状态\nps  [aux] | 进程快照\nkill [-9] pid | 杀死进程\npkill [name] | 根据进程名杀死进程\n\n\n\n\n## 网络管理命令\n命令 | 说明\n---|---\nifconfig| 查看网络接口（ interface）\nip | 网络配置工具箱\nroute | 诊断网络\n ipdown eth0 | 关闭`eth0`网卡\nipup eth0 |开启`eth0`网卡\nss -anp , grep :22 |  查找占用端口情况\nnetstat -anp , grep :22 |  查找占用端口情况\n\n\n## 命令行下载命令\n命令 | 说明\n---|---\ncurl| 查看网络接口（ interface）\nwget | 网络配置工具箱\nwget -c | 断点续传\n\n\n## vi / vim 行编辑器\n> vim是vi的增强版\n\n命令 | 说明\n---|---\nvi [target] | 编辑目标文件\ncat [target] | 查看文件内容\ni (insert) | 在当前光标所在字符的前面，转为编辑模式；\na (append) | 在当前光标所在字符的后面，转为编辑模式；\no| 在当前光标所在行的下方，新建一行，并转为输入模式；\nI|在当前光标所在行的行首，转换为输入模式\nA|在当前光标所在行的行尾，转换为输入模式\nO|在当前光标所在行的上方，新建一行，并转为输入模式；\nesc | 退出编辑, ubuntu 需要 `esc + :`\n:q| 退出编辑\n:q!| 强制退出\n:wq| 退出并保存\n\n\n## 系统操作命令\n命令 | 说明\n---|---\n！| 强制执行命令\nshutdown -h now  | 立刻关机\nshutdown -r now /reboot | 立刻重启计算机\nsu - root | 先用普通账户登录再切换 sudo临时已管理员操作\nlogout | 用户注销\n\n## 帮助命令\n命令 | 说明\n---|---\n--help  | 查看命令帮助\nman xxx | 查看详细手册\n\n## 辅助命令\n命令 | 说明\n---|---\n0  | 关机\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【Linux】命令手册.md","raw":"---\ntitle: 【Linux】命令手册\ndate: 2019-04-02 20:35:33\ncategories: Linux\ntags: Linux\n---\n\n\nlinux 只有区的概念\n\n## 终端快捷键\n| 命令 | 功能 | \n| ------ | ------ | \n| ctrl + c | 结束正在运行的程序 【 ping 、 teInet等】 | \n| ctrl + d | 结束输入或退出shell |\n| ctrl + s |  暂停屏幕输出 |\n| ctrl + q |  恢复屏幕输出 |\n| ctrl + l |  清屏， 等同于Clear |\n| ctrl + a / ctrl + e | 快速移动光标到行首 / 行尾 |\n\n\n\n## 身份命令\n| 命令 | 功能 | \n| ------ | ------ | \n| sudo | 暂时以root 用户身份运行命令 | \n| su | 切换用户身份, root身份切换不需要密码 |\n| exit |  退出当前身份或退出连接 |\n| w | 查看正在登录用户|\n\n### 路径知识\n* Linux下文件前带`.`表示隐藏文件\n* 一个`.`代表当前目录, 两个`..`代表上级目录\n\n\n## 资源目录相关命令\n> a是显示隐藏文件, l是显示长列表格\n\n命令 | 说明\n---|---\nls 或 dir | 查看当前目录内容\nls -l  | 显示长格式目录, 有创建时间,修改信息, 文件大小\nls -a | 显示隐藏文件\nls -al | 查看目录所有对应的权限( )\npwd | 宣誓当前目录的全部路径\ncd ~ | 进入到当前分配`home`目录下的用户区域, 比如`/home/nxl`\ncd / | 进入系统的根目录\n\n\n## 文件命令\n* [old] 表示旧文件       \n* [new] 表示操作后的文件     \n* [target] 目标文件        \n* [targetDir] 目标目录\n\n命令 | 说明\n---|---\nmkdir | 创建文件夹\nrmdir | 删除文件\ntouch [new] | 创建文件\nrm [target] | 删除文件\nrm -r [targetDir] | 删除文件夹\nrm -rf * | 删除所有内容(r递归, f强制)\ncp [old] [test/new] | 复制文件\ncp [old] -R [test/new] | 复制目录 \nln -s old new  | 建立软链\n\n\n## 界面切换命令 init [number]\n命令 | 说明\n---|---\n0  | 关机\n1 | 单用户\n2 | 多用户状态没有网络服务\n3 | 多用户状态有网络服务(就是平时的小黑窗)\n4 |  系统未使用保留给用户\n5 | 图形界面\n6 | 系统重启\n\n## 服务 / 进程管理命令\n\n命令 | 说明\n---|---\nsystemctl  | 查看进程\nststemctl [ status , start , stop , restart ] nginx |  如对 nginx 执行相关命令 \ntop  | 进程资源实时状态\nps  [aux] | 进程快照\nkill [-9] pid | 杀死进程\npkill [name] | 根据进程名杀死进程\n\n\n\n\n## 网络管理命令\n命令 | 说明\n---|---\nifconfig| 查看网络接口（ interface）\nip | 网络配置工具箱\nroute | 诊断网络\n ipdown eth0 | 关闭`eth0`网卡\nipup eth0 |开启`eth0`网卡\nss -anp , grep :22 |  查找占用端口情况\nnetstat -anp , grep :22 |  查找占用端口情况\n\n\n## 命令行下载命令\n命令 | 说明\n---|---\ncurl| 查看网络接口（ interface）\nwget | 网络配置工具箱\nwget -c | 断点续传\n\n\n## vi / vim 行编辑器\n> vim是vi的增强版\n\n命令 | 说明\n---|---\nvi [target] | 编辑目标文件\ncat [target] | 查看文件内容\ni (insert) | 在当前光标所在字符的前面，转为编辑模式；\na (append) | 在当前光标所在字符的后面，转为编辑模式；\no| 在当前光标所在行的下方，新建一行，并转为输入模式；\nI|在当前光标所在行的行首，转换为输入模式\nA|在当前光标所在行的行尾，转换为输入模式\nO|在当前光标所在行的上方，新建一行，并转为输入模式；\nesc | 退出编辑, ubuntu 需要 `esc + :`\n:q| 退出编辑\n:q!| 强制退出\n:wq| 退出并保存\n\n\n## 系统操作命令\n命令 | 说明\n---|---\n！| 强制执行命令\nshutdown -h now  | 立刻关机\nshutdown -r now /reboot | 立刻重启计算机\nsu - root | 先用普通账户登录再切换 sudo临时已管理员操作\nlogout | 用户注销\n\n## 帮助命令\n命令 | 说明\n---|---\n--help  | 查看命令帮助\nman xxx | 查看详细手册\n\n## 辅助命令\n命令 | 说明\n---|---\n0  | 关机\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【Linux】命令手册","published":1,"updated":"2019-09-09T16:57:46.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4so001vaas6mtn3oi95"},{"title":"【Linux】理解权限命令-chown","date":"2019-03-22T12:38:50.000Z","_content":"\n```Python\n# 更改文件属组\nchgrp [-R] 属组名  文件名\n\n# 更改文件属主 或 属组\nchown [-R] 属主名 文件名\nchown [-R] 属主名：属组名 文件名\n\n# 修改文件权限 9 个属性\n# 有两种设置方式， 一种是数字 一种是符号\n# 基本身份 owner/group/others 的各自三种权限\n# read(r 4)/write(w 2)/execute(x 1): -rwxr-xr-- = [4+2+1][4+0+1][4+0+0]=754\nchmod [-R] xyz 文件或目录\n\n# 符号修改权限\nchmod u(user)        +(加入)    r 文件或目录\n      g(group)       -(减去)    w \n      o(others)      =(设定)    x\n      a(all 全部身份)      \n\nchmod u=rwx,g=rx, o=r 文件名\nchmod a-x test1\n```\n\n\n## 图解\n![chmod命令](http://img.nixiaolei.com/2019-04-02-20-47-10.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【Linux】理解chown命令.md","raw":"---\ntitle: 【Linux】理解权限命令-chown\ndate: 2019-03-22 20:38:50\ncategories: Linux\ntags:  Linux\n---\n\n```Python\n# 更改文件属组\nchgrp [-R] 属组名  文件名\n\n# 更改文件属主 或 属组\nchown [-R] 属主名 文件名\nchown [-R] 属主名：属组名 文件名\n\n# 修改文件权限 9 个属性\n# 有两种设置方式， 一种是数字 一种是符号\n# 基本身份 owner/group/others 的各自三种权限\n# read(r 4)/write(w 2)/execute(x 1): -rwxr-xr-- = [4+2+1][4+0+1][4+0+0]=754\nchmod [-R] xyz 文件或目录\n\n# 符号修改权限\nchmod u(user)        +(加入)    r 文件或目录\n      g(group)       -(减去)    w \n      o(others)      =(设定)    x\n      a(all 全部身份)      \n\nchmod u=rwx,g=rx, o=r 文件名\nchmod a-x test1\n```\n\n\n## 图解\n![chmod命令](http://img.nixiaolei.com/2019-04-02-20-47-10.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【Linux】理解chown命令","published":1,"updated":"2019-09-09T16:57:46.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sq001yaas6oasfnd9e"},{"title":"【Node】mongose基本使用","date":"2019-04-10T14:29:46.000Z","_content":"\n\n\n\n# NodeJS 与 MongooDB\n\n> 在NodeJs 中推荐使用 Mongoose来对mongoDB 进行操作\n> mongoose 官网  http://mongoosejs.com/\n\n\n## mongoDB 的特点\n*  JSON 格式的数据存储\n*  非关系型数据库\n*  不需要和 MYSQL 之类的关系型数据库一样简表, 使用时若没有该集合会自动创建\n*  集合 => 文档 => 记录/数据字段\n*  缺点就是数据操作太灵活, 容易混入脏数据\n\n## 如何安装 mongoose \n```\nnpm install mongoose\n```\n## 导入Mongooes\n* 在 Node 中 需要先使用 require 导入mongoose 模块\n```\nconst mongoose = require('mongoose')\n```\n\n\n## 连接MongoDB\n* 这里拿连接本地的mongoDB 示范\n```\nmongoose.connect('mongod://localhost/test')\n```\n\n## 引入数据库模型骨架 Schema\n* Schema 在导入的 mongoose 对象中, 建议先将其的引用存入一个变量\n* Schema  是一种以文件形式存储的数据库模型骨架,\n* 它不具备对数据库的操作能力\n* 它可以弥补 mongoDB 对数据格式控制的不足\n```\nconst Schema = mongoose.Schema  \n```\n## 实例化 Schema\n* 既然是模型骨架,  那我们就需要 将它的骨架搭建起来\n* 以下举例 一个用户注册使用的 骨架模型\n* type (数据类型)   如: String ,Number\n* required (  是否允许为空 )\n```\nlet userSchema = new Schema({\n    name:{\n        type: String,\n        required: true\n    },\n    email: {\n        type: String\n    },\n    pwd:{\n        type: String,\n        required: true\n    }\n})\n```\n## 发布模型 Model \n* 由搭建好的模型骨架 Schema 发布生成的模型, 具有抽象属性和数据库操作的能力\n* Model 第一个参数 单数形式开头大写 , Mongoose 会自动将其转换为小写的负数形式作为文档名称\n* 如: User => users\n* 接下来你就可以对 User 为所欲为了, CURD\n```\nconst User = mongoose.model('Use',userSchema) \n```\n##  Sava 方法 保存数据\n```\nUser.save()\n\t.then(() => console.log('保存成功'));\n```\n\n## Remove 删除数据\n```\nUser.remove({ 删除条件 })\n.then(res=>{ })\n.catch(err=>{ })\n```\n## FindOne 返回匹配到的第一条数据\n* 如果用 Find 查找是返回的数组, FindOne 返回的就是个单独的对象\n* 注意返回的 的查询结果可以经过修改之后为所欲为\n```\nUser.findOne( { 查询条件 } )\n  .then(data=>{\n     //you can\n    // data.save()\n  })\n```\n## Find 查找满足条件的所有\n* 和 FinOne 不同的是 无论结果有多少条,它返回的始终是一个数组\n```\nUser.find( { 查询条件 } )\n  .then(data=>{\n     //you can\n    // data.save()\n  })\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【Node】mongose基本使用.md","raw":"---\ntitle: 【Node】mongose基本使用\ndate: 2019-04-10 22:29:46\ncategories: NodeJs\ntags: [NodeJs, MongoDB]\n---\n\n\n\n\n# NodeJS 与 MongooDB\n\n> 在NodeJs 中推荐使用 Mongoose来对mongoDB 进行操作\n> mongoose 官网  http://mongoosejs.com/\n\n\n## mongoDB 的特点\n*  JSON 格式的数据存储\n*  非关系型数据库\n*  不需要和 MYSQL 之类的关系型数据库一样简表, 使用时若没有该集合会自动创建\n*  集合 => 文档 => 记录/数据字段\n*  缺点就是数据操作太灵活, 容易混入脏数据\n\n## 如何安装 mongoose \n```\nnpm install mongoose\n```\n## 导入Mongooes\n* 在 Node 中 需要先使用 require 导入mongoose 模块\n```\nconst mongoose = require('mongoose')\n```\n\n\n## 连接MongoDB\n* 这里拿连接本地的mongoDB 示范\n```\nmongoose.connect('mongod://localhost/test')\n```\n\n## 引入数据库模型骨架 Schema\n* Schema 在导入的 mongoose 对象中, 建议先将其的引用存入一个变量\n* Schema  是一种以文件形式存储的数据库模型骨架,\n* 它不具备对数据库的操作能力\n* 它可以弥补 mongoDB 对数据格式控制的不足\n```\nconst Schema = mongoose.Schema  \n```\n## 实例化 Schema\n* 既然是模型骨架,  那我们就需要 将它的骨架搭建起来\n* 以下举例 一个用户注册使用的 骨架模型\n* type (数据类型)   如: String ,Number\n* required (  是否允许为空 )\n```\nlet userSchema = new Schema({\n    name:{\n        type: String,\n        required: true\n    },\n    email: {\n        type: String\n    },\n    pwd:{\n        type: String,\n        required: true\n    }\n})\n```\n## 发布模型 Model \n* 由搭建好的模型骨架 Schema 发布生成的模型, 具有抽象属性和数据库操作的能力\n* Model 第一个参数 单数形式开头大写 , Mongoose 会自动将其转换为小写的负数形式作为文档名称\n* 如: User => users\n* 接下来你就可以对 User 为所欲为了, CURD\n```\nconst User = mongoose.model('Use',userSchema) \n```\n##  Sava 方法 保存数据\n```\nUser.save()\n\t.then(() => console.log('保存成功'));\n```\n\n## Remove 删除数据\n```\nUser.remove({ 删除条件 })\n.then(res=>{ })\n.catch(err=>{ })\n```\n## FindOne 返回匹配到的第一条数据\n* 如果用 Find 查找是返回的数组, FindOne 返回的就是个单独的对象\n* 注意返回的 的查询结果可以经过修改之后为所欲为\n```\nUser.findOne( { 查询条件 } )\n  .then(data=>{\n     //you can\n    // data.save()\n  })\n```\n## Find 查找满足条件的所有\n* 和 FinOne 不同的是 无论结果有多少条,它返回的始终是一个数组\n```\nUser.find( { 查询条件 } )\n  .then(data=>{\n     //you can\n    // data.save()\n  })\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【Node】mongose基本使用","published":1,"updated":"2019-09-09T16:57:46.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sr0023aas6q8fj32ze"},{"title":"【NodeJs】异步IO与EventLoop","date":"2019-03-26T14:49:27.000Z","_content":"\nIO密集型就是需要频繁请求的程序，高访问量，  CPU密集型就是需要进行大量计算的 \n\n\n## 异步IO的好处\n\n* 前端通过异步IO可以消除UI堵塞。\n* 假设请求资源A的时间为M,请求资源B的时间为N.那么同步的请求耗时为M+N.如果采用异步方式占用时间为Max(M,N)。\n* 随着业务的复杂，会引入分布式系统，时间会线性的增加，M+N+...和Max(M,N…)，这会放大同步和异步之间的差异。\n* I/O是昂贵的，分布式I/O是更昂贵的。\n  * 分布式因为你读取到了这个值， 但并没有在你这台机器上， 远程的机器想要读取到那就必须要走网络， 这个过程就变长了\n* NodeJS 适用于IO密集型不适用CPU密集型\n\n\n\n\n## Node对异步IO的实现\n> 完美的异步IO应该是应该是应用程序发起非阻塞调用，无需通过遍历或者事件幻想等方式轮询。\n\nNode.js 的事件循环和在浏览器中的实现不太一样， 在Node.js 中事件循环交给了Libuv托管，  Libuv 和 v8 是分别独立的线程， 辅助Node.js 进行事件轮询\n\nNode.js 依靠v8运行javascript, 并且绑定了底层的操作系统\n\n当V8接收到用户的请求进入， 通过绑定系统接口，将事件交给Libuv处理， Libuv 将事件加入事件队列( event queue)， EventLoop 不行的旋转并执行同步事件，当遇到异步事件时，将其交给 worker Threads 线程， 比如操作文件就是交给工作线程去同步完成， 当文件操作完毕后， 根据文件描述符去获取数据， 然后将结果作为参数返回给事件队列中等候的回调函数\n\n\n![EventLoop](http://img.nixiaolei.com/2019-03-29-22-50-40.png)\n\n\n\n## 常用的Node控制异步技术手段\n> Promise 是一个语法， 规范， js只是实现了这个规范，  Promise 是一个高级接口， 创建一次，不容易修改， then就是 低级接口， 可以一直then ,处理逻辑\n\n1. Step、wind（提供等待的异步库）、Bigpipe、Q.js\n2. Async、Await\n3. Promise/Defferred 是一种先执行异步调用，延迟传递的处理方式。Promise是高级接口，事件是低级接口。低级接口可以构建更多复杂的场景，高级接口一旦定义，不太容易变化，不再有低级接口的灵活性，但对于解决问题非常有效\n4. 由于Node基于V8的原因，目前还不支持协程。协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。\n\n\n\n##  底层的知识\n1. CPU时钟周期：1/cpu主频 -> 1s/3.1 GHz\n![底层知识](http://img.nixiaolei.com/2019-03-29-22-54-03.png)\n\n\n3. 操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理。应用程序如果需要进行IO需要打开文件描述符，在进行文件和数据的读写。异步IO不带数据直接返回，要获取数据还需要通过文件描述符再次读取。\n\n![文件操作](http://img.nixiaolei.com/2019-03-29-22-54-36.png)\n\n\n","source":"_posts/【NodeJs】异步IO与EventLoop.md","raw":"---\ntitle: 【NodeJs】异步IO与EventLoop\ndate: 2019-03-26 22:49:27\ncategories: NodeJs\ntags: [ NodeJs, JavaScript ]\n---\n\nIO密集型就是需要频繁请求的程序，高访问量，  CPU密集型就是需要进行大量计算的 \n\n\n## 异步IO的好处\n\n* 前端通过异步IO可以消除UI堵塞。\n* 假设请求资源A的时间为M,请求资源B的时间为N.那么同步的请求耗时为M+N.如果采用异步方式占用时间为Max(M,N)。\n* 随着业务的复杂，会引入分布式系统，时间会线性的增加，M+N+...和Max(M,N…)，这会放大同步和异步之间的差异。\n* I/O是昂贵的，分布式I/O是更昂贵的。\n  * 分布式因为你读取到了这个值， 但并没有在你这台机器上， 远程的机器想要读取到那就必须要走网络， 这个过程就变长了\n* NodeJS 适用于IO密集型不适用CPU密集型\n\n\n\n\n## Node对异步IO的实现\n> 完美的异步IO应该是应该是应用程序发起非阻塞调用，无需通过遍历或者事件幻想等方式轮询。\n\nNode.js 的事件循环和在浏览器中的实现不太一样， 在Node.js 中事件循环交给了Libuv托管，  Libuv 和 v8 是分别独立的线程， 辅助Node.js 进行事件轮询\n\nNode.js 依靠v8运行javascript, 并且绑定了底层的操作系统\n\n当V8接收到用户的请求进入， 通过绑定系统接口，将事件交给Libuv处理， Libuv 将事件加入事件队列( event queue)， EventLoop 不行的旋转并执行同步事件，当遇到异步事件时，将其交给 worker Threads 线程， 比如操作文件就是交给工作线程去同步完成， 当文件操作完毕后， 根据文件描述符去获取数据， 然后将结果作为参数返回给事件队列中等候的回调函数\n\n\n![EventLoop](http://img.nixiaolei.com/2019-03-29-22-50-40.png)\n\n\n\n## 常用的Node控制异步技术手段\n> Promise 是一个语法， 规范， js只是实现了这个规范，  Promise 是一个高级接口， 创建一次，不容易修改， then就是 低级接口， 可以一直then ,处理逻辑\n\n1. Step、wind（提供等待的异步库）、Bigpipe、Q.js\n2. Async、Await\n3. Promise/Defferred 是一种先执行异步调用，延迟传递的处理方式。Promise是高级接口，事件是低级接口。低级接口可以构建更多复杂的场景，高级接口一旦定义，不太容易变化，不再有低级接口的灵活性，但对于解决问题非常有效\n4. 由于Node基于V8的原因，目前还不支持协程。协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。\n\n\n\n##  底层的知识\n1. CPU时钟周期：1/cpu主频 -> 1s/3.1 GHz\n![底层知识](http://img.nixiaolei.com/2019-03-29-22-54-03.png)\n\n\n3. 操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理。应用程序如果需要进行IO需要打开文件描述符，在进行文件和数据的读写。异步IO不带数据直接返回，要获取数据还需要通过文件描述符再次读取。\n\n![文件操作](http://img.nixiaolei.com/2019-03-29-22-54-36.png)\n\n\n","slug":"【NodeJs】异步IO与EventLoop","published":1,"updated":"2019-09-09T16:57:46.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ss0026aas6ivro5fc5"},{"title":"【Node】了解koa源码","date":"2019-06-16T14:29:06.000Z","_content":"\n想要查看源码， 首先我们\n```shell\nnpm i Koa -S\n```\n\n打开`node_modules`， 找到koa目录下的application 文件，\n\n我们可以看到平时使用的 app 及其相关方法就在这里, 删除了不必要的代码后， 我们看看简易版\n\n```js\nmodule.exports = class Application extends Emitter {\n\n  constructor() {\n    super();\n\n    this.proxy = false;\n    this.middleware = [];\n    this.subdomainOffset = 2;\n    this.env = process.env.NODE_ENV || 'development';\n    this.context = Object.create(context);\n    this.request = Object.create(request);\n    this.response = Object.create(response);\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n  }\n\n  listen(...args) {\n    debug('listen');\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n  }\n\n  toJSON() {\n    return only(this, [\n      'subdomainOffset',\n      'proxy',\n      'env'\n    ]);\n  }\n\n  inspect() {\n    return this.toJSON();\n  }\n\n  use(fn) {\n    this.middleware.push(fn);\n    return this;\n  }\n\n  callback() {\n    const fn = compose(this.middleware);\n\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n\n    return handleRequest;\n  }\n\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n  }\n\n  createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.response);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.state = {};\n    return context;\n  }\n\n  /**\n   * Default error handler.\n   *\n   * @param {Error} err\n   * @api private\n   */\n\n  onerror(err) {\n    const msg = err.stack || err.toString();\n    console.error(msg.replace(/^/gm, '  '));\n  }\n};\n\nfunction respond(ctx) {\n\n  const res = ctx.res;\n  let body = ctx.body;\n  const code = ctx.status;\n\n  // body: json\n  body = JSON.stringify(body);\n  res.end(body);\n}\n```\n\n\n\n\n## 灵魂部分\n```js\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  // 检测中间件类型\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0) // 执行整这个函数\n    function dispatch (i) {\n      index = i\n      // 取出当前中间件\n      let fn = middleware[i]\n      // 如果索引跟中间件长度一样了,实际上就等于访问完了, fn是空,  next 也是空, 这里应该是保证一下next 确实不存在\n      if (i === middleware.length) fn = next\n      // 最后一个中间件没有 next 就熄火了\n      if (!fn) return Promise.resolve()\n      try {\n        // fn 就是中间件,  中间件接收两个参数, context 和 Next\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        // 出错\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n\n得出的一个整体结构就是\n```Js\nconsole.log(1)\n  console.log(1)\n    console.log(1)\n      Promise.resolve() // 中间件全部执行完毕\n    console.log(1)\n  console.log(1)\nconsole.log(1)\n```\n\n\n![2019-06-16-23-33-51](http://img.nixiaolei.com/2019-06-16-23-33-51.png)\n\n","source":"_posts/【Node】了解koa源码.md","raw":"---\ntitle: 【Node】了解koa源码\ndate: 2019-06-16 22:29:06\ncategories: NodeJs\ntags: [ NodeJs, Koa, 源码 ]\n---\n\n想要查看源码， 首先我们\n```shell\nnpm i Koa -S\n```\n\n打开`node_modules`， 找到koa目录下的application 文件，\n\n我们可以看到平时使用的 app 及其相关方法就在这里, 删除了不必要的代码后， 我们看看简易版\n\n```js\nmodule.exports = class Application extends Emitter {\n\n  constructor() {\n    super();\n\n    this.proxy = false;\n    this.middleware = [];\n    this.subdomainOffset = 2;\n    this.env = process.env.NODE_ENV || 'development';\n    this.context = Object.create(context);\n    this.request = Object.create(request);\n    this.response = Object.create(response);\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n  }\n\n  listen(...args) {\n    debug('listen');\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n  }\n\n  toJSON() {\n    return only(this, [\n      'subdomainOffset',\n      'proxy',\n      'env'\n    ]);\n  }\n\n  inspect() {\n    return this.toJSON();\n  }\n\n  use(fn) {\n    this.middleware.push(fn);\n    return this;\n  }\n\n  callback() {\n    const fn = compose(this.middleware);\n\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n\n    return handleRequest;\n  }\n\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n  }\n\n  createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.response);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.state = {};\n    return context;\n  }\n\n  /**\n   * Default error handler.\n   *\n   * @param {Error} err\n   * @api private\n   */\n\n  onerror(err) {\n    const msg = err.stack || err.toString();\n    console.error(msg.replace(/^/gm, '  '));\n  }\n};\n\nfunction respond(ctx) {\n\n  const res = ctx.res;\n  let body = ctx.body;\n  const code = ctx.status;\n\n  // body: json\n  body = JSON.stringify(body);\n  res.end(body);\n}\n```\n\n\n\n\n## 灵魂部分\n```js\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  // 检测中间件类型\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0) // 执行整这个函数\n    function dispatch (i) {\n      index = i\n      // 取出当前中间件\n      let fn = middleware[i]\n      // 如果索引跟中间件长度一样了,实际上就等于访问完了, fn是空,  next 也是空, 这里应该是保证一下next 确实不存在\n      if (i === middleware.length) fn = next\n      // 最后一个中间件没有 next 就熄火了\n      if (!fn) return Promise.resolve()\n      try {\n        // fn 就是中间件,  中间件接收两个参数, context 和 Next\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        // 出错\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n\n得出的一个整体结构就是\n```Js\nconsole.log(1)\n  console.log(1)\n    console.log(1)\n      Promise.resolve() // 中间件全部执行完毕\n    console.log(1)\n  console.log(1)\nconsole.log(1)\n```\n\n\n![2019-06-16-23-33-51](http://img.nixiaolei.com/2019-06-16-23-33-51.png)\n\n","slug":"【Node】了解koa源码","published":1,"updated":"2019-09-09T16:57:46.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4st002baas6ns1zj87k"},{"title":"【PostCss】使用明天的CSS","date":"2019-03-16T05:30:24.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\n通过PostCss作为CSS的后处理器， 可以根据浏览器的市场份额， 选择性的将一些最新的CSS新特性编译成浏览器支持的语法\n\n当然国内的情况有点不一样\n\n## 新特性举例\n\n比如这个CSS变量:\n他存储了媒体查询的规则， 在多个媒体查询的情况下就不用重复写了\n```CSS\n@custom-media --viewport-medium (width <= 50rem);\n\n@media (--viewport-medium) {\n  body { font-size: calc(var(--fontSize) * 1.2); }\n}\n\n```\n\n那这个属性浏览器兼容不理想怎么办？ 别担心， 交给PostCss, 经过处理， 我们可以看到，生成了一个规规矩矩的媒体查询代码\n\n```CSS\n@media (max-width: 50rem) {\n  body { font-size: 1.2rem; }\n}\n```\n\n## 更多演示\n> 编译前后以 ------ 分割\n\n\n自定义选择器\n```CSS\n@custom-selector :--heading h1, h2, h3, h4, h5, h6;\n:--heading { margin-top: 0 }\n/* ------------------------------------ */\nh1,h2,h3,h4,h5,h6 { margin-top: 0 }\n```\n\n自动一倍图(1X)和二倍图(2X)\n```CSS\n/* image-set function */\n.foo {\n  background-image:\n    image-set(\n      url(img/test.png) 1x,\n      url(img/test-2x.png) 2x\n    );\n}\n\n/* ------------------------------------ */\n\n/* 默认状态 */\n.foo {\n    background-image:\n      url(img/test.png);\n}\n\n/* 满足 设备上物理像素和设备独立像素( device-independent pixels (dips) )的比例  */\n@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {\n.foo {\n    background-image:\n      url(img/test-2x.png);\n}\n}\n```\n\n\n`any-link`, 补齐标签的剩余的所有状态， 这是为了防止某些样式不生效\n```CSS\na {\ncolor: var(--highlightColor);\ntransition: color 1s; /* autoprefixed ! */\n}\na:hover { color: gray(255, 50%) }\na:active { color: rebeccapurple }\na:focus { background-color: rgb(255 153 0 / 33%); outline: 3px solid hsl(1turn 60% 50%); }\na:any-link { color: color(var(--highlightColor) blackness(+20%)) }\n\n/* --------------------------------- */\n\na {\n  color: rgb(89, 185, 204);\n  -webkit-transition: color 1s;\n  transition: color 1s; /* autoprefixed ! */\n}\na:hover { color: rgba(255, 255, 255, 0.5) }\na:active { color: #639 }\na:focus { \n  background-color: rgba(255, 153, 0, .33); \n  outline: 3px solid hsl(360, 60%, 50%); \n}\na:link,a:visited { color: rgb(89, 142, 153) }\n```\n\n\n还有很多， 不一一举例了， 比如：\n* 各个浏览器的滤镜`filter`兼容\n* 选择器正则\n* css嵌套\n\n## 如何让PostCS支持嵌套\n> 本环境基于webpack\n\nnpm地址:\n* https://www.npmjs.com/package/postcss\n* https://www.npmjs.com/package/postcss-loader\n\n\n```CSS\n.container {\n  /* 一定要带上 & 才会编译 */\n  & .menu {\n    height: 40px;\n    background: sandybrown; \n    & .menu--item {\n      height: 40px;\n      color: skyblue;\n      & .menu--item__active {\n        color: pink;\n      }\n    }\n  }\n}\n```\n\n\n\n\n首先在项目的根目录中创建一个文件`postcss.config.js`\n\n相关依赖安装就不说了， 真的缺了也会报错提示的\n\n我们将会在里面做`PostCSS`的相关配置\n\n```JavaScript\nmodule.exports = {\n  plugins: [\n    require('postcss-nested')\n  ]\n}\n```\n\n然后接下来是配置 Loader ，\n\n进入webpack 配置css loader 的地方， 我们在css loader 后面加上PostCss 的loader\n```JavaScript\nrules: [\n  {\n    test: /\\.css$/,\n    use: [\n      {\n        loader: 'css-loader',\n      },\n      // --------------新增区域---------------\n      {\n        loader: 'postcss-loader',\n        options: {\n          ident: 'postcss',\n          plugins: (loader) => [\n            require('postcss-preset-env')({\n              /* 这里要改成 0  否则不一定编译嵌套 */\n              stage: 0,\n              features: {\n                'nesting-rules': true\n              }\n            })\n          ]\n        }\n      }\n      // --------------新增区域---------------\n    ]\n  }\n]\n```\n\n像这样，记得把 `stage` 这个参数修改为 0 ， 因为PostCss 会根据这个参数分为好几个阶段，阶段太高它是不处理嵌套的。\n\n\n我们运行一下看看\n\n```CSS\n.container {\n  /* 一定要带上 & 才会编译 */\n}\n.container .menu {\n  height: 40px;\n  background: sandybrown\n}\n.container .menu .menu--item {\n  height: 40px;\n  color: skyblue\n}\n.container .menu .menu--item .menu--item__active {\n  color: pink;\n}\n```\n\n大功告成😄~\n\n想知道有用的PostCSS的插件大纲，可以在本站内搜索: `CSS插件` \n\n\n\n\n\n\n## 相关的网站\n> PostCss: https://postcss.org/\n> css next: http://cssnext.io/\n\n","source":"_posts/【PostCss】使用明天的CSS.md","raw":"---\ntitle: 【PostCss】使用明天的CSS\ndate: 2019-03-16 13:30:24\ncategories: CSS\ntags: [css, PostCss]\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\n通过PostCss作为CSS的后处理器， 可以根据浏览器的市场份额， 选择性的将一些最新的CSS新特性编译成浏览器支持的语法\n\n当然国内的情况有点不一样\n\n## 新特性举例\n\n比如这个CSS变量:\n他存储了媒体查询的规则， 在多个媒体查询的情况下就不用重复写了\n```CSS\n@custom-media --viewport-medium (width <= 50rem);\n\n@media (--viewport-medium) {\n  body { font-size: calc(var(--fontSize) * 1.2); }\n}\n\n```\n\n那这个属性浏览器兼容不理想怎么办？ 别担心， 交给PostCss, 经过处理， 我们可以看到，生成了一个规规矩矩的媒体查询代码\n\n```CSS\n@media (max-width: 50rem) {\n  body { font-size: 1.2rem; }\n}\n```\n\n## 更多演示\n> 编译前后以 ------ 分割\n\n\n自定义选择器\n```CSS\n@custom-selector :--heading h1, h2, h3, h4, h5, h6;\n:--heading { margin-top: 0 }\n/* ------------------------------------ */\nh1,h2,h3,h4,h5,h6 { margin-top: 0 }\n```\n\n自动一倍图(1X)和二倍图(2X)\n```CSS\n/* image-set function */\n.foo {\n  background-image:\n    image-set(\n      url(img/test.png) 1x,\n      url(img/test-2x.png) 2x\n    );\n}\n\n/* ------------------------------------ */\n\n/* 默认状态 */\n.foo {\n    background-image:\n      url(img/test.png);\n}\n\n/* 满足 设备上物理像素和设备独立像素( device-independent pixels (dips) )的比例  */\n@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {\n.foo {\n    background-image:\n      url(img/test-2x.png);\n}\n}\n```\n\n\n`any-link`, 补齐标签的剩余的所有状态， 这是为了防止某些样式不生效\n```CSS\na {\ncolor: var(--highlightColor);\ntransition: color 1s; /* autoprefixed ! */\n}\na:hover { color: gray(255, 50%) }\na:active { color: rebeccapurple }\na:focus { background-color: rgb(255 153 0 / 33%); outline: 3px solid hsl(1turn 60% 50%); }\na:any-link { color: color(var(--highlightColor) blackness(+20%)) }\n\n/* --------------------------------- */\n\na {\n  color: rgb(89, 185, 204);\n  -webkit-transition: color 1s;\n  transition: color 1s; /* autoprefixed ! */\n}\na:hover { color: rgba(255, 255, 255, 0.5) }\na:active { color: #639 }\na:focus { \n  background-color: rgba(255, 153, 0, .33); \n  outline: 3px solid hsl(360, 60%, 50%); \n}\na:link,a:visited { color: rgb(89, 142, 153) }\n```\n\n\n还有很多， 不一一举例了， 比如：\n* 各个浏览器的滤镜`filter`兼容\n* 选择器正则\n* css嵌套\n\n## 如何让PostCS支持嵌套\n> 本环境基于webpack\n\nnpm地址:\n* https://www.npmjs.com/package/postcss\n* https://www.npmjs.com/package/postcss-loader\n\n\n```CSS\n.container {\n  /* 一定要带上 & 才会编译 */\n  & .menu {\n    height: 40px;\n    background: sandybrown; \n    & .menu--item {\n      height: 40px;\n      color: skyblue;\n      & .menu--item__active {\n        color: pink;\n      }\n    }\n  }\n}\n```\n\n\n\n\n首先在项目的根目录中创建一个文件`postcss.config.js`\n\n相关依赖安装就不说了， 真的缺了也会报错提示的\n\n我们将会在里面做`PostCSS`的相关配置\n\n```JavaScript\nmodule.exports = {\n  plugins: [\n    require('postcss-nested')\n  ]\n}\n```\n\n然后接下来是配置 Loader ，\n\n进入webpack 配置css loader 的地方， 我们在css loader 后面加上PostCss 的loader\n```JavaScript\nrules: [\n  {\n    test: /\\.css$/,\n    use: [\n      {\n        loader: 'css-loader',\n      },\n      // --------------新增区域---------------\n      {\n        loader: 'postcss-loader',\n        options: {\n          ident: 'postcss',\n          plugins: (loader) => [\n            require('postcss-preset-env')({\n              /* 这里要改成 0  否则不一定编译嵌套 */\n              stage: 0,\n              features: {\n                'nesting-rules': true\n              }\n            })\n          ]\n        }\n      }\n      // --------------新增区域---------------\n    ]\n  }\n]\n```\n\n像这样，记得把 `stage` 这个参数修改为 0 ， 因为PostCss 会根据这个参数分为好几个阶段，阶段太高它是不处理嵌套的。\n\n\n我们运行一下看看\n\n```CSS\n.container {\n  /* 一定要带上 & 才会编译 */\n}\n.container .menu {\n  height: 40px;\n  background: sandybrown\n}\n.container .menu .menu--item {\n  height: 40px;\n  color: skyblue\n}\n.container .menu .menu--item .menu--item__active {\n  color: pink;\n}\n```\n\n大功告成😄~\n\n想知道有用的PostCSS的插件大纲，可以在本站内搜索: `CSS插件` \n\n\n\n\n\n\n## 相关的网站\n> PostCss: https://postcss.org/\n> css next: http://cssnext.io/\n\n","slug":"【PostCss】使用明天的CSS","published":1,"updated":"2019-09-09T16:57:46.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4su002daas6y98ngzgg"},{"title":"【React】Flux架构是什么","date":"2019-04-16T13:30:19.000Z","_content":"\n为了避免`React`的`state`混乱， 让`React`专注于`ui`,  `Flux`就应运而生了\n\nFlux是一种架构思想， 专门解决软件的结构问题。他跟MVC架构是同一类东西， 但是更加简单和清晰。\n\n## Flux构成\n* `View`视图层 \n* `Action`(动作): 视图层发出的消息(比如mouseClick)\n* `Dispatcher`(派发器): 用来接收`Actions`, 执行回调函数\n* `Store`(数据层): 用来存放应用的状态， 一旦发生变动， 就提醒`Views`要更新页面\n\n![Flux构成](http://img.nixiaolei.com/2019-04-16-22-00-28.png)\n\nFlux 的最大特点，就是数据的\"单向流动\"。\n\n1. 用户访问 View\n2. View 发出用户的 Action\n3. Dispatcher 收到 Action，要求 Store 进行相应的更新\n4. Store 更新后，发出一个\"change\"事件\n5. View 收到\"change\"事件后，更新页面\n\n上面过程中，数据总是\"单向流动\"，任何相邻的部分都不会发生数据的\"双向流动\"。这保证了流程的清晰。\n\n\n\n## Flux与Redux\n因为`Flux`的不好理解， 所以社区做出了很多的努力， 常用的`Redux`就是`Flux`的其中一种实现\n\n\n\n\n\n\n\n\n\n\n优质文献\n> [阮一峰的flux](https://www.cnblogs.com/fliu/articles/5245923.html)\n\n\n","source":"_posts/【React】Flux架构是什么.md","raw":"---\ntitle: 【React】Flux架构是什么\ndate: 2019-04-16 21:30:19\ncategories: React\ntags: React\n---\n\n为了避免`React`的`state`混乱， 让`React`专注于`ui`,  `Flux`就应运而生了\n\nFlux是一种架构思想， 专门解决软件的结构问题。他跟MVC架构是同一类东西， 但是更加简单和清晰。\n\n## Flux构成\n* `View`视图层 \n* `Action`(动作): 视图层发出的消息(比如mouseClick)\n* `Dispatcher`(派发器): 用来接收`Actions`, 执行回调函数\n* `Store`(数据层): 用来存放应用的状态， 一旦发生变动， 就提醒`Views`要更新页面\n\n![Flux构成](http://img.nixiaolei.com/2019-04-16-22-00-28.png)\n\nFlux 的最大特点，就是数据的\"单向流动\"。\n\n1. 用户访问 View\n2. View 发出用户的 Action\n3. Dispatcher 收到 Action，要求 Store 进行相应的更新\n4. Store 更新后，发出一个\"change\"事件\n5. View 收到\"change\"事件后，更新页面\n\n上面过程中，数据总是\"单向流动\"，任何相邻的部分都不会发生数据的\"双向流动\"。这保证了流程的清晰。\n\n\n\n## Flux与Redux\n因为`Flux`的不好理解， 所以社区做出了很多的努力， 常用的`Redux`就是`Flux`的其中一种实现\n\n\n\n\n\n\n\n\n\n\n优质文献\n> [阮一峰的flux](https://www.cnblogs.com/fliu/articles/5245923.html)\n\n\n","slug":"【React】Flux架构是什么","published":1,"updated":"2019-09-09T16:57:46.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sv002gaas64hc6o073"},{"title":"【React】immutable 内部实现原理","date":"2019-07-03T12:01:04.000Z","_content":"\n## immutable.js\nImmutable.js 采用了持久化数据结构（每次修改后我们都会得到一个新的版本，且旧版本可以完好保留），保证每一个对象都是不可变的，任何添加、修改、删除等操作都会生成一个新的对象，且通过结构共享(对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是结构共享)等方式大幅提高性能。\n\n\n## 原理解读\n1. Vector trie 原理是，使用二叉树，将所有值按照顺序，从左到右存放于叶子节点，当需要更新数据\n时，只将其更新路径上的节点生成新的对象，没有改变的节点继续共用。\n2. Immutable.js 实现了一个hash函数，可以把一个值转换成相应数字。接下来HAMT\n3. Hash array maps trie 压缩treeImmutablejs 对于 Map，使用了这种方式优化，并且通过树宽与树高的压缩，形成了文中例图中的效果（10010 10000 聚合成了一个节点，并且移除了同级的空节点）。\n\n![2019-07-03-20-25-37](http://img.nixiaolei.com/2019-07-03-20-25-37.png)\n\n![2019-07-03-20-43-09](http://img.nixiaolei.com/2019-07-03-20-43-09.png)\n\n## 查找原理\n可以看到上面那张图一样， 查找 `tea`, 先找到 `t` 再找到`e` ,再往下找到`a`， 根据这个查找路径， 找到对应的值\n\n二进制的查找方式也是这个原理， 如下图所示， 左上角的值与二进制路径互相映射\n\n![2019-07-03-20-54-59](http://img.nixiaolei.com/2019-07-03-20-54-59.png)\n\n\n## 分区\n1. 数字分区（Digit partitioning）指我们把一个 key 作为数字对应到一棵前缀树上。\n2. 位分区（Bit Partitioning）数字分区的方法是有点耗时的，在每一层我们都要进行两次除法一次取\n模，显然这样并不高效，位分区就是对其的一种优化。位分区是建立在数字分区的基础上的，所有以2的\n整数次幂（2，4，8，16，32…）为基数的数字分区前缀树，都可以转为位分区。基于一些位运算相关\n的知识，我们就能避免一些耗时的计算。数字分区把 key 拆分成一个个数字，而位分区把 key 分成一组\n组 bit。以一个 32 路的前缀树为例，数字分区的方法是把 key 以 32 为基数拆分（实际上就是 32 进\n制），而位分区是把它以 5 个 bits 拆分，因为32 = 25，那我们就可以把 32 进制数的每一位看做 5 个二\n进制位 。\n\n\n## bitMap\n> bitMap学习链接：https://blog.csdn.net/moakun/article/details/79927791\n\n\n利用位运算来快速查找计算，  得出结果， immutable 也正是利用了这一点， 在代码逻辑的关键处大量的使用了位运算\n\n## 为什么选择32位\nImmutable.js 的 Vector Trie 采用了 32 作为数组的长度，我们解释了由于采用了位分区，该数字只能\n是2的整数次幂，所以不能是 31、33 等。但8、16、64等等呢？这是通过实际测试得出的，图中分别是\n查找和更新的时间，看上去似乎 8 或 16 更好？考虑到平时的使用中，查找比更新频次高很多，所以\nImmutable.js 选择了 32\n\n\n![2019-07-03-21-36-06](http://img.nixiaolei.com/2019-07-03-21-36-06.png)\n\n\n## 32位如何处理\n\nimmutable 会把32位挨个转换为二进制， 因为 2^5 = 32， 类似如下图， 每一位都会转换为相应的二进制用于快速位运算\n\n![2019-07-03-21-36-54](http://img.nixiaolei.com/2019-07-03-21-36-54.png)\n\n\n## 核心原理\n1. Bitmap 一种数据结构，代表了有限域中的稠集（dense set），每一个元素至少出现一次，没有其他\n的数据和元素相关联。在索引，数据压缩等方面有广泛应用。\n\n2. HashArrayMapNode，拥有的子节点数量 ＞16 ，拥有的数组长度为 32\n3. BitmapIndexedNode，拥有的子节点数量 ≤16 ，拥有的数组长度与子节点数量一致，经由 bitmap\n压缩\n4. ValueNode，叶子节点，存储 key 和 value\n5. HashCollisionNode的节点去处理发生冲突的键值\n\n\n## 经典的代码段\n```Js\n//计算二进制中1的数量\nfunction popCount(x) {\n  x -= (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n```","source":"_posts/【React】immutable-内部实现原理.md","raw":"---\ntitle: 【React】immutable 内部实现原理\ndate: 2019-07-03 20:01:04\ncategories: immutable\ntags: immutable\n---\n\n## immutable.js\nImmutable.js 采用了持久化数据结构（每次修改后我们都会得到一个新的版本，且旧版本可以完好保留），保证每一个对象都是不可变的，任何添加、修改、删除等操作都会生成一个新的对象，且通过结构共享(对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是结构共享)等方式大幅提高性能。\n\n\n## 原理解读\n1. Vector trie 原理是，使用二叉树，将所有值按照顺序，从左到右存放于叶子节点，当需要更新数据\n时，只将其更新路径上的节点生成新的对象，没有改变的节点继续共用。\n2. Immutable.js 实现了一个hash函数，可以把一个值转换成相应数字。接下来HAMT\n3. Hash array maps trie 压缩treeImmutablejs 对于 Map，使用了这种方式优化，并且通过树宽与树高的压缩，形成了文中例图中的效果（10010 10000 聚合成了一个节点，并且移除了同级的空节点）。\n\n![2019-07-03-20-25-37](http://img.nixiaolei.com/2019-07-03-20-25-37.png)\n\n![2019-07-03-20-43-09](http://img.nixiaolei.com/2019-07-03-20-43-09.png)\n\n## 查找原理\n可以看到上面那张图一样， 查找 `tea`, 先找到 `t` 再找到`e` ,再往下找到`a`， 根据这个查找路径， 找到对应的值\n\n二进制的查找方式也是这个原理， 如下图所示， 左上角的值与二进制路径互相映射\n\n![2019-07-03-20-54-59](http://img.nixiaolei.com/2019-07-03-20-54-59.png)\n\n\n## 分区\n1. 数字分区（Digit partitioning）指我们把一个 key 作为数字对应到一棵前缀树上。\n2. 位分区（Bit Partitioning）数字分区的方法是有点耗时的，在每一层我们都要进行两次除法一次取\n模，显然这样并不高效，位分区就是对其的一种优化。位分区是建立在数字分区的基础上的，所有以2的\n整数次幂（2，4，8，16，32…）为基数的数字分区前缀树，都可以转为位分区。基于一些位运算相关\n的知识，我们就能避免一些耗时的计算。数字分区把 key 拆分成一个个数字，而位分区把 key 分成一组\n组 bit。以一个 32 路的前缀树为例，数字分区的方法是把 key 以 32 为基数拆分（实际上就是 32 进\n制），而位分区是把它以 5 个 bits 拆分，因为32 = 25，那我们就可以把 32 进制数的每一位看做 5 个二\n进制位 。\n\n\n## bitMap\n> bitMap学习链接：https://blog.csdn.net/moakun/article/details/79927791\n\n\n利用位运算来快速查找计算，  得出结果， immutable 也正是利用了这一点， 在代码逻辑的关键处大量的使用了位运算\n\n## 为什么选择32位\nImmutable.js 的 Vector Trie 采用了 32 作为数组的长度，我们解释了由于采用了位分区，该数字只能\n是2的整数次幂，所以不能是 31、33 等。但8、16、64等等呢？这是通过实际测试得出的，图中分别是\n查找和更新的时间，看上去似乎 8 或 16 更好？考虑到平时的使用中，查找比更新频次高很多，所以\nImmutable.js 选择了 32\n\n\n![2019-07-03-21-36-06](http://img.nixiaolei.com/2019-07-03-21-36-06.png)\n\n\n## 32位如何处理\n\nimmutable 会把32位挨个转换为二进制， 因为 2^5 = 32， 类似如下图， 每一位都会转换为相应的二进制用于快速位运算\n\n![2019-07-03-21-36-54](http://img.nixiaolei.com/2019-07-03-21-36-54.png)\n\n\n## 核心原理\n1. Bitmap 一种数据结构，代表了有限域中的稠集（dense set），每一个元素至少出现一次，没有其他\n的数据和元素相关联。在索引，数据压缩等方面有广泛应用。\n\n2. HashArrayMapNode，拥有的子节点数量 ＞16 ，拥有的数组长度为 32\n3. BitmapIndexedNode，拥有的子节点数量 ≤16 ，拥有的数组长度与子节点数量一致，经由 bitmap\n压缩\n4. ValueNode，叶子节点，存储 key 和 value\n5. HashCollisionNode的节点去处理发生冲突的键值\n\n\n## 经典的代码段\n```Js\n//计算二进制中1的数量\nfunction popCount(x) {\n  x -= (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n```","slug":"【React】immutable-内部实现原理","published":1,"updated":"2019-09-09T16:57:46.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sx002kaas6p3ykl5gz"},{"title":"【React】memo为函数组件创造shouldComponentUpdate","date":"2019-04-12T14:09:22.000Z","_content":"\n\n`React v16.6.0`出了一些新的包装函数(`wrapped functions`)，一种用于函数组件`PureComponent / shouldComponentUpdate`形式的`React.memo()`\n\n> React.memo()是一个高阶函数，它与 React.PureComponent类似，但是一个函数组件而非一个类。\n\n利用`memo`我们就能函数组件创造为`Purecomponent`\n\n总之就是， 在今天，我们也能为函数组件做性能优化了， 就让我们来演示下具体如何使用\n\n## 先创建一个普通的函数组件\n\n这是一个最普通的函数组件， 接收一个`name`的`props`参数\n```Js\n// 创建一个函数组件\nfunction Child({ name }) {\n  console.log('I am rendering')\n  return <div>Memo组件 name => { name }</div>\n}\n```\n## 显式地shouldComponentUpdate\n然后我们为其量身定制一个`shouldComponentUpdate`\n```Js\nfunction areEqual(prevProps, nextProps) {\n  if( prevProps.name == nextProps.name ) {\n    return true\n  } else {\n    return false\n  }\n}\n```\n## 产生出一个新组件\n利用`memo`这个高阶函数，我们创造出一个新的组件，这将会是个拥有`shouldComponentUpdate`的函数组件\n```Js\nimport React, { memo, Component } from 'react'\nconst DemoComponent = memo(Child, areEqual)\n```\n\n## 查看结果\n最后我们将其放入`render`函数， 让它渲染出来， 并传入刚刚设定的`name`参数\n```Js\n\nexport default class Menotest extends Component {\n  render() {\n    return (\n      <div>\n        {/* seconds作为Props传入 */}\n        <DemoComponent name=\"小明\" />\n      </div>\n    )\n  }\n}\n```\n\n\n结果如下:\n![2019-04-12-22-30-31](http://img.nixiaolei.com/2019-04-12-22-30-31.png)\n\n*** \n\n## 完整代码\n```Js\nimport React, { memo, Component } from 'react'\n\n// 创建一个函数组件\nfunction Child({ name }) {\n  console.log('I am rendering')\n  return <div>Memo组件 name => { name }</div>\n}\n// 注意 函数组件没有state , 显式的shouldComponentUpdate\nfunction areEqual(prevProps, nextProps) {\n  if( prevProps.name == nextProps.name ) {\n    return true\n  } else {\n    return false\n  }\n}\nconst DemoComponent = memo(Child, areEqual)\n\nexport default class Menotest extends Component {\n  render() {\n    return (\n      <div>\n        {/* seconds作为Props传入 */}\n        <DemoComponent name=\"小明\" />\n      </div>\n    )\n  }\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/【React】memo为函数组件创造shouldComponentUpdate.md","raw":"---\ntitle: 【React】memo为函数组件创造shouldComponentUpdate\ndate: 2019-04-12 22:09:22\ncategories: React \ntags: [React, 性能优化]\n---\n\n\n`React v16.6.0`出了一些新的包装函数(`wrapped functions`)，一种用于函数组件`PureComponent / shouldComponentUpdate`形式的`React.memo()`\n\n> React.memo()是一个高阶函数，它与 React.PureComponent类似，但是一个函数组件而非一个类。\n\n利用`memo`我们就能函数组件创造为`Purecomponent`\n\n总之就是， 在今天，我们也能为函数组件做性能优化了， 就让我们来演示下具体如何使用\n\n## 先创建一个普通的函数组件\n\n这是一个最普通的函数组件， 接收一个`name`的`props`参数\n```Js\n// 创建一个函数组件\nfunction Child({ name }) {\n  console.log('I am rendering')\n  return <div>Memo组件 name => { name }</div>\n}\n```\n## 显式地shouldComponentUpdate\n然后我们为其量身定制一个`shouldComponentUpdate`\n```Js\nfunction areEqual(prevProps, nextProps) {\n  if( prevProps.name == nextProps.name ) {\n    return true\n  } else {\n    return false\n  }\n}\n```\n## 产生出一个新组件\n利用`memo`这个高阶函数，我们创造出一个新的组件，这将会是个拥有`shouldComponentUpdate`的函数组件\n```Js\nimport React, { memo, Component } from 'react'\nconst DemoComponent = memo(Child, areEqual)\n```\n\n## 查看结果\n最后我们将其放入`render`函数， 让它渲染出来， 并传入刚刚设定的`name`参数\n```Js\n\nexport default class Menotest extends Component {\n  render() {\n    return (\n      <div>\n        {/* seconds作为Props传入 */}\n        <DemoComponent name=\"小明\" />\n      </div>\n    )\n  }\n}\n```\n\n\n结果如下:\n![2019-04-12-22-30-31](http://img.nixiaolei.com/2019-04-12-22-30-31.png)\n\n*** \n\n## 完整代码\n```Js\nimport React, { memo, Component } from 'react'\n\n// 创建一个函数组件\nfunction Child({ name }) {\n  console.log('I am rendering')\n  return <div>Memo组件 name => { name }</div>\n}\n// 注意 函数组件没有state , 显式的shouldComponentUpdate\nfunction areEqual(prevProps, nextProps) {\n  if( prevProps.name == nextProps.name ) {\n    return true\n  } else {\n    return false\n  }\n}\nconst DemoComponent = memo(Child, areEqual)\n\nexport default class Menotest extends Component {\n  render() {\n    return (\n      <div>\n        {/* seconds作为Props传入 */}\n        <DemoComponent name=\"小明\" />\n      </div>\n    )\n  }\n}\n```\n\n\n\n\n\n\n\n","slug":"【React】memo为函数组件创造shouldComponentUpdate","published":1,"updated":"2019-09-09T16:57:46.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sy002oaas67xv6izcz"},{"title":"【React】PureComponent解决了什么问题","date":"2019-04-04T07:10:16.000Z","_content":"\n`PureComponent` 是和 `shouldComponentUpdate`这个生命周期息息相关的\n\n## React 重新渲染问题\n\n`React`中，当父组件中触发`setState`， 尽管未修改任何 `state` 中的值也会引起所有子组件的重新渲染， 更何况是修改了某个`state`\n\n还有， 当父组件传给子组件的`props` 发生改变， 不管该`props`是否被子组件用到， 都会去重新渲染子组件。\n\n\n> 其实我们也可以想得到， setState 会去触发 render， 所以父组件`render`函数中的子组件都会被重新渲染， 因此也就无关 `state` 与 `props`了\n\n\n针对这个问题我实现了个例子， 来看一下下面这个例子\n\n### 实现下问题\n> setState但未修改任何state\n\n父组件触发 `setState` 方法, 但未更新任何`state`\n\n```JsX\nimport TodoItem from './components/todoItem/todoItem'\n// 父组件代码\nclass TodoList extends Component {\n  noChange() {\n    console.log('触发setState')\n    this.setState(() => ({\n    }))\n  }\n  render() {\n    const { todoList } = this.state\n    return (\n      <div className=\"wrap\">\n        <button onClick={() => this.noChange()}>没有变化的setState</button>\n        {\n          todoList.map( (item,index) => <TodoItem key={index}  data={item} /> )\n        }\n      </div>\n    )\n  }\n}\n\n// 子组件代码\nclass TodoItem extends Component {\n  constructor(props) {\n    super(props)\n  }\n\n  componentWillUpdate() {\n    console.log('我被更新了')\n  }\n\n  render() {\n    return (\n      <div>\n        { this.props.data.thing }\n      </div>\n    )\n  }\n}\n```\n\n\n\n我们在子组件中预留了`componentWillUpdate` 方法， 用来监测子组件是否被跟新\n\n```JavaScript\ncomponentWillUpdate() {\n  console.log('我被更新了')\n}\n```\n\n实验结果: \n\n![noChangeState](http://img.nixiaolei.com/noChangeState.gif)\n\n\n\n我们可以看到, 每一次的点击都引起了子组件的`update`\n\n\n### 冷静分析问题\n\n无故的重复`update`, 这会导致业务规模扩大后十分的影响性能.\n\n为此我监测了一下页面的重绘事件:\n> 绿色区域是浏览器发成重绘的地方\n\n![noRePaint](http://img.nixiaolei.com/noRePaint.gif)\n\n可以看到`todoList`其实并没有引起浏览器的`repaint` , 因此可以推测, 实际`dom`并没有更新这在渲染页面前被`dom diff`给排除掉了, 因此性能损耗在了转换成`Virtual DOM`的过程中 \n\n\n\n## shouldComponentUpdate\n> shouldComponentUpdate(nextProps, nextState)， 默认返回true\n\n`shouldComponentUpdate` 是 `React` 中做性能优化的重要手段， 看这个英文翻译我们大概也能猜出个一二来 --- '组件是否跟新？'\n\n`React` 会根据 `shouldComponentUpdate` 的返回结果来决定该组件是否重新渲染， 如果返回`True`就渲染，  如果返回`False`就重新渲染\n\n基于这个特性, 我们来修改一下上面问题中的代码\n\n```JavaScript\n// 父组件无变化, 因此省略\n\n// 子组件代码\nclass TodoItem extends Component {\n\n  // ...省略其他原有的代码\n\n\n  // --------- 新增代码 -------------\n  shouldComponentUpdate(nextProps, nextState) {\n    // 判断下 当前 props传入的data.thing  是否和新传入的  data.thing 相同\n    return  this.props.data.thing !== nextProps.data.thing\n  }\n  // --------- 新增代码 -------------\n}\n```\n\n实验结果:\n![addShouUpdate](http://img.nixiaolei.com/addShouUpdate.gif)\n\n我们可以看到`update`事件确实消失了\n\n\n\n## PureComponent\n看了`shouldComponentUpdate`函数的作用, 就能够理解`PureComponent`了?  它其实就是在帮我们做这样一件事:\n\n**自动的帮我们编写 `shouldComponentUpdate` 方法, 避免我们为每个组件都编写一次的麻烦**\n\n我们只需要这样, 就可以一步到位\n```JavaScript\nimport React, { PureComponent } from 'react'\nclass TodoItem extends PureComponent {\n}\n```\n\n\n***\n\n是不是感觉`PureComponent`很强大, 但`PureComponent`并不完美, \n\n其实它还有一些潜藏的问题, 如果您想要继续了解, 请在站内搜索 `immutable`\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【React】PureComponent解决了什么问题.md","raw":"---\ntitle: 【React】PureComponent解决了什么问题\ndate: 2019-04-04 15:10:16\ncategories: React\ntags: [React, 性能优化]\n---\n\n`PureComponent` 是和 `shouldComponentUpdate`这个生命周期息息相关的\n\n## React 重新渲染问题\n\n`React`中，当父组件中触发`setState`， 尽管未修改任何 `state` 中的值也会引起所有子组件的重新渲染， 更何况是修改了某个`state`\n\n还有， 当父组件传给子组件的`props` 发生改变， 不管该`props`是否被子组件用到， 都会去重新渲染子组件。\n\n\n> 其实我们也可以想得到， setState 会去触发 render， 所以父组件`render`函数中的子组件都会被重新渲染， 因此也就无关 `state` 与 `props`了\n\n\n针对这个问题我实现了个例子， 来看一下下面这个例子\n\n### 实现下问题\n> setState但未修改任何state\n\n父组件触发 `setState` 方法, 但未更新任何`state`\n\n```JsX\nimport TodoItem from './components/todoItem/todoItem'\n// 父组件代码\nclass TodoList extends Component {\n  noChange() {\n    console.log('触发setState')\n    this.setState(() => ({\n    }))\n  }\n  render() {\n    const { todoList } = this.state\n    return (\n      <div className=\"wrap\">\n        <button onClick={() => this.noChange()}>没有变化的setState</button>\n        {\n          todoList.map( (item,index) => <TodoItem key={index}  data={item} /> )\n        }\n      </div>\n    )\n  }\n}\n\n// 子组件代码\nclass TodoItem extends Component {\n  constructor(props) {\n    super(props)\n  }\n\n  componentWillUpdate() {\n    console.log('我被更新了')\n  }\n\n  render() {\n    return (\n      <div>\n        { this.props.data.thing }\n      </div>\n    )\n  }\n}\n```\n\n\n\n我们在子组件中预留了`componentWillUpdate` 方法， 用来监测子组件是否被跟新\n\n```JavaScript\ncomponentWillUpdate() {\n  console.log('我被更新了')\n}\n```\n\n实验结果: \n\n![noChangeState](http://img.nixiaolei.com/noChangeState.gif)\n\n\n\n我们可以看到, 每一次的点击都引起了子组件的`update`\n\n\n### 冷静分析问题\n\n无故的重复`update`, 这会导致业务规模扩大后十分的影响性能.\n\n为此我监测了一下页面的重绘事件:\n> 绿色区域是浏览器发成重绘的地方\n\n![noRePaint](http://img.nixiaolei.com/noRePaint.gif)\n\n可以看到`todoList`其实并没有引起浏览器的`repaint` , 因此可以推测, 实际`dom`并没有更新这在渲染页面前被`dom diff`给排除掉了, 因此性能损耗在了转换成`Virtual DOM`的过程中 \n\n\n\n## shouldComponentUpdate\n> shouldComponentUpdate(nextProps, nextState)， 默认返回true\n\n`shouldComponentUpdate` 是 `React` 中做性能优化的重要手段， 看这个英文翻译我们大概也能猜出个一二来 --- '组件是否跟新？'\n\n`React` 会根据 `shouldComponentUpdate` 的返回结果来决定该组件是否重新渲染， 如果返回`True`就渲染，  如果返回`False`就重新渲染\n\n基于这个特性, 我们来修改一下上面问题中的代码\n\n```JavaScript\n// 父组件无变化, 因此省略\n\n// 子组件代码\nclass TodoItem extends Component {\n\n  // ...省略其他原有的代码\n\n\n  // --------- 新增代码 -------------\n  shouldComponentUpdate(nextProps, nextState) {\n    // 判断下 当前 props传入的data.thing  是否和新传入的  data.thing 相同\n    return  this.props.data.thing !== nextProps.data.thing\n  }\n  // --------- 新增代码 -------------\n}\n```\n\n实验结果:\n![addShouUpdate](http://img.nixiaolei.com/addShouUpdate.gif)\n\n我们可以看到`update`事件确实消失了\n\n\n\n## PureComponent\n看了`shouldComponentUpdate`函数的作用, 就能够理解`PureComponent`了?  它其实就是在帮我们做这样一件事:\n\n**自动的帮我们编写 `shouldComponentUpdate` 方法, 避免我们为每个组件都编写一次的麻烦**\n\n我们只需要这样, 就可以一步到位\n```JavaScript\nimport React, { PureComponent } from 'react'\nclass TodoItem extends PureComponent {\n}\n```\n\n\n***\n\n是不是感觉`PureComponent`很强大, 但`PureComponent`并不完美, \n\n其实它还有一些潜藏的问题, 如果您想要继续了解, 请在站内搜索 `immutable`\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【React】PureComponent解决了什么问题","published":1,"updated":"2019-09-09T16:57:46.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4sz002saas6dwbbzhfb"},{"title":"【React】react16.6中如何处理异步&&按需加载","date":"2019-04-11T13:48:06.000Z","_content":"\n当前大部分 `React` 应用需要使用 `code splitting` 的时候，都选择使用优秀的 `react-loadable` 来处理检测代码段是否已加载。然而，随着`React v16.6` 的发布，我们有一个非常难得的机会 ，可以删除我们的第三方依赖！\n\n[React.Suspense](https://reactjs.org/docs/code-splitting.html)是一个新添加到核心React库中的功能，他的功能基本和 `react-loadable` 一致，所以不用多说，让我们来看看用 `React.Suspense` 替换 `react-loadable`。\n\n`Suspense` 的好处是不一定只能处理组件的按需加载， 也能用来处理其他的异步事件\n\n## 处理异步\n> 自己实现流程\n\n首先创建一个`Promise` ， 模拟一个异步请求\n```Js\nfunction fetchApi() {\n  const promise = new Promise(resolve => {\n    setTimeout(() => {\n      resolve('data resolved')\n    }, 3000)\n  })\n  return promise\n}\n```\n\n实现处理`promise`异步的逻辑\n```Js\nimport React, { Suspense, Component } from 'react'\n// 创建Fetcher \nvar cached = {}\n// 接收一个为promise 的参数\nconst createFetcher = promiseTask => {\n  // 将ref 复制为 cached\n  let ref = cached\n  return () => {\n    // 返回一个 promise\n    const task = promiseTask()\n    // task\n    task.then(res => {\n      // ref 复制为 res, 也就是promise 的返回结果\n      ref = res\n    })\n    //  ------注意此处的 console --------\n    console.log('进入ref === cached的判断')\n    // 如果 ref 没有发生改变， 仍旧和cached相等\n    if (ref === cached) {\n      // 抛出 task \n      throw task\n    }\n    // 得到结果输出\n    console.log('🍎', ref)\n    // 正常返回 ref ， 此时已是promise 的结果\n    return ref\n  }\n}\n```\n\n\n我们将异步事件传入刚刚定义的`createFtecher`\n```Js\nconst requestData = createFetcher(fetchApi)\n```\n\n\n创建一个函数组件， 用于显示处理好的异步结果\n```Js\nfunction SuspenseComp() {\n  const data = requestData()\n  return <p className=\"name\">{data}</p>\n}\n```\n\n重点来了， 使用`Suspense`组件包裹住， 使用`fallback`参数传入未加载完成的时候的样式, 我们这里传入一个`loading`的文字意思意思\n```Js\nclass Test extends Component {\n  render() {\n    return (\n      <Suspense fallback={<div>loading</div>} >\n        <SuspenseComp />\n      </Suspense>\n    )\n  }\n}\n```\n\n来看一下效果， 在经过一段事件的Loading 后成功的显示除了我们在`setTimeout`中返回的文字\n\n![实现效果](http://img.nixiaolei.com/suspense01.gif)\n\n\n### 原理分析\n仔细观看上面的效果图\n\n我们看到`进入ref === cached的判断` 这条语句出现了二次， 继而才出现了最终结果`data resolved`，\n还记得在`createFetcher`函数中抛出的`task`吗， 它就是利用这样一种方法， 抛出错误，让`Suspense` 来接收， 如果抛出了错误， 就隔一会继续来一次， \n\n其实就可以理解为轮询\n\n\n## 处理组件\n组件就比上面简单多了, \n\n`React`就提供了一个 `lazy`方法\n\n我们只需要这样即可， 非常的快捷\n```Js\nlazy(() => import(\"./xxx\"))\n```\n\n来看看实际如何使用\n```Js\n// 引入`lazy` 和 `Suspense`\nimport React, { Suspense, Component, lazy } from 'react'\n\n\n// 加载异步组件\nconst LazyComp = lazy(() => import(\"./lazy\"))\n\nclass Test extends Component {\n  render() {\n    return (\n      <div>\n        <Suspense fallback={<div>loading</div>} >\n          { /* lazy 组件 */ }\n          <LazyComp /> \n        </Suspense>\n      </div>\n    )\n  }\n}\n\n// 被加载的lazy组件\nclass Lazy extends Component {\n  render() {\n    return (\n      <div>\n        my name lazy\n      </div>\n    )\n  }\n}\n```\n\n来， 让我们看一下效果\n\n![实现效果](http://img.nixiaolei.com/lasy01.gif)\n\n\n\n## 加载顺序\n那上面两个例子中的组件`SuspenseComp` 和  `LazyComp` 都放在`Suspense` 里面呢，到底是各管各的还是一起完成呢？ 让我们实践一下\n```Js\nclass Test extends Component {\n  render() {\n    return (\n      <Suspense fallback={<div>loading</div>} >\n        <SuspenseComp />\n        <LazyComp />\n      </Suspense>\n    )\n  }\n}\n```\n\n效果如下:\n![实现效果](http://img.nixiaolei.com/lazy02.gif)\n\n\n我们可以看到,尽管`SuspenseComp` 和`LazyComp` 加载速度不同, 但是它仍旧是等待`Suspense` 中的所有组件都加载完成后才显示出来\n\n## 处理异步-Hooks版本\n\nHooks 处理异步只需要短短的几行，就有了相同的效果\n```Js\nimport { useFetch } from 'react-hooks-fetch'\n\nfunction SuspenseComp() {\n  const {error, data} = useFetch(\"a.php\")\n  if( error ) return <span>出错了🙂</span>\n  if( !data ) return null\n  return <span>result{data.title}</span>\n}\n```\n\n真香\n\n\n\n\n## 非Hooks版本全部代码\n```Js\nimport React, { Suspense, Component, lazy } from 'react'\n\n// React 自带的lazy组件，自己会编译 （避免被webpack打包成js）\nconst LazyComp = lazy(() => import(\"./lazy\"))\n\nfunction fetchApi() {\n  const promise = new Promise(resolve => {\n    setTimeout(() => {\n      resolve('data resolved')\n    }, 3000)\n  })\n  return promise\n}\n\n// 创建Fetcher \nvar cached = {}\nconst createFetcher = promiseTask => {\n  let ref = cached\n  return () => {\n    // 返回一个promise\n    const task = promiseTask()\n    task.then(res => {\n      ref = res\n    })\n    console.log('进入ref === cached的判断')\n    if (ref === cached) {\n      throw task\n    }\n    // 得到结果输出\n    console.log('🍎', ref)\n    return ref\n  }\n}\n\nconst requestData = createFetcher(fetchApi)\nfunction SuspenseComp() {\n  const data = requestData()\n  return <p className=\"name\">{data}</p>\n}\n\nclass Test extends Component {\n\n  render() {\n    return (\n      <div>\n        <Suspense fallback={<div>loading</div>} >\n          <SuspenseComp />\n          <LazyComp />\n        </Suspense>\n      </div>\n    )\n  }\n}\nexport default Test\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【React】react16.6中如何处理异步&&按需加载.md","raw":"---\ntitle: 【React】react16.6中如何处理异步&&按需加载\ndate: 2019-04-11 21:48:06\ncategories: React\ntags: [React, 性能优化]\n---\n\n当前大部分 `React` 应用需要使用 `code splitting` 的时候，都选择使用优秀的 `react-loadable` 来处理检测代码段是否已加载。然而，随着`React v16.6` 的发布，我们有一个非常难得的机会 ，可以删除我们的第三方依赖！\n\n[React.Suspense](https://reactjs.org/docs/code-splitting.html)是一个新添加到核心React库中的功能，他的功能基本和 `react-loadable` 一致，所以不用多说，让我们来看看用 `React.Suspense` 替换 `react-loadable`。\n\n`Suspense` 的好处是不一定只能处理组件的按需加载， 也能用来处理其他的异步事件\n\n## 处理异步\n> 自己实现流程\n\n首先创建一个`Promise` ， 模拟一个异步请求\n```Js\nfunction fetchApi() {\n  const promise = new Promise(resolve => {\n    setTimeout(() => {\n      resolve('data resolved')\n    }, 3000)\n  })\n  return promise\n}\n```\n\n实现处理`promise`异步的逻辑\n```Js\nimport React, { Suspense, Component } from 'react'\n// 创建Fetcher \nvar cached = {}\n// 接收一个为promise 的参数\nconst createFetcher = promiseTask => {\n  // 将ref 复制为 cached\n  let ref = cached\n  return () => {\n    // 返回一个 promise\n    const task = promiseTask()\n    // task\n    task.then(res => {\n      // ref 复制为 res, 也就是promise 的返回结果\n      ref = res\n    })\n    //  ------注意此处的 console --------\n    console.log('进入ref === cached的判断')\n    // 如果 ref 没有发生改变， 仍旧和cached相等\n    if (ref === cached) {\n      // 抛出 task \n      throw task\n    }\n    // 得到结果输出\n    console.log('🍎', ref)\n    // 正常返回 ref ， 此时已是promise 的结果\n    return ref\n  }\n}\n```\n\n\n我们将异步事件传入刚刚定义的`createFtecher`\n```Js\nconst requestData = createFetcher(fetchApi)\n```\n\n\n创建一个函数组件， 用于显示处理好的异步结果\n```Js\nfunction SuspenseComp() {\n  const data = requestData()\n  return <p className=\"name\">{data}</p>\n}\n```\n\n重点来了， 使用`Suspense`组件包裹住， 使用`fallback`参数传入未加载完成的时候的样式, 我们这里传入一个`loading`的文字意思意思\n```Js\nclass Test extends Component {\n  render() {\n    return (\n      <Suspense fallback={<div>loading</div>} >\n        <SuspenseComp />\n      </Suspense>\n    )\n  }\n}\n```\n\n来看一下效果， 在经过一段事件的Loading 后成功的显示除了我们在`setTimeout`中返回的文字\n\n![实现效果](http://img.nixiaolei.com/suspense01.gif)\n\n\n### 原理分析\n仔细观看上面的效果图\n\n我们看到`进入ref === cached的判断` 这条语句出现了二次， 继而才出现了最终结果`data resolved`，\n还记得在`createFetcher`函数中抛出的`task`吗， 它就是利用这样一种方法， 抛出错误，让`Suspense` 来接收， 如果抛出了错误， 就隔一会继续来一次， \n\n其实就可以理解为轮询\n\n\n## 处理组件\n组件就比上面简单多了, \n\n`React`就提供了一个 `lazy`方法\n\n我们只需要这样即可， 非常的快捷\n```Js\nlazy(() => import(\"./xxx\"))\n```\n\n来看看实际如何使用\n```Js\n// 引入`lazy` 和 `Suspense`\nimport React, { Suspense, Component, lazy } from 'react'\n\n\n// 加载异步组件\nconst LazyComp = lazy(() => import(\"./lazy\"))\n\nclass Test extends Component {\n  render() {\n    return (\n      <div>\n        <Suspense fallback={<div>loading</div>} >\n          { /* lazy 组件 */ }\n          <LazyComp /> \n        </Suspense>\n      </div>\n    )\n  }\n}\n\n// 被加载的lazy组件\nclass Lazy extends Component {\n  render() {\n    return (\n      <div>\n        my name lazy\n      </div>\n    )\n  }\n}\n```\n\n来， 让我们看一下效果\n\n![实现效果](http://img.nixiaolei.com/lasy01.gif)\n\n\n\n## 加载顺序\n那上面两个例子中的组件`SuspenseComp` 和  `LazyComp` 都放在`Suspense` 里面呢，到底是各管各的还是一起完成呢？ 让我们实践一下\n```Js\nclass Test extends Component {\n  render() {\n    return (\n      <Suspense fallback={<div>loading</div>} >\n        <SuspenseComp />\n        <LazyComp />\n      </Suspense>\n    )\n  }\n}\n```\n\n效果如下:\n![实现效果](http://img.nixiaolei.com/lazy02.gif)\n\n\n我们可以看到,尽管`SuspenseComp` 和`LazyComp` 加载速度不同, 但是它仍旧是等待`Suspense` 中的所有组件都加载完成后才显示出来\n\n## 处理异步-Hooks版本\n\nHooks 处理异步只需要短短的几行，就有了相同的效果\n```Js\nimport { useFetch } from 'react-hooks-fetch'\n\nfunction SuspenseComp() {\n  const {error, data} = useFetch(\"a.php\")\n  if( error ) return <span>出错了🙂</span>\n  if( !data ) return null\n  return <span>result{data.title}</span>\n}\n```\n\n真香\n\n\n\n\n## 非Hooks版本全部代码\n```Js\nimport React, { Suspense, Component, lazy } from 'react'\n\n// React 自带的lazy组件，自己会编译 （避免被webpack打包成js）\nconst LazyComp = lazy(() => import(\"./lazy\"))\n\nfunction fetchApi() {\n  const promise = new Promise(resolve => {\n    setTimeout(() => {\n      resolve('data resolved')\n    }, 3000)\n  })\n  return promise\n}\n\n// 创建Fetcher \nvar cached = {}\nconst createFetcher = promiseTask => {\n  let ref = cached\n  return () => {\n    // 返回一个promise\n    const task = promiseTask()\n    task.then(res => {\n      ref = res\n    })\n    console.log('进入ref === cached的判断')\n    if (ref === cached) {\n      throw task\n    }\n    // 得到结果输出\n    console.log('🍎', ref)\n    return ref\n  }\n}\n\nconst requestData = createFetcher(fetchApi)\nfunction SuspenseComp() {\n  const data = requestData()\n  return <p className=\"name\">{data}</p>\n}\n\nclass Test extends Component {\n\n  render() {\n    return (\n      <div>\n        <Suspense fallback={<div>loading</div>} >\n          <SuspenseComp />\n          <LazyComp />\n        </Suspense>\n      </div>\n    )\n  }\n}\nexport default Test\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【React】react16.6中如何处理异步&&按需加载","published":1,"updated":"2019-09-09T16:57:46.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4t0002waas6nma7fj1c"},{"title":"【React】react16中如何使用ref ","date":"2019-04-12T15:27:49.000Z","_content":"\n在 React16 新版本中，新引入了 React.createRef 与 React.forwardRef 两个 API，有计划移除老的 string ref，使 ref 的使用更加便捷与明确。如果你的应用已经升级到 React16.3+ 版本，那就放心大胆使用 React.createRef 吧，如果暂时没有的话，建议使用 callback ref 来代替 string ref。\n\n> 新版的`ref`内部使用`Symbol`来作为标识， 可以猜测出，`React`的用意是想避免`string ref`可能引起重复的问题\n\n## 关联ref\n\n使用新版本的ref\n```Js\nexport default class Reftest extends Component {\n  constructor(props) {\n    super(props);\n    // 创建ref\n    this.myRef = React.createRef();\n  }\n  componentDidMount() {\n    // 打印ref\n    console.log(this.myRef)\n    this.myRef.current.focus();\n  }\n  render() {\n    // 挂载 ref\n    return <input ref={this.myRef} />;\n  }\n}\n\n```\n\n\n## 传递和转发ref\n\n\n利用 `React.forwardRef` 传递复用 `ref`\n\n```Js\nimport React, { Component } from 'react'\n\nconst TargetComponent = React.forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} />\n})\n\nexport default class Reftest extends Component {\n  constructor(props) {\n    super(props);\n    // 创建ref\n    this.myRef = React.createRef();\n  }\n  componentDidMount() {\n    // 改变value\n    this.myRef.current.value = \"传递ref成功\"\n  }\n  render() {\n    // 挂载 ref, 让组件也保持ref写法\n    return <TargetComponent ref={this.myRef} />\n  }\n}\n```\n\n结果如下: \n\n![ref复用](http://img.nixiaolei.com/2019-04-12-23-44-48.png)\n\n参考文献:\n* https://blog.csdn.net/qq_24147051/article/details/81218688\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【React】react16中如何使用ref.md","raw":"---\ntitle: '【React】react16中如何使用ref '\ndate: 2019-04-12 23:27:49\ncategories: React\ntags: React\n---\n\n在 React16 新版本中，新引入了 React.createRef 与 React.forwardRef 两个 API，有计划移除老的 string ref，使 ref 的使用更加便捷与明确。如果你的应用已经升级到 React16.3+ 版本，那就放心大胆使用 React.createRef 吧，如果暂时没有的话，建议使用 callback ref 来代替 string ref。\n\n> 新版的`ref`内部使用`Symbol`来作为标识， 可以猜测出，`React`的用意是想避免`string ref`可能引起重复的问题\n\n## 关联ref\n\n使用新版本的ref\n```Js\nexport default class Reftest extends Component {\n  constructor(props) {\n    super(props);\n    // 创建ref\n    this.myRef = React.createRef();\n  }\n  componentDidMount() {\n    // 打印ref\n    console.log(this.myRef)\n    this.myRef.current.focus();\n  }\n  render() {\n    // 挂载 ref\n    return <input ref={this.myRef} />;\n  }\n}\n\n```\n\n\n## 传递和转发ref\n\n\n利用 `React.forwardRef` 传递复用 `ref`\n\n```Js\nimport React, { Component } from 'react'\n\nconst TargetComponent = React.forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} />\n})\n\nexport default class Reftest extends Component {\n  constructor(props) {\n    super(props);\n    // 创建ref\n    this.myRef = React.createRef();\n  }\n  componentDidMount() {\n    // 改变value\n    this.myRef.current.value = \"传递ref成功\"\n  }\n  render() {\n    // 挂载 ref, 让组件也保持ref写法\n    return <TargetComponent ref={this.myRef} />\n  }\n}\n```\n\n结果如下: \n\n![ref复用](http://img.nixiaolei.com/2019-04-12-23-44-48.png)\n\n参考文献:\n* https://blog.csdn.net/qq_24147051/article/details/81218688\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【React】react16中如何使用ref","published":1,"updated":"2019-09-09T16:57:46.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4t10030aas6ycyglkjx"},{"title":"【React】react16新增错误处理生命周期","date":"2019-04-12T15:49:46.000Z","_content":"\n`React16`新增了一个用于错误处理的生命周期，\n\n有了这个法宝，我们就能针对组件的错误做很多事情啦， 来看看怎么用\n\n## 使用示例\n```Js\nexport default class Errorfun extends Component {\n  constructor( props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  // 捕捉错误和错误上报程序库一起使用\n  componentDidCatch(err, info) {\n    this.setState({ hasError: true })\n  }\n  render() {\n    if ( this.state.hasError ) {\n      return <div>Somthing error </div> \n    }\n    return (\n      <div>\n        Hello React\n      </div>\n    )\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【React】react16新增错误处理生命周期.md","raw":"---\ntitle: 【React】react16新增错误处理生命周期\ndate: 2019-04-12 23:49:46\ncategories: React\ntags: [React, 错误处理]\n---\n\n`React16`新增了一个用于错误处理的生命周期，\n\n有了这个法宝，我们就能针对组件的错误做很多事情啦， 来看看怎么用\n\n## 使用示例\n```Js\nexport default class Errorfun extends Component {\n  constructor( props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  // 捕捉错误和错误上报程序库一起使用\n  componentDidCatch(err, info) {\n    this.setState({ hasError: true })\n  }\n  render() {\n    if ( this.state.hasError ) {\n      return <div>Somthing error </div> \n    }\n    return (\n      <div>\n        Hello React\n      </div>\n    )\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【React】react16新增错误处理生命周期","published":1,"updated":"2019-09-09T16:57:46.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4t20032aas6yvve7d90"},{"title":"【Redux】react、redux与函数式编程","date":"2019-07-07T10:44:26.000Z","_content":"\n\n> redux 本身是container ， state就是value ， action 就是 变形关系\n\n1. 可以将React看作输入为state， 输出为view的“纯”函数\n2. 范畴论将世界抽象为对象和对象之间的联系， Redux将所有事件抽象为 `action` (变形关系)\n3. container 有_value  和 map 两个属性， 而修改 _value 的方法直有 map  , 在操作完 _value 后将新值放回 Container中\n4. 如何操作或修改_value 由f给出\n5. store 是一个容器含有state 和 reducer , 这从store 的创建语句， 并且currentState在修改完后将新值依然存放在 store内。\n如何修改 currentState 是根据用户操作 action\n\n\n```js\nstore -> container\ncurrentState -> _value\naction -> f\ncurrentReducer -> map\nmiddleware -> IO functior // 解决异步操作的各种问题\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【React】react、redux与函数式编程.md","raw":"---\ntitle: 【Redux】react、redux与函数式编程\ndate: 2019-07-07 18:44:26\ncategories: React\ntags: [React, Redux]\n---\n\n\n> redux 本身是container ， state就是value ， action 就是 变形关系\n\n1. 可以将React看作输入为state， 输出为view的“纯”函数\n2. 范畴论将世界抽象为对象和对象之间的联系， Redux将所有事件抽象为 `action` (变形关系)\n3. container 有_value  和 map 两个属性， 而修改 _value 的方法直有 map  , 在操作完 _value 后将新值放回 Container中\n4. 如何操作或修改_value 由f给出\n5. store 是一个容器含有state 和 reducer , 这从store 的创建语句， 并且currentState在修改完后将新值依然存放在 store内。\n如何修改 currentState 是根据用户操作 action\n\n\n```js\nstore -> container\ncurrentState -> _value\naction -> f\ncurrentReducer -> map\nmiddleware -> IO functior // 解决异步操作的各种问题\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【React】react、redux与函数式编程","published":1,"updated":"2019-09-09T16:57:46.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4t40035aas6cdvg674b"},{"title":"【React】为什么要使用immutableJs","date":"2019-04-08T14:10:17.000Z","_content":"\n\n## React自身的一些Bug\n在开发中对`React`应用做性能优化时， 我们通常会使用`shouldComponentUpdate` 这个生命周期钩子来决定该组件是否需要更新， 来过滤掉没有意义的更新修改。 \n\n并且，官方也贴心的为我们提供了 `PureComponent` 用来省去我们繁琐的判断， 自动生成`shouldComponentUpdate`\n\n\n\n但现实往往不是那么的完美， `PureComponent` 也有解决不了问题的时候， \n\n为了更好的理解， 我们先来显示的使用`shouldComponentUpdate`操作一遍\n\n```JavaScript\n// 父组件\nclass TodoList extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { \n      todoList: [\n       '喝可乐', \n       '打游戏'\n      ] \n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if( this.state.todoList != nextState.todoList ) {\n      console.log('两次不一致， 同意更新')\n      return true\n    }\n    console.log('更新前后todolist 一致， 所以不更新')\n    return false\n  }\n\n  // 数组concat操作， 会返回新数组\n  concatHandle() {\n    let todoList = this.state.todoList\n    const rd = Math.random() * 30\n    todoList = todoList.concat([ `搞事情:${rd}` ])\n    this.setState(() => ({\n      todoList\n    }))\n  }\n\n  // 数组Push操作， 未改变原数组\n  pushHandle() {\n    let todoList = this.state.todoList\n    const rd = Math.random() * 30\n    todoList.push( `搞事情:${rd}` )\n    this.setState(() => ({\n      todoList\n    }))\n  }\n\n  render() {\n    const { todoList } = this.state\n\n    return (\n      <div className=\"wrap\">\n        <button onClick={() => this.pushHandle()}>Push操作</button>\n        <button onClick={() => this.concatHandle()}>concat操作</button>\n        {\n          todoList.map( (item,index) => <TodoItem key={index}  thing={item} /> )\n        }\n      </div>\n    )\n  }\n}\n\n// 子组件\nclass TodoItem extends Component {\n  constructor(props) {\n    super(props)\n  }\n  render() {\n    return (\n      <div>\n        { this.props.thing }\n      </div>\n    )\n  }\n}\n```\n\n我们在`shouldComponentUpdate` 进行了简单的判断， 但是可悲的是这只在对比普通类型时比较的奏效， 因为`JavaScript`中存在这引用类型的概念， 所以对于引用类型来说`==` 会变成判断该变量地址的操作\n\n口说无凭，我们来看看实际的情况。 \n\n![ReactBug](http://img.nixiaolei.com/pureCompoents.gif)\n\n\n我的天，这是怎么回事， 实际情况好像要更复杂一些！\n点击了两次`Push`没有反应， 然而在点击`concat`的时候， 一瞬间多出了`3`条\n\n\n### 冷静分析\n对于这种种非正常现象， 我们有必要保持清新的头脑去分析一下\n\n![别慌](http://img.nixiaolei.com/2019-04-08-22-39-14.png)\n\n我们可以看到， 第一次点击`push`操作， 页面没有任何反应， 只是在控制台打印了`更新前后todolist 一致， 所以不更新`,\n\n哦~， 看到这个我们知道了， 此次组件的更新被`shouldComponentUpdate`拦截了，  这怎么行呢， 我要更新的你给我拦截了， 我数组明明变化了啊， 我数组新增了内容， 你就该给我正常变化， 这不是坑人吗\n\n\n### PureComponent\n看到这，你可能会说， 官方不是提供了`PureComponent`吗，  官方给的还能跟你一样这么龊？  该更新的不更新？\n\n您还别不信， 它就这么龊， `PureComponent` 其实是很傻的， 他也只是单纯的帮我们做了上面我们那样的操作， 虽然这样针对基本类型来说已经非常够用了， 能够解决问题了， 但是一旦遇上了引用类型， 它可就歇菜了， 还会引起你页面的奇妙`Bug`\n\n不信咱们来测试下， 我们修改下父组件代码， 子组件保持一致: \n```JavaScript\n// 替换为 PureComponent\nclass TodoList extends PureComponent {\n  constructor(props) {\n    super(props)\n    this.state = { \n      todoList: [\n       '喝可乐', \n       '打游戏'\n      ] \n    }\n  }\n\n  //  ------------ 删除掉 shouldComponentUpdate ------------------------\n  // shouldComponentUpdate(nextProps, nextState) {\n  //   if( this.state.todoList != nextState.todoList ) {\n  //     console.log('两次不一致， 同意更新')\n  //     return true\n  //   }\n  //   console.log('更新前后todolist 一致， 所以不更新')\n  //   return false\n  // }\n\n  concatHandle() {\n    let todoList = this.state.todoList\n    const rd = Math.random() * 30\n    todoList = todoList.concat([ `concat操作: ${rd}` ])\n    this.setState(() => ({\n      todoList\n    }))\n  }\n\n  pushHandle() {\n    let todoList = this.state.todoList\n    const rd = Math.random() * 30\n    todoList.push( `push操作:${rd}` )\n    this.setState(() => ({\n      todoList\n    }))\n  }\n\n  render() {\n    const { todoList } = this.state\n\n    return (\n      <div className=\"wrap\">\n        <button onClick={() => this.pushHandle()}>Push操作</button>\n        <button onClick={() => this.concatHandle()}>concat操作</button>\n        {\n          todoList.map( (item,index) => <TodoItem key={index}  thing={item} /> )\n        }\n      </div>\n    )\n  }\n}\n```\n\n来看看结果\n\n![测试结果](http://img.nixiaolei.com/pureComponent02.gif)\n\n\n哎， 还是一样的坑\n\n那这个`Bug`怎么办， 这时候就请本文的主角`immutableJs`登场吧\n\n\n## immutableJs\n> Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce、find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。\n\n\n使用 `immutableJs` 避免这个副作用的一种实现是按值传递，也就是拷贝一份再传递过去，有深层结构就深拷贝。深拷贝在只做局部修改的时候做了很多无用功，于是`ImmutableJs`做了性能优化。\n\n\n### 使用它带来的好处\n\n网上找了个图，假如我们要修改左图中黄色节点的子节点4，那么Immutable.js只需要更新右图中的绿色节点，其余节点不需拷贝，继续复用。也就是说，Immutable.js会更新从根节点到所修改节点路径上的所有节点，由于修改了根节点，所以返回一个新对象，这也解释了为什么能控制副作用。\n\n![更新树](http://img.nixiaolei.com/2019-04-09-21-43-20.png)\n\n\n1. 假如你在组件state中保存了一份有深层结构的引用类型的数据，如果没有Immutable.js，你需要深拷贝一份再做修改。而用Immutable.js将state中的数据包装一下，不需深拷贝就可以直接修改。\n2. 由于修改后返回的是新对象，React.js只需要在oldState.obj === newState.obj这一层就能判断出obj产生了变化，不需要深入obj的深层结构。\n3. 带来几种操作方便的数据结构和API\n\n\n","source":"_posts/【React】为什么要使用immutableJs.md","raw":"---\ntitle: 【React】为什么要使用immutableJs\ndate: 2019-04-08 22:10:17\ncategories: React\ntags: [React, 性能优化]\n---\n\n\n## React自身的一些Bug\n在开发中对`React`应用做性能优化时， 我们通常会使用`shouldComponentUpdate` 这个生命周期钩子来决定该组件是否需要更新， 来过滤掉没有意义的更新修改。 \n\n并且，官方也贴心的为我们提供了 `PureComponent` 用来省去我们繁琐的判断， 自动生成`shouldComponentUpdate`\n\n\n\n但现实往往不是那么的完美， `PureComponent` 也有解决不了问题的时候， \n\n为了更好的理解， 我们先来显示的使用`shouldComponentUpdate`操作一遍\n\n```JavaScript\n// 父组件\nclass TodoList extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { \n      todoList: [\n       '喝可乐', \n       '打游戏'\n      ] \n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if( this.state.todoList != nextState.todoList ) {\n      console.log('两次不一致， 同意更新')\n      return true\n    }\n    console.log('更新前后todolist 一致， 所以不更新')\n    return false\n  }\n\n  // 数组concat操作， 会返回新数组\n  concatHandle() {\n    let todoList = this.state.todoList\n    const rd = Math.random() * 30\n    todoList = todoList.concat([ `搞事情:${rd}` ])\n    this.setState(() => ({\n      todoList\n    }))\n  }\n\n  // 数组Push操作， 未改变原数组\n  pushHandle() {\n    let todoList = this.state.todoList\n    const rd = Math.random() * 30\n    todoList.push( `搞事情:${rd}` )\n    this.setState(() => ({\n      todoList\n    }))\n  }\n\n  render() {\n    const { todoList } = this.state\n\n    return (\n      <div className=\"wrap\">\n        <button onClick={() => this.pushHandle()}>Push操作</button>\n        <button onClick={() => this.concatHandle()}>concat操作</button>\n        {\n          todoList.map( (item,index) => <TodoItem key={index}  thing={item} /> )\n        }\n      </div>\n    )\n  }\n}\n\n// 子组件\nclass TodoItem extends Component {\n  constructor(props) {\n    super(props)\n  }\n  render() {\n    return (\n      <div>\n        { this.props.thing }\n      </div>\n    )\n  }\n}\n```\n\n我们在`shouldComponentUpdate` 进行了简单的判断， 但是可悲的是这只在对比普通类型时比较的奏效， 因为`JavaScript`中存在这引用类型的概念， 所以对于引用类型来说`==` 会变成判断该变量地址的操作\n\n口说无凭，我们来看看实际的情况。 \n\n![ReactBug](http://img.nixiaolei.com/pureCompoents.gif)\n\n\n我的天，这是怎么回事， 实际情况好像要更复杂一些！\n点击了两次`Push`没有反应， 然而在点击`concat`的时候， 一瞬间多出了`3`条\n\n\n### 冷静分析\n对于这种种非正常现象， 我们有必要保持清新的头脑去分析一下\n\n![别慌](http://img.nixiaolei.com/2019-04-08-22-39-14.png)\n\n我们可以看到， 第一次点击`push`操作， 页面没有任何反应， 只是在控制台打印了`更新前后todolist 一致， 所以不更新`,\n\n哦~， 看到这个我们知道了， 此次组件的更新被`shouldComponentUpdate`拦截了，  这怎么行呢， 我要更新的你给我拦截了， 我数组明明变化了啊， 我数组新增了内容， 你就该给我正常变化， 这不是坑人吗\n\n\n### PureComponent\n看到这，你可能会说， 官方不是提供了`PureComponent`吗，  官方给的还能跟你一样这么龊？  该更新的不更新？\n\n您还别不信， 它就这么龊， `PureComponent` 其实是很傻的， 他也只是单纯的帮我们做了上面我们那样的操作， 虽然这样针对基本类型来说已经非常够用了， 能够解决问题了， 但是一旦遇上了引用类型， 它可就歇菜了， 还会引起你页面的奇妙`Bug`\n\n不信咱们来测试下， 我们修改下父组件代码， 子组件保持一致: \n```JavaScript\n// 替换为 PureComponent\nclass TodoList extends PureComponent {\n  constructor(props) {\n    super(props)\n    this.state = { \n      todoList: [\n       '喝可乐', \n       '打游戏'\n      ] \n    }\n  }\n\n  //  ------------ 删除掉 shouldComponentUpdate ------------------------\n  // shouldComponentUpdate(nextProps, nextState) {\n  //   if( this.state.todoList != nextState.todoList ) {\n  //     console.log('两次不一致， 同意更新')\n  //     return true\n  //   }\n  //   console.log('更新前后todolist 一致， 所以不更新')\n  //   return false\n  // }\n\n  concatHandle() {\n    let todoList = this.state.todoList\n    const rd = Math.random() * 30\n    todoList = todoList.concat([ `concat操作: ${rd}` ])\n    this.setState(() => ({\n      todoList\n    }))\n  }\n\n  pushHandle() {\n    let todoList = this.state.todoList\n    const rd = Math.random() * 30\n    todoList.push( `push操作:${rd}` )\n    this.setState(() => ({\n      todoList\n    }))\n  }\n\n  render() {\n    const { todoList } = this.state\n\n    return (\n      <div className=\"wrap\">\n        <button onClick={() => this.pushHandle()}>Push操作</button>\n        <button onClick={() => this.concatHandle()}>concat操作</button>\n        {\n          todoList.map( (item,index) => <TodoItem key={index}  thing={item} /> )\n        }\n      </div>\n    )\n  }\n}\n```\n\n来看看结果\n\n![测试结果](http://img.nixiaolei.com/pureComponent02.gif)\n\n\n哎， 还是一样的坑\n\n那这个`Bug`怎么办， 这时候就请本文的主角`immutableJs`登场吧\n\n\n## immutableJs\n> Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce、find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。\n\n\n使用 `immutableJs` 避免这个副作用的一种实现是按值传递，也就是拷贝一份再传递过去，有深层结构就深拷贝。深拷贝在只做局部修改的时候做了很多无用功，于是`ImmutableJs`做了性能优化。\n\n\n### 使用它带来的好处\n\n网上找了个图，假如我们要修改左图中黄色节点的子节点4，那么Immutable.js只需要更新右图中的绿色节点，其余节点不需拷贝，继续复用。也就是说，Immutable.js会更新从根节点到所修改节点路径上的所有节点，由于修改了根节点，所以返回一个新对象，这也解释了为什么能控制副作用。\n\n![更新树](http://img.nixiaolei.com/2019-04-09-21-43-20.png)\n\n\n1. 假如你在组件state中保存了一份有深层结构的引用类型的数据，如果没有Immutable.js，你需要深拷贝一份再做修改。而用Immutable.js将state中的数据包装一下，不需深拷贝就可以直接修改。\n2. 由于修改后返回的是新对象，React.js只需要在oldState.obj === newState.obj这一层就能判断出obj产生了变化，不需要深入obj的深层结构。\n3. 带来几种操作方便的数据结构和API\n\n\n","slug":"【React】为什么要使用immutableJs","published":1,"updated":"2019-09-09T16:57:46.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4t40037aas6cv1a7n20"},{"title":"【React】react生命周期的变化","date":"2019-04-13T01:46:16.000Z","_content":"\n`React16`带来了新的生命周期， 为了更好的贴合`fiber`架构， 移除了几个旧的生命周期， 这几个生命周期也确实不太常用\n\n我们先来看看老的生命周期\n## react15生命周期\n![react15生命周期](http://img.nixiaolei.com/2019-04-13-10-14-55.png)\n\n\n光看没用呀，记不住，我们来实际看一下它的打印顺序。\n初次加载时：\n![react15打印生命周期01](http://img.nixiaolei.com/2019-04-13-10-08-51.png)\n\n点击按钮更新组件，使得传入`Props`发生改变，触发子组件的生命周期\n![react15打印生命周期02](http://img.nixiaolei.com/2019-04-13-10-19-11.png)\n\n\n\n## react16生命周期\n\n![React16生命周期](http://img.nixiaolei.com/2019-04-14-17-50-09.png)\n\n\n\n### 废弃的三个生命周期：\n* componentWillMount\n* componentWillReceiveProps\n* componentWillUpdate\n\n如果你在`react16`中还继续使用这几个什么周期， 他就会提示你这是不安全的\n![warning](http://img.nixiaolei.com/2019-04-14-19-02-00.png)\n\n\n### 新增的两个生命周期:\n> 为了配合`fiber`\n* getDerivedStateFromProps\n* getSnapshotBeforeUpdate\n\n\n我这个人说话比较简单， 我就简介的说一下这两个生命周期主要的功能及解决的问题， 具体的长篇大论不好描述，也不是我擅长的事情， 我在下面给出了两份不错的文章， 方便自己回忆细节， 也方便大家理解\n\n#### getDerivedStateFromProps\n> 用来取代`componentWillReceiveProps`, 是一个静态方法\n\n> 接收两个参数 nextProps, preProps\n是一个将接收到的`props`映射到`state`的方法\n具体映射规则根据该方法的返回值，\n\n比如，如果这样，返回一个`name`\n```Js\nstatic getDerivedStateFromProps(nextProps, prevProps) {\n  return { name: \"张三\" }\n}\n```\n\n随即我们打印一下`state`\n![映射props](http://img.nixiaolei.com/2019-04-14-21-19-29.png)\n我们发现，返回的`name` 确实出现在了`state`, 尽管这是我创造出来的， 而不是`props`上传入的\n\n如果我们不想它映射到`state`, 我们可以返回一个`null`\n\n![不映射props](http://img.nixiaolei.com/2019-04-14-21-22-06.png)\n\n\n根据这个特性利用传入的`nextProps, prevProps`两个参数， 我们就可以做类似 `shouldComponentUpdate`的操作\n\n#### getSnapshotBeforeUpdate\n> 该方法获取上一次`render`时的镜像\n\n> 接收 prevProps, prevState 两个参数\n\n新的`getSnapshotBeforeUpdate`生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给`componentDidUpdate`。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）\n\n与`componentDidUpdate`一起，这个新的生命周期将覆盖旧版`componentWillUpdate`的所有用例。\n\n来看一下每次的打印结果\n```Js\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n  console.log(`---第${times++}次renders---`)\n  console.log('prevProps', prevProps)\n  console.log('prevState', prevState)\n}\n```\n\n![查看镜像](http://img.nixiaolei.com/2019-04-14-21-41-52.png)\n\n\n\n\n关于这两个生命周期， 有两个个比较好的文章：\n* [理论型文章](https://blog.csdn.net/nnxxyy1111/article/details/80832525#%E4%BB%80%E4%B9%88%E6%98%AFmemoization)\n* [使用型文章](https://www.jianshu.com/p/50fe3fb9f7c3)\n\n\n\n\n\n\n\n参考文献:\n> https://www.jianshu.com/p/50fe3fb9f7c3\n> https://blog.csdn.net/nnxxyy1111/article/details/80832525#%E4%BB%80%E4%B9%88%E6%98%AFmemoization\n> https://www.zcfy.cc/article/update-on-async-rendering\n\n\n\n\n","source":"_posts/【React】react生命周期的变化.md","raw":"---\ntitle: 【React】react生命周期的变化\ndate: 2019-04-13 09:46:16\ncategories: React\ntags: React\n---\n\n`React16`带来了新的生命周期， 为了更好的贴合`fiber`架构， 移除了几个旧的生命周期， 这几个生命周期也确实不太常用\n\n我们先来看看老的生命周期\n## react15生命周期\n![react15生命周期](http://img.nixiaolei.com/2019-04-13-10-14-55.png)\n\n\n光看没用呀，记不住，我们来实际看一下它的打印顺序。\n初次加载时：\n![react15打印生命周期01](http://img.nixiaolei.com/2019-04-13-10-08-51.png)\n\n点击按钮更新组件，使得传入`Props`发生改变，触发子组件的生命周期\n![react15打印生命周期02](http://img.nixiaolei.com/2019-04-13-10-19-11.png)\n\n\n\n## react16生命周期\n\n![React16生命周期](http://img.nixiaolei.com/2019-04-14-17-50-09.png)\n\n\n\n### 废弃的三个生命周期：\n* componentWillMount\n* componentWillReceiveProps\n* componentWillUpdate\n\n如果你在`react16`中还继续使用这几个什么周期， 他就会提示你这是不安全的\n![warning](http://img.nixiaolei.com/2019-04-14-19-02-00.png)\n\n\n### 新增的两个生命周期:\n> 为了配合`fiber`\n* getDerivedStateFromProps\n* getSnapshotBeforeUpdate\n\n\n我这个人说话比较简单， 我就简介的说一下这两个生命周期主要的功能及解决的问题， 具体的长篇大论不好描述，也不是我擅长的事情， 我在下面给出了两份不错的文章， 方便自己回忆细节， 也方便大家理解\n\n#### getDerivedStateFromProps\n> 用来取代`componentWillReceiveProps`, 是一个静态方法\n\n> 接收两个参数 nextProps, preProps\n是一个将接收到的`props`映射到`state`的方法\n具体映射规则根据该方法的返回值，\n\n比如，如果这样，返回一个`name`\n```Js\nstatic getDerivedStateFromProps(nextProps, prevProps) {\n  return { name: \"张三\" }\n}\n```\n\n随即我们打印一下`state`\n![映射props](http://img.nixiaolei.com/2019-04-14-21-19-29.png)\n我们发现，返回的`name` 确实出现在了`state`, 尽管这是我创造出来的， 而不是`props`上传入的\n\n如果我们不想它映射到`state`, 我们可以返回一个`null`\n\n![不映射props](http://img.nixiaolei.com/2019-04-14-21-22-06.png)\n\n\n根据这个特性利用传入的`nextProps, prevProps`两个参数， 我们就可以做类似 `shouldComponentUpdate`的操作\n\n#### getSnapshotBeforeUpdate\n> 该方法获取上一次`render`时的镜像\n\n> 接收 prevProps, prevState 两个参数\n\n新的`getSnapshotBeforeUpdate`生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给`componentDidUpdate`。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）\n\n与`componentDidUpdate`一起，这个新的生命周期将覆盖旧版`componentWillUpdate`的所有用例。\n\n来看一下每次的打印结果\n```Js\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n  console.log(`---第${times++}次renders---`)\n  console.log('prevProps', prevProps)\n  console.log('prevState', prevState)\n}\n```\n\n![查看镜像](http://img.nixiaolei.com/2019-04-14-21-41-52.png)\n\n\n\n\n关于这两个生命周期， 有两个个比较好的文章：\n* [理论型文章](https://blog.csdn.net/nnxxyy1111/article/details/80832525#%E4%BB%80%E4%B9%88%E6%98%AFmemoization)\n* [使用型文章](https://www.jianshu.com/p/50fe3fb9f7c3)\n\n\n\n\n\n\n\n参考文献:\n> https://www.jianshu.com/p/50fe3fb9f7c3\n> https://blog.csdn.net/nnxxyy1111/article/details/80832525#%E4%BB%80%E4%B9%88%E6%98%AFmemoization\n> https://www.zcfy.cc/article/update-on-async-rendering\n\n\n\n\n","slug":"【React】react生命周期的变化","published":1,"updated":"2019-09-09T16:57:46.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4t6003caas6rygmb2yr"},{"title":"【React】从高阶函数到理解高阶组件","date":"2019-04-09T14:13:49.000Z","_content":"\n高阶组件其实就是高阶函数\n\n高阶函数的概念千万别和普通回调搞混， 高阶函数的必要条件：\n* 一定要返回一个新函数\n* 非入侵\n\n\n## 一句话理解高阶函数\n本来我没有的，我很垃圾，  通过把我交给别人， 在我身上装了额外的东西， 使我变的拥有了某种能力\n\n举个例子:  人和坦克， 本来人是不能发射炮弹的， 但是人钻进了坦克， 就可以发射炮弹了， 人还是人（自身未变）， 只是在坦克里了\n\n\n## 一个例子理解高阶函数\n\n一个简单的不能再简单的高阶函数\n```JavaScript\nfunction hoc(fn) {\n  return () => {\n    console.log('start')\n    fn()\n    console.log('end')\n  }\n}\n```\n\n## 一个例子理解高阶组件\n在不修改原有组件的情况下， 为其添加一个生命周期\n\n```JavaScript\n// 接收一个组件参数\nconst MyContainer = (WrappedComponent) => {\n  return class extends Component {\n\n    // 新增的生命周期\n    componentwillmount() {\n      console.log('增加一个生命周期')\n    }\n\n    render() {\n      return (\n        // 传入的组件\n        <WrappedComponent />\n      )\n    }\n  }\n}\nexport default MyContainer;\n```\n\n\n\n## 随处可见的高阶函数\n\nnode的`express`框架中, 你的`app.use`就是典型的高阶组件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【React】从高阶函数到理解高阶组件.md","raw":"---\ntitle: 【React】从高阶函数到理解高阶组件\ndate: 2019-04-09 22:13:49\ncategories: React\ntags: React\n---\n\n高阶组件其实就是高阶函数\n\n高阶函数的概念千万别和普通回调搞混， 高阶函数的必要条件：\n* 一定要返回一个新函数\n* 非入侵\n\n\n## 一句话理解高阶函数\n本来我没有的，我很垃圾，  通过把我交给别人， 在我身上装了额外的东西， 使我变的拥有了某种能力\n\n举个例子:  人和坦克， 本来人是不能发射炮弹的， 但是人钻进了坦克， 就可以发射炮弹了， 人还是人（自身未变）， 只是在坦克里了\n\n\n## 一个例子理解高阶函数\n\n一个简单的不能再简单的高阶函数\n```JavaScript\nfunction hoc(fn) {\n  return () => {\n    console.log('start')\n    fn()\n    console.log('end')\n  }\n}\n```\n\n## 一个例子理解高阶组件\n在不修改原有组件的情况下， 为其添加一个生命周期\n\n```JavaScript\n// 接收一个组件参数\nconst MyContainer = (WrappedComponent) => {\n  return class extends Component {\n\n    // 新增的生命周期\n    componentwillmount() {\n      console.log('增加一个生命周期')\n    }\n\n    render() {\n      return (\n        // 传入的组件\n        <WrappedComponent />\n      )\n    }\n  }\n}\nexport default MyContainer;\n```\n\n\n\n## 随处可见的高阶函数\n\nnode的`express`框架中, 你的`app.use`就是典型的高阶组件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【React】从高阶函数到理解高阶组件","published":1,"updated":"2019-09-09T16:57:46.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4t7003eaas6167org9g"},{"title":"【React】使用Context避免多层嵌套","date":"2019-04-12T14:39:19.000Z","_content":"\n用过redux + react-redux的同学，应该会觉得新的Context API很眼熟。而有看过react-redux源码的同学就知道，react-redux本身就是基于旧版本的Context API实现的。\n\n既然已经有了现成的解决方案，为什么还会有新的Context API呢？\n\n1. 现有Context API的实现存在一定问题：比如当父组件的shouldComponentUpdate性能优化，可能会导致消费了context数据的子组件不更新。\n2. 降低复杂度：类似redux全家桶这样的解决方案，给项目引入了一定的复杂度，尤其是对方案了解不足的同学，遇到问题可能一筹莫展。新Context API的引入，一定程度上可以减少不少项目对redux全家桶的依赖。\n3. 解决多层组件嵌套\n\n\n## 创建一个上下文\n\n利用新的`API`创建一个上下文， 接收返回的`Provider`, `Consumer`\n```Js\nimport React, { Component } from 'react'\nconst { Provider, Consumer } = React.createContext(\"default\")\n```\n\n## 定义父容器\n\n在此父容器内部使用`Provider`包裹住插槽传入的子组件， 传入`Provider`的值和`state`挂钩， 并且我将两个值都实现了双向绑定，以便于查看使用`context`方法传递的变量能否及时刷新  \n\n```Js\nclass Parent extends Component {\n  state = {\n    name: \"张三\",\n    age: 12\n  }\n\n  render() {\n    const { name, age } = this.state\n    return (\n      <div>\n        姓名：\n        <input  onChange={ e=> this.setState({ name: e.target.value })} value={name} />\n        年龄:\n        <input  onChange={ e=> this.setState({ age: e.target.value })}  value={age} />\n\n        <Provider value={{ name, age }}>\n          {this.props.children}\n        </Provider>\n      </div>\n    )\n  }\n}\n```\n\n## 创建两个子组件\n两个子组件分别用接收一个参数， 当然你也可以接收多个的\n```Js\n// 我用来展示name\nfunction Child01() {\n  return (\n    <Consumer>\n      {\n        value => (\n          <div>{value.name}</div>\n        )\n      }\n    </Consumer>\n  )\n}\n// 我用来展示age\nfunction Child02() {\n  return (\n    <Consumer>\n      {\n        value => (\n          <div>{value.age}</div>\n        )\n      }\n    </Consumer>\n  )\n}\n```\n\n## 组件整合\n用`Parent`组件将两个`Child`包裹， 也就是上面说的插槽\n```Js\nexport default () => (\n  <Parent >\n    <Child01 />\n    <Child02 />\n  </Parent>\n)\n```\n\n最终效果:\n\n![最终效果](http://img.nixiaolei.com/reactContext.gif)\n\n\n## 完整代码\n```Js\nimport React, { Component } from 'react'\nconst { Provider, Consumer } = React.createContext(\"default\")\nclass Parent extends Component {\n  state = {\n    name: \"张三\",\n    age: 12\n  }\n\n  render() {\n    const { name, age } = this.state\n    return (\n      <div>\n        姓名：\n        <input  onChange={ e=> this.setState({ name: e.target.value })} value={name} />\n        年龄:\n        <input  onChange={ e=> this.setState({ age: e.target.value })}  value={age} />\n\n        <Provider value={{ name, age }}>\n          {this.props.children}\n        </Provider>\n      </div>\n    )\n  }\n}\n\nfunction Child01() {\n  return (\n    <Consumer>\n      {\n        value => (\n          <div>{value.name}</div>\n        )\n      }\n    </Consumer>\n  )\n}\n\nfunction Child02() {\n  return (\n    <Consumer>\n      {\n        value => (\n          <div>{value.age}</div>\n        )\n      }\n    </Consumer>\n  )\n}\n\nexport default () => (\n  <Parent >\n    <Child01 />\n    <Child02 />\n  </Parent>\n)\n```\n\n\n\n\n\n\n\n","source":"_posts/【React】使用Context避免多层嵌套.md","raw":"---\ntitle: 【React】使用Context避免多层嵌套\ndate: 2019-04-12 22:39:19\ncategories: React\ntags: React\n---\n\n用过redux + react-redux的同学，应该会觉得新的Context API很眼熟。而有看过react-redux源码的同学就知道，react-redux本身就是基于旧版本的Context API实现的。\n\n既然已经有了现成的解决方案，为什么还会有新的Context API呢？\n\n1. 现有Context API的实现存在一定问题：比如当父组件的shouldComponentUpdate性能优化，可能会导致消费了context数据的子组件不更新。\n2. 降低复杂度：类似redux全家桶这样的解决方案，给项目引入了一定的复杂度，尤其是对方案了解不足的同学，遇到问题可能一筹莫展。新Context API的引入，一定程度上可以减少不少项目对redux全家桶的依赖。\n3. 解决多层组件嵌套\n\n\n## 创建一个上下文\n\n利用新的`API`创建一个上下文， 接收返回的`Provider`, `Consumer`\n```Js\nimport React, { Component } from 'react'\nconst { Provider, Consumer } = React.createContext(\"default\")\n```\n\n## 定义父容器\n\n在此父容器内部使用`Provider`包裹住插槽传入的子组件， 传入`Provider`的值和`state`挂钩， 并且我将两个值都实现了双向绑定，以便于查看使用`context`方法传递的变量能否及时刷新  \n\n```Js\nclass Parent extends Component {\n  state = {\n    name: \"张三\",\n    age: 12\n  }\n\n  render() {\n    const { name, age } = this.state\n    return (\n      <div>\n        姓名：\n        <input  onChange={ e=> this.setState({ name: e.target.value })} value={name} />\n        年龄:\n        <input  onChange={ e=> this.setState({ age: e.target.value })}  value={age} />\n\n        <Provider value={{ name, age }}>\n          {this.props.children}\n        </Provider>\n      </div>\n    )\n  }\n}\n```\n\n## 创建两个子组件\n两个子组件分别用接收一个参数， 当然你也可以接收多个的\n```Js\n// 我用来展示name\nfunction Child01() {\n  return (\n    <Consumer>\n      {\n        value => (\n          <div>{value.name}</div>\n        )\n      }\n    </Consumer>\n  )\n}\n// 我用来展示age\nfunction Child02() {\n  return (\n    <Consumer>\n      {\n        value => (\n          <div>{value.age}</div>\n        )\n      }\n    </Consumer>\n  )\n}\n```\n\n## 组件整合\n用`Parent`组件将两个`Child`包裹， 也就是上面说的插槽\n```Js\nexport default () => (\n  <Parent >\n    <Child01 />\n    <Child02 />\n  </Parent>\n)\n```\n\n最终效果:\n\n![最终效果](http://img.nixiaolei.com/reactContext.gif)\n\n\n## 完整代码\n```Js\nimport React, { Component } from 'react'\nconst { Provider, Consumer } = React.createContext(\"default\")\nclass Parent extends Component {\n  state = {\n    name: \"张三\",\n    age: 12\n  }\n\n  render() {\n    const { name, age } = this.state\n    return (\n      <div>\n        姓名：\n        <input  onChange={ e=> this.setState({ name: e.target.value })} value={name} />\n        年龄:\n        <input  onChange={ e=> this.setState({ age: e.target.value })}  value={age} />\n\n        <Provider value={{ name, age }}>\n          {this.props.children}\n        </Provider>\n      </div>\n    )\n  }\n}\n\nfunction Child01() {\n  return (\n    <Consumer>\n      {\n        value => (\n          <div>{value.name}</div>\n        )\n      }\n    </Consumer>\n  )\n}\n\nfunction Child02() {\n  return (\n    <Consumer>\n      {\n        value => (\n          <div>{value.age}</div>\n        )\n      }\n    </Consumer>\n  )\n}\n\nexport default () => (\n  <Parent >\n    <Child01 />\n    <Child02 />\n  </Parent>\n)\n```\n\n\n\n\n\n\n\n","slug":"【React】使用Context避免多层嵌套","published":1,"updated":"2019-09-09T16:57:46.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4t9003iaas6uyv39x01"},{"title":"【React】拥抱函数组件的Hooks","date":"2019-04-14T13:47:49.000Z","_content":"\nReact16带来了惊人的改变， amazing~\n\n## hooks带来的好处和特点\n\n1. 只能在函数组件中使用\n2. 函数组件后期的业务变更无需修改为class组件\n3. 告别了麻烦`this` 和难记的生命周期\n4. 合并了生命周期`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`的作用\n5. 可以包装自己的`hooks`，基于纯命令式的`API`\n6. 更好的完成状态之间的共享， 解决原来class组件内部封装问题。 也解决高阶组件嵌套过深\n7. `useReducer`集成`redux`\n8. `useEffect`接受脏操作等到`react`更新了`dom`后， 它再依次执行我们定义的副作用函数。 这里就是一个`io`且是异步的\n\n\n## 起步\n先来看看最常用的两个hooks： `useState`, `useEffect` \n\n### useState\n> 传入一个初始值， 返回 `count`、`setCount`,  \n> `count`用来读， `setCount`用来写  \n\n\n```Js\nexport default () => {\n  const [ count, setCount ] = useState(0)\n  return (\n    <div>\n      count: { count }\n      {/* 点击事件触发setCount方法 */}\n      <button onclick={ setCount }>增加Count</button>\n    </div>\n  )\n}\n```\n此时页面就是这个样子的\n![当前页面状态](http://img.nixiaolei.com/2019-04-14-22-35-19.png)\n\n然后我点击一次按钮\n![点击后](http://img.nixiaolei.com/2019-04-14-22-43-40.png)\n\n此时`count`就发生了变化变为了`1`， 就好像我们使用了`setState`方法一样神奇\n\n\n### useEffect\n> 副作用， 如果你对函数式编程有一定的了解， 那应该能明白这个词\n\n它主要用来承担`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`的作用\n\n它传入一个函数，用于在组件`render`时触发， 其中需要返回一个函数，返回的函数在组件卸载时被触发\n```Js\nuseEffect(() => {\n  console.log(\"更新渲染阶段\")\n  document.title = `标题-${count} times`\n  return () => {\n    console.log(\"卸载阶段\")\n  }\n})\n```\n\n在`useState`例子基础上我们添加了`useEffect`后， 效果如下：\n\n![useEffect](http://img.nixiaolei.com/effect.gif)\n\n我们可以看到， 刷新页面后首先出现的是\"更新渲染阶段\"，\n当我们点击了按钮后， 立即出现了“卸载阶段”， 然后出现了\"更新渲染阶段\"\n\n这就证明该副作用是在每次组件更新时都会被触发的。\n\n\n#### 自定义触发\n`useEffect`不仅能够替代那些个老生命周期， 还能够自定义根据某个值来触发\n\n`useEffect`的能接收两个参数， 第一个就是刚刚我们尝试的回调， 第二个参数可传可不传， 他是一个数组， \n\n如果你不传，就和上面的例子一样， 默认全部触发，\n如果你传入的是一个空数组`[]`，那就只在第一次渲染时触发\n如果你数组里制定了值， 那就只在这些值变化时触发\n\n***\n\n比如我要指定只有 `count`变化时才会触发\n```Js\nuseEffect(() => {\n  console.log(\"更新渲染阶段\")\n  document.title = `标题-${count} times`\n  return () => {\n    console.log(\"卸载阶段\")\n  }\n}, [count])\n```\n\n| api | ability | \n| :------: | :------: | \n| state | 返回有状态值, 以及更新这个状态值的函数 | \n| useEffect | 接收包含命令式， 可能有副作用代码的函数 |\n| useContext | 接受上下文对象（从React.createContext返回的值） |\n| useReducer  | useState的替代方案 |\n| useCallback | 返回一个回忆的memoized版本， |\n| useMemo | 纯的一个记忆函数 |\n| useRef | 返回一个可变的ref对象 |\n| useImperativeMethods  | 自定义使用ref时公开给父组件的实例值之前 |\n| useMutationEffect  | 更新兄弟组件之前， 它dom改变前执行 |\n| useLayoutEffect  | Dom改变后同步触发 |\n","source":"_posts/【React】拥抱函数组件的Hooks.md","raw":"---\ntitle: 【React】拥抱函数组件的Hooks\ndate: 2019-04-14 21:47:49\ncategories: React\ntags: React\n---\n\nReact16带来了惊人的改变， amazing~\n\n## hooks带来的好处和特点\n\n1. 只能在函数组件中使用\n2. 函数组件后期的业务变更无需修改为class组件\n3. 告别了麻烦`this` 和难记的生命周期\n4. 合并了生命周期`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`的作用\n5. 可以包装自己的`hooks`，基于纯命令式的`API`\n6. 更好的完成状态之间的共享， 解决原来class组件内部封装问题。 也解决高阶组件嵌套过深\n7. `useReducer`集成`redux`\n8. `useEffect`接受脏操作等到`react`更新了`dom`后， 它再依次执行我们定义的副作用函数。 这里就是一个`io`且是异步的\n\n\n## 起步\n先来看看最常用的两个hooks： `useState`, `useEffect` \n\n### useState\n> 传入一个初始值， 返回 `count`、`setCount`,  \n> `count`用来读， `setCount`用来写  \n\n\n```Js\nexport default () => {\n  const [ count, setCount ] = useState(0)\n  return (\n    <div>\n      count: { count }\n      {/* 点击事件触发setCount方法 */}\n      <button onclick={ setCount }>增加Count</button>\n    </div>\n  )\n}\n```\n此时页面就是这个样子的\n![当前页面状态](http://img.nixiaolei.com/2019-04-14-22-35-19.png)\n\n然后我点击一次按钮\n![点击后](http://img.nixiaolei.com/2019-04-14-22-43-40.png)\n\n此时`count`就发生了变化变为了`1`， 就好像我们使用了`setState`方法一样神奇\n\n\n### useEffect\n> 副作用， 如果你对函数式编程有一定的了解， 那应该能明白这个词\n\n它主要用来承担`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`的作用\n\n它传入一个函数，用于在组件`render`时触发， 其中需要返回一个函数，返回的函数在组件卸载时被触发\n```Js\nuseEffect(() => {\n  console.log(\"更新渲染阶段\")\n  document.title = `标题-${count} times`\n  return () => {\n    console.log(\"卸载阶段\")\n  }\n})\n```\n\n在`useState`例子基础上我们添加了`useEffect`后， 效果如下：\n\n![useEffect](http://img.nixiaolei.com/effect.gif)\n\n我们可以看到， 刷新页面后首先出现的是\"更新渲染阶段\"，\n当我们点击了按钮后， 立即出现了“卸载阶段”， 然后出现了\"更新渲染阶段\"\n\n这就证明该副作用是在每次组件更新时都会被触发的。\n\n\n#### 自定义触发\n`useEffect`不仅能够替代那些个老生命周期， 还能够自定义根据某个值来触发\n\n`useEffect`的能接收两个参数， 第一个就是刚刚我们尝试的回调， 第二个参数可传可不传， 他是一个数组， \n\n如果你不传，就和上面的例子一样， 默认全部触发，\n如果你传入的是一个空数组`[]`，那就只在第一次渲染时触发\n如果你数组里制定了值， 那就只在这些值变化时触发\n\n***\n\n比如我要指定只有 `count`变化时才会触发\n```Js\nuseEffect(() => {\n  console.log(\"更新渲染阶段\")\n  document.title = `标题-${count} times`\n  return () => {\n    console.log(\"卸载阶段\")\n  }\n}, [count])\n```\n\n| api | ability | \n| :------: | :------: | \n| state | 返回有状态值, 以及更新这个状态值的函数 | \n| useEffect | 接收包含命令式， 可能有副作用代码的函数 |\n| useContext | 接受上下文对象（从React.createContext返回的值） |\n| useReducer  | useState的替代方案 |\n| useCallback | 返回一个回忆的memoized版本， |\n| useMemo | 纯的一个记忆函数 |\n| useRef | 返回一个可变的ref对象 |\n| useImperativeMethods  | 自定义使用ref时公开给父组件的实例值之前 |\n| useMutationEffect  | 更新兄弟组件之前， 它dom改变前执行 |\n| useLayoutEffect  | Dom改变后同步触发 |\n","slug":"【React】拥抱函数组件的Hooks","published":1,"updated":"2019-09-09T16:57:46.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ta003kaas6ch88mkce"},{"title":"【React】fiber带来的API","date":"2019-04-15T15:03:00.000Z","_content":"\n[github地址](https://github.com/koba04/react-fiber-resources) \n↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n## React Fiber异步渲染\n\n### unstable_ConcurrentMode\n`React.unstable_ConcurrentMode` 是一个使子组件中的更新异步的组件，这意味着更新被视为低优先级。\n```Js\nconst ConcurrentMode = React.unstable_ConcurrentMode;\n<ConcurrentMode>\n  <App /> // Low Priority by default\n</ConcurrentMode>\n```\n### flushSync\n如果您想在组件内部使用同步更新，则可以使用ReactDOM.flushSync(cb)。在ReactDOM.flushSync回调内部，更新被视为同步优先级，这是v16的默认优先级。\n```Js\nflushSync(() => {\n  this.setState({\n    num: newNum,\n  })\n})\n```\n\n\n\n\n\n\n\n\n\n","source":"_posts/【React】革命性的fiber架构.md","raw":"---\ntitle: 【React】fiber带来的API\ndate: 2019-04-15 23:03:00\ncategories: React\ntags: React\n---\n\n[github地址](https://github.com/koba04/react-fiber-resources) \n↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n## React Fiber异步渲染\n\n### unstable_ConcurrentMode\n`React.unstable_ConcurrentMode` 是一个使子组件中的更新异步的组件，这意味着更新被视为低优先级。\n```Js\nconst ConcurrentMode = React.unstable_ConcurrentMode;\n<ConcurrentMode>\n  <App /> // Low Priority by default\n</ConcurrentMode>\n```\n### flushSync\n如果您想在组件内部使用同步更新，则可以使用ReactDOM.flushSync(cb)。在ReactDOM.flushSync回调内部，更新被视为同步优先级，这是v16的默认优先级。\n```Js\nflushSync(() => {\n  this.setState({\n    num: newNum,\n  })\n})\n```\n\n\n\n\n\n\n\n\n\n","slug":"【React】革命性的fiber架构","published":1,"updated":"2019-09-09T16:57:46.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tb003oaas6u1gan6jf"},{"title":"【React】高阶用法","date":"2019-04-02T02:55:50.000Z","_content":"\n\n\n## 默认参数\n> 当未传入props时使用预设的默认值\n\n使用静态属性`defaultProps`来定义`props`的默认值, 避免未传`props`报错的情况\n```JavaScript\nstatic defaultProps = {\n  thing: \"这是默认的props参数\"\n}\n```\n\n### demo\n```JavaScript\n// todoList.jsx\nclass TodoList extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { \n      todoList: [\n        { thing: '喝可乐' },\n        { thing: '打游戏' },\n        // 故意留空一个\n        {  },\n        { thing: '看电影' },\n        { thing: '看剧' },\n        { thing: '刷抖音' },\n        { thing: '吃饭' }\n      ] \n    }\n  }\n\n  render() {\n    const { todoList } = this.state\n    return (\n      <div className=\"wrap\">\n        {\n          todoList.map( item => <TodoItem  thing={item.thing} />)\n        }\n      </div>\n    )\n  }\n}\n\n// todoItem.jsx\nclass TodoItem extends Component {\n  constructor(props) {\n    super(props)\n  }\n  static defaultProps = {\n    thing: \"这是默认的props参数\"\n  }\n  render() {\n    return (\n      <div>\n        { this.props.thing }\n      </div>\n    )\n  }\n}\n```\n\n实际显示:\n![props默认值](http://img.nixiaolei.com/2019-04-07-11-28-59.png)\n\n\n\n## 自由的render返回值类型\n> `render`函数的要求没有以前严格了， 不用固定返回`dom` 以及 免除必须使用`()`包裹\n\n### 返回dom\n```JavaScript\nclass Demo extends Component {\n  render() {\n    return <div>Hello React</div>\n  }\n}\n```\n\n### 返回字符串\n```JavaScript\nclass Demo extends Component {\n  render() {\n    return 'Hello React'\n  }\n}\n```\n\n### 返回数组\n```JavaScript\nclass Demo extends Component {\n  render() {\n    return [\n      <li>1111</li>,\n      <li>2222</li>,\n      <li>3333</li>,\n    ]\n  }\n}\n```\n\n\n\n## 空的根节点\n> 避免了无故地嵌套\n\n写法一： \n```JavaScript\nclass Demo extends Component {\n  render() {\n    return <>\n      <li>hello world1</li>\n      <li>hello world2</li>\n      <li>hello world3</li>\n    </>\n  }\n}\n```\n\n写法二 ：\n```JavaScript\n// 使用文档片段\nimport React, { Component, Fragment } from 'react'\n\nclass Demo extends Component {\n  render() {\n    return <Fragment>\n      <li>hello world1</li>\n      <li>hello world2</li>\n      <li>hello world3</li>\n    </Fragment>\n  }\n}\n```\n\n两种写法的效果是一样的：\n![空地根节点](http://img.nixiaolei.com/2019-04-07-12-57-12.png)\n\n## PureComponent\n> 自动为状态组件添加`shouldComponentUpdate`函数\n\n```JavaScript\nimport React, { PureComponent } from 'react'\nclass TodoItem extends PureComponent {\n  \n}\n```\n\n## 更安全的数据类型\n使用`immutableJs`\n\n\n## 处理异步任务及组件\n站内搜索 `react16.6中如何处理异步`\n\n## 为函数组件做性能优化\n站内搜索 `memo`\n\n\n## 新版ref用法\n站内搜索 `react16中如何使用ref`\n\n\n\n\n","source":"_posts/【React】高阶用法.md","raw":"---\ntitle: 【React】高阶用法\ndate: 2019-04-02 10:55:50\ncategories: React\ntags: React\n---\n\n\n\n## 默认参数\n> 当未传入props时使用预设的默认值\n\n使用静态属性`defaultProps`来定义`props`的默认值, 避免未传`props`报错的情况\n```JavaScript\nstatic defaultProps = {\n  thing: \"这是默认的props参数\"\n}\n```\n\n### demo\n```JavaScript\n// todoList.jsx\nclass TodoList extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { \n      todoList: [\n        { thing: '喝可乐' },\n        { thing: '打游戏' },\n        // 故意留空一个\n        {  },\n        { thing: '看电影' },\n        { thing: '看剧' },\n        { thing: '刷抖音' },\n        { thing: '吃饭' }\n      ] \n    }\n  }\n\n  render() {\n    const { todoList } = this.state\n    return (\n      <div className=\"wrap\">\n        {\n          todoList.map( item => <TodoItem  thing={item.thing} />)\n        }\n      </div>\n    )\n  }\n}\n\n// todoItem.jsx\nclass TodoItem extends Component {\n  constructor(props) {\n    super(props)\n  }\n  static defaultProps = {\n    thing: \"这是默认的props参数\"\n  }\n  render() {\n    return (\n      <div>\n        { this.props.thing }\n      </div>\n    )\n  }\n}\n```\n\n实际显示:\n![props默认值](http://img.nixiaolei.com/2019-04-07-11-28-59.png)\n\n\n\n## 自由的render返回值类型\n> `render`函数的要求没有以前严格了， 不用固定返回`dom` 以及 免除必须使用`()`包裹\n\n### 返回dom\n```JavaScript\nclass Demo extends Component {\n  render() {\n    return <div>Hello React</div>\n  }\n}\n```\n\n### 返回字符串\n```JavaScript\nclass Demo extends Component {\n  render() {\n    return 'Hello React'\n  }\n}\n```\n\n### 返回数组\n```JavaScript\nclass Demo extends Component {\n  render() {\n    return [\n      <li>1111</li>,\n      <li>2222</li>,\n      <li>3333</li>,\n    ]\n  }\n}\n```\n\n\n\n## 空的根节点\n> 避免了无故地嵌套\n\n写法一： \n```JavaScript\nclass Demo extends Component {\n  render() {\n    return <>\n      <li>hello world1</li>\n      <li>hello world2</li>\n      <li>hello world3</li>\n    </>\n  }\n}\n```\n\n写法二 ：\n```JavaScript\n// 使用文档片段\nimport React, { Component, Fragment } from 'react'\n\nclass Demo extends Component {\n  render() {\n    return <Fragment>\n      <li>hello world1</li>\n      <li>hello world2</li>\n      <li>hello world3</li>\n    </Fragment>\n  }\n}\n```\n\n两种写法的效果是一样的：\n![空地根节点](http://img.nixiaolei.com/2019-04-07-12-57-12.png)\n\n## PureComponent\n> 自动为状态组件添加`shouldComponentUpdate`函数\n\n```JavaScript\nimport React, { PureComponent } from 'react'\nclass TodoItem extends PureComponent {\n  \n}\n```\n\n## 更安全的数据类型\n使用`immutableJs`\n\n\n## 处理异步任务及组件\n站内搜索 `react16.6中如何处理异步`\n\n## 为函数组件做性能优化\n站内搜索 `memo`\n\n\n## 新版ref用法\n站内搜索 `react16中如何使用ref`\n\n\n\n\n","slug":"【React】高阶用法","published":1,"updated":"2019-09-09T16:57:46.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tc003paas67yq3p472"},{"title":"【SSR】nuxt.js服务端渲染体验笔记","date":"2019-04-02T10:16:27.000Z","_content":"\n\n> 官网: https://zh.nuxtjs.org/\n\n\n这段时间公司招了个专门搞seo优化的,  经过他的建议我们需要整改一系列之前没有注意的细节来提升SEO的优化\n\n给我们提出了大致以下的建议\n1. 对非必要跟踪的页面的`a`标签添加 `noffollow`属性\n2. 需要对首页的`meta`的`title`,` keyword`, `description`进行设置, 而且要避免大写\n3. 网页静态化, 使用 `/`路由参数, 而不是`query`形式的参数(`?`)\n4. 去掉无关页面的`keyword`和 `description`标签\n5. 必须要有404页面\n6. 提供一个专门给爬虫爬取的`新闻栏目`, 并且入口对用户不可见\n7. 生成`sitemap.html`和`sitemap.xml`文件,  并在网站底部\"链接\"的地方以\"网站地图\"和\"XML\"添加\n8. 配置`robots.txt`文件\n9. 需要SSR\n\n\n最后一点也就是工程量最大的一点--SSR, 就是使用`Nuxt.js`的目的\n\n怎么起步就不说了, 官网写的很好, 这里就记录一下本次尝试中花了比较多的时间去理解的地方, 以及坑\n\n## compoents 和 pages目录\n顾名思义, Pages 文件夹应该存放的是页面, components应该是组件,  这其实在最开始是比较容易混淆的,  在我们平时习惯性的使用vue的时候, 一个vue文件既可以作为组件也可以作为页面,  但在 `Nuxt` 中是类似但不完全相同,  \n\npages 中的页面组件具有被强化的几个方法\n![页面组件](http://img.nixiaolei.com/2019-05-02-19-08-21.png)\n\n而components 则确实是组件的定义,  它就是最普通的`vue`组件\n\n## 可选与必选动态路由\n\nNuxt.js 的路由按照pages 文件夹的具体目录结构自动划分,  动态路由也是如此, 但动态路由可被分为可选和必选,  \n\n可选路由, 访问路径demo: `people/123`\n```\npages/\n--| people/\n-----| _id.vue\n--| _.vue\n--| index.vue\n```\n\n\n\n这样的结构是 必选路由,  访问路径demo: `people/123/456`\n> 同时可接收 123 和 456 两个参数, 并且 123 参数必须有\n```\npages/\n--| people/\n-----| _id/\n---------| _id.vue\n---------| index.vue\n--| _.vue\n--| index.vue\n```\n\n\n\n## 404页面\n`_.vue` 可以用来充当路由未被匹配上的情况, 所以我们需要的404页面就可以使用`_.vue`来编写, 放在pages目录下\n\n\n```\npages/\n--| _.vue\n--| index.vue\n```\n\n## 使用axios\n必须要在`nuxt.config.js`中添加关于`axios`的配置, 才能使用`this.$axios`访问到\n```Js\naxios: {\n  proxy: true,\n  prefix: 'http://jsonplaceholder.typicode.com', // baseURL\n  credentials: true,\n},\nproxy: {\n  '/api/': {\n    target: 'http://127.0.0.1:2001', // 代理地址\n    changeOrigin: true,\n    pathRewrite: {\n      '^/api': ''\n    },\n  },\n},\n```\n\n## 使用axios\n不需要创建 `vuex`实例\n只需要把你的 `state`,`getters`等等导出即可,  命名空间的方式也是如此,只需要多建一个文件即可\n\n如下:\n`store/index.js`\n```Js\nexport const state = () => ({\n  userInfo: 0\n})\n\nexport const getters = {\n  getUserInfo (state) {\n    return state.userInfo\n  }\n}\nexport const mutations = {\n  setUserInfo (state, data) {\n    state.userInfo = data\n  }\n}\n```\n\n`fetch.js`\n```Js\nexport const state = () => ({\n  posts: null\n})\n\nexport const getters = {\n  getPosts (state) {\n    return state.posts\n  }\n}\nexport const mutations = {\n  setPosts (state, data) {\n    state.posts = data\n  }\n}\n```\n\n\n使用`fetch`中的state时:\n```Js\n  // 写数据\n  this.$store.commit('fetch/setPosts', res.data)\n\n  // 取数据\n  this.posts = this.$store.getters['fetch/getPosts'] \n```\n\n\n\n## 服务端与客户端数据传递\n利用vuex里提供的`nuxtServerInit`,  Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（服务端调用时才会酱紫哟）\n\n举个例子，假设我们服务端的会话状态树里可以通过 req.session.user 来访问当前登录的用户。将该登录用户信息传给客户端的状态树，我们只需更新 store/index.js 如下：\n```Js\nactions: {\n  nuxtServerInit ({ commit }, { req }) {\n    if (req.session.user) {\n      commit('user', req.session.user)\n    }\n  }\n}\n```\n> 如果你使用_状态树模块化_的模式，只有主模块（即 store/index.js）适用设置该方法（其他模块设置了也不会被调用）。\n\n## 生命周期的调用环境\n在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。\n\n\n\n\n","source":"_posts/【SSR】nuxt-js体验笔记.md","raw":"---\ntitle: 【SSR】nuxt.js服务端渲染体验笔记\ndate: 2019-04-02 18:16:27\ncategories: SEO\ntags: [SSR, SEO, Vue]\n---\n\n\n> 官网: https://zh.nuxtjs.org/\n\n\n这段时间公司招了个专门搞seo优化的,  经过他的建议我们需要整改一系列之前没有注意的细节来提升SEO的优化\n\n给我们提出了大致以下的建议\n1. 对非必要跟踪的页面的`a`标签添加 `noffollow`属性\n2. 需要对首页的`meta`的`title`,` keyword`, `description`进行设置, 而且要避免大写\n3. 网页静态化, 使用 `/`路由参数, 而不是`query`形式的参数(`?`)\n4. 去掉无关页面的`keyword`和 `description`标签\n5. 必须要有404页面\n6. 提供一个专门给爬虫爬取的`新闻栏目`, 并且入口对用户不可见\n7. 生成`sitemap.html`和`sitemap.xml`文件,  并在网站底部\"链接\"的地方以\"网站地图\"和\"XML\"添加\n8. 配置`robots.txt`文件\n9. 需要SSR\n\n\n最后一点也就是工程量最大的一点--SSR, 就是使用`Nuxt.js`的目的\n\n怎么起步就不说了, 官网写的很好, 这里就记录一下本次尝试中花了比较多的时间去理解的地方, 以及坑\n\n## compoents 和 pages目录\n顾名思义, Pages 文件夹应该存放的是页面, components应该是组件,  这其实在最开始是比较容易混淆的,  在我们平时习惯性的使用vue的时候, 一个vue文件既可以作为组件也可以作为页面,  但在 `Nuxt` 中是类似但不完全相同,  \n\npages 中的页面组件具有被强化的几个方法\n![页面组件](http://img.nixiaolei.com/2019-05-02-19-08-21.png)\n\n而components 则确实是组件的定义,  它就是最普通的`vue`组件\n\n## 可选与必选动态路由\n\nNuxt.js 的路由按照pages 文件夹的具体目录结构自动划分,  动态路由也是如此, 但动态路由可被分为可选和必选,  \n\n可选路由, 访问路径demo: `people/123`\n```\npages/\n--| people/\n-----| _id.vue\n--| _.vue\n--| index.vue\n```\n\n\n\n这样的结构是 必选路由,  访问路径demo: `people/123/456`\n> 同时可接收 123 和 456 两个参数, 并且 123 参数必须有\n```\npages/\n--| people/\n-----| _id/\n---------| _id.vue\n---------| index.vue\n--| _.vue\n--| index.vue\n```\n\n\n\n## 404页面\n`_.vue` 可以用来充当路由未被匹配上的情况, 所以我们需要的404页面就可以使用`_.vue`来编写, 放在pages目录下\n\n\n```\npages/\n--| _.vue\n--| index.vue\n```\n\n## 使用axios\n必须要在`nuxt.config.js`中添加关于`axios`的配置, 才能使用`this.$axios`访问到\n```Js\naxios: {\n  proxy: true,\n  prefix: 'http://jsonplaceholder.typicode.com', // baseURL\n  credentials: true,\n},\nproxy: {\n  '/api/': {\n    target: 'http://127.0.0.1:2001', // 代理地址\n    changeOrigin: true,\n    pathRewrite: {\n      '^/api': ''\n    },\n  },\n},\n```\n\n## 使用axios\n不需要创建 `vuex`实例\n只需要把你的 `state`,`getters`等等导出即可,  命名空间的方式也是如此,只需要多建一个文件即可\n\n如下:\n`store/index.js`\n```Js\nexport const state = () => ({\n  userInfo: 0\n})\n\nexport const getters = {\n  getUserInfo (state) {\n    return state.userInfo\n  }\n}\nexport const mutations = {\n  setUserInfo (state, data) {\n    state.userInfo = data\n  }\n}\n```\n\n`fetch.js`\n```Js\nexport const state = () => ({\n  posts: null\n})\n\nexport const getters = {\n  getPosts (state) {\n    return state.posts\n  }\n}\nexport const mutations = {\n  setPosts (state, data) {\n    state.posts = data\n  }\n}\n```\n\n\n使用`fetch`中的state时:\n```Js\n  // 写数据\n  this.$store.commit('fetch/setPosts', res.data)\n\n  // 取数据\n  this.posts = this.$store.getters['fetch/getPosts'] \n```\n\n\n\n## 服务端与客户端数据传递\n利用vuex里提供的`nuxtServerInit`,  Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（服务端调用时才会酱紫哟）\n\n举个例子，假设我们服务端的会话状态树里可以通过 req.session.user 来访问当前登录的用户。将该登录用户信息传给客户端的状态树，我们只需更新 store/index.js 如下：\n```Js\nactions: {\n  nuxtServerInit ({ commit }, { req }) {\n    if (req.session.user) {\n      commit('user', req.session.user)\n    }\n  }\n}\n```\n> 如果你使用_状态树模块化_的模式，只有主模块（即 store/index.js）适用设置该方法（其他模块设置了也不会被调用）。\n\n## 生命周期的调用环境\n在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。\n\n\n\n\n","slug":"【SSR】nuxt-js体验笔记","published":1,"updated":"2019-09-09T16:57:46.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4td003saas6s00h0c63"},{"title":"【Three】Three.js光源入门之点光源","date":"2019-04-04T09:47:05.000Z","_content":"\n点光源是一种单点发光照亮物体的光源\n\n## 基础介绍\n* 照射所有方向的光源，例如照明弹\n* 点光源是单点发光方式\n* 点光源不会产生阴影， 减少GPU 的负担\n\n\n\n## 调用方法\n```Js\nTHREE.PointLight(hex, intensity, distance)\n```\n\n* clone() ---- 复制当前颜色。 color 光源颜色\n* intensity ---- 光照强度\n* distance ---- 光源照射的距离\n* position ---- 光源所在位置\n\n\n\n## 测试点光源\n测试方法和大体上和环境光是一样的， 但是点光源和环境光不同的是， 他有个特点， 它能产生阴影\n\n那我们就创建一个点光源和几个几何物体， 顺便移动一下点光源， 看看阴影是如何变化的\n\n### 创建立方体\n```Js\n\n// 立方体\nvar cubeGeomtry = new THREE.BoxGeometry(5,5,5)\nvar cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\nvar cube = new THREE.Mesh(cubeGeomtry, cubeMaterial)\ncube.position.set(0, 6, 0)\ncommonObj.scene.add(cube)\n```\n\n### 创建球体\n\n```js\n// 球体\nvar sphereGeometry = new THREE.SphereGeometry(4, 20, 30)\nvar sphreMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\nvar sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)\nsphere.position.set(20, 6, 0)\ncommonObj.scene.add(sphere)\n```\n\n\n### 创建点光源\n```Js\n// 添加点光源\nvar pointLight = new THREE.PointLight(0xffffff)\npointLight.position.set(-40, 60, -10)\ncommonObj.scene.add(pointLight)\n```\n\n\n### 让点光源动起来\n```JS\nfunction render() {\n  requestAnimationFrame(render)\n  pointLight.position.z += 0.2\n  commonObj.renderer.render(commonObj.scene, commonObj.camera)\n}\n\nrender()\n```\n\n### 最终效果\n\n我们可以看到， 随着点光源的不断发生位置变动， 我们可以看到阴影发生逐渐的发生变化\n\n![](http://img.nixiaolei.com/yA1pla0mDn.gif)\n\n\n## 完整代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<script src=\"../common/common.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script src=\"../common/common.js\"></script>\n<script>\n  var commonObj = common()\n\n  // 立方体\n  var cubeGeomtry = new THREE.BoxGeometry(5,5,5)\n  var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\n  var cube = new THREE.Mesh(cubeGeomtry, cubeMaterial)\n  cube.position.set(0, 6, 0)\n  commonObj.scene.add(cube)\n  \n  // 球体\n  var sphereGeometry = new THREE.SphereGeometry(4, 20, 30)\n  var sphreMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\n  var sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)\n  sphere.position.set(20, 6, 0)\n  commonObj.scene.add(sphere)\n  \n  \n  commonObj.camera.position.set(-25, 30, 25)\n  commonObj.camera.lookAt(commonObj.scene.position)\n\n\n\n\n  // 添加点光源\n  var pointLight = new THREE.PointLight(0xffffff)\n  pointLight.position.set(-40, 60, -10)\n  commonObj.scene.add(pointLight)\n\n  function render() {\n    requestAnimationFrame(render)\n    pointLight.position.z += 0.2\n    commonObj.renderer.render(commonObj.scene, commonObj.camera)\n  }\n\n  render()\n  document.body.appendChild(commonObj.renderer.domElement)\n</script>\n</html>\n```\n\n\n\n","source":"_posts/【Three】Three-js光源入门之点光源.md","raw":"---\ntitle: 【Three】Three.js光源入门之点光源\ndate: 2019-04-04 17:47:05\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n点光源是一种单点发光照亮物体的光源\n\n## 基础介绍\n* 照射所有方向的光源，例如照明弹\n* 点光源是单点发光方式\n* 点光源不会产生阴影， 减少GPU 的负担\n\n\n\n## 调用方法\n```Js\nTHREE.PointLight(hex, intensity, distance)\n```\n\n* clone() ---- 复制当前颜色。 color 光源颜色\n* intensity ---- 光照强度\n* distance ---- 光源照射的距离\n* position ---- 光源所在位置\n\n\n\n## 测试点光源\n测试方法和大体上和环境光是一样的， 但是点光源和环境光不同的是， 他有个特点， 它能产生阴影\n\n那我们就创建一个点光源和几个几何物体， 顺便移动一下点光源， 看看阴影是如何变化的\n\n### 创建立方体\n```Js\n\n// 立方体\nvar cubeGeomtry = new THREE.BoxGeometry(5,5,5)\nvar cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\nvar cube = new THREE.Mesh(cubeGeomtry, cubeMaterial)\ncube.position.set(0, 6, 0)\ncommonObj.scene.add(cube)\n```\n\n### 创建球体\n\n```js\n// 球体\nvar sphereGeometry = new THREE.SphereGeometry(4, 20, 30)\nvar sphreMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\nvar sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)\nsphere.position.set(20, 6, 0)\ncommonObj.scene.add(sphere)\n```\n\n\n### 创建点光源\n```Js\n// 添加点光源\nvar pointLight = new THREE.PointLight(0xffffff)\npointLight.position.set(-40, 60, -10)\ncommonObj.scene.add(pointLight)\n```\n\n\n### 让点光源动起来\n```JS\nfunction render() {\n  requestAnimationFrame(render)\n  pointLight.position.z += 0.2\n  commonObj.renderer.render(commonObj.scene, commonObj.camera)\n}\n\nrender()\n```\n\n### 最终效果\n\n我们可以看到， 随着点光源的不断发生位置变动， 我们可以看到阴影发生逐渐的发生变化\n\n![](http://img.nixiaolei.com/yA1pla0mDn.gif)\n\n\n## 完整代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<script src=\"../common/common.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script src=\"../common/common.js\"></script>\n<script>\n  var commonObj = common()\n\n  // 立方体\n  var cubeGeomtry = new THREE.BoxGeometry(5,5,5)\n  var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\n  var cube = new THREE.Mesh(cubeGeomtry, cubeMaterial)\n  cube.position.set(0, 6, 0)\n  commonObj.scene.add(cube)\n  \n  // 球体\n  var sphereGeometry = new THREE.SphereGeometry(4, 20, 30)\n  var sphreMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\n  var sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)\n  sphere.position.set(20, 6, 0)\n  commonObj.scene.add(sphere)\n  \n  \n  commonObj.camera.position.set(-25, 30, 25)\n  commonObj.camera.lookAt(commonObj.scene.position)\n\n\n\n\n  // 添加点光源\n  var pointLight = new THREE.PointLight(0xffffff)\n  pointLight.position.set(-40, 60, -10)\n  commonObj.scene.add(pointLight)\n\n  function render() {\n    requestAnimationFrame(render)\n    pointLight.position.z += 0.2\n    commonObj.renderer.render(commonObj.scene, commonObj.camera)\n  }\n\n  render()\n  document.body.appendChild(commonObj.renderer.domElement)\n</script>\n</html>\n```\n\n\n\n","slug":"【Three】Three-js光源入门之点光源","published":1,"updated":"2019-09-09T16:57:46.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4te003vaas6sx4y1bmr"},{"title":"【Three】Three.js光源入门之环境光","date":"2019-04-04T09:47:05.000Z","_content":"\n环境光是环境整体的光照效果， 是场景内若干光源的多次反射形成的一种亮度一致的效果\n\n\n## 环境光\n> AmbientLight \n\n它是一种基础光源， 影响整个场景的光源\n\n环境光没有明确的光源位置， 在各处形成的亮度也是一致的。\n\n它不会影响阴影的产生。\n\n不能将环境光作为场景中唯一的光源。\n\n### 在Three中使用\n> THREE.AmbientLight(hex)\n\n> add(color) 添加到当前颜色上\n\n> clone 复制当前颜色\n\n\n如果只有环境光没有物同样是看不见东西的， 所以想测试环境光， 得先创建物体， \n\n看一下下面两幅图:\n\n\n这是正常环境光情况下的物体\n![正常环境光](http://img.nixiaolei.com/three-ambientLight.png)\n\n\n然后我们把环境光调暗一点:\n\n![调暗环境光](http://img.nixiaolei.com/three-ambientLight-darker.png)\n\n\n可以看到， 两张图中鲜艳的绿色明显的暗淡了\n\n### 环境光换色\n\n刚刚我们只是调整了亮度明暗， 现在我们试试给环境光换个颜色， 就换个红色吧， 红色的灯感觉蛮吓人的\n\n\n![红色环境光](http://img.nixiaolei.com/three-ambientLight-red02.png)\n\n\n我们发现， 立方体好像少了一个， 这是因为一个不透明的物体 ， 我们所看到的颜色其实是他反射出来的颜色， 而绿色立方体无法反射红色通道的颜色， 所以， 绿色立方体在我们看上去就像是隐藏了一样， 实际上是黑了， 而我们的白色， 他能反射所有颜色， 所以是他就变红了\n\n\n## 如何添加\n```Js\nscene.add(new THREE.AmbientLight(0xff0000))\n```\n\n## 实际操作一下\n大体思路， 我们创建一个面，和一个立方体， 先不投射任何的光，看看是什么效果， 然后我们最后放上环境光，看一下效果\n\n\n### 第一步-创建好立方体和面\n\n\n```Js\n var commonObj = common()\n  var cubeGeometry = new THREE.BoxGeometry(5,5,5)\n  var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\n  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n\n  // 打开立方体的阴影\n  cube.castShadow = true\n  cube.position.set(-4, 2.5, 0)\n  \n  commonObj.scene.add(cube)\n  // 调整相机位置\n  commonObj.camera.position.set(-25, 20, 25)\n  // 镜头朝向舞台中央\n  commonObj.camera.lookAt(commonObj.scene.position)\n\n\n  document.body.appendChild(commonObj.renderer.domElement)\n  commonObj.renderer.render(commonObj.scene, commonObj.camera)\n```\n\n此时浏览器中的效果\n![无光环境](http://img.nixiaolei.com/three-ambientLight-nolight.png)\n\n可以看到， 此时尽管我们给物体设定了他的颜色， 但我们看到的不管是面还是立方体都依旧是黑色。\n\n### 第二步-添加光源\n上帝说要有光， 我们给添加一个环境光试试\n\n```Js\n// 环境光\ncommonObj.scene.add(new THREE.AmbientLight()) // 默认白光\n```\n\n好， 就这行代码，就算是加上了\n\n![有光环境](http://img.nixiaolei.com/three-ambientLight-haslight.png)\n\n### 第三步-改变环境光颜色\n环境光默认是白色， 那我们可不可以试着改变一下， 把环境光改为红色？ 是不是会很吓人\n\n```Js\n// 环境光\ncommonObj.scene.add(new THREE.AmbientLight(0xff0000)) // 设置红色\n```\n\n\n![红色环境光](http://img.nixiaolei.com/three-ambientLight-redlight.png)\n\n此时原本白色的面，也变为了红色， 感觉好刺眼， 吓得我赶紧关了\n\n\n\n\n\n## 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script src=\"../common/common.js\"></script>\n<script>\n  // 公共的方法\n  function common() {\n    var scene = new THREE.Scene()\n    \n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0))\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    renderer.shadowMapEnabled = true\n    // 创建面\n    var planeGeometry = new THREE.PlaneGeometry(60, 30)\n    // 材质\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff})\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    \n    plane.rotation.x = -0.5 * Math.PI\n    plane.position.set(15, 0, 10)\n    scene.add(plane)\n\n    var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)\n\n    return {\n      scene,\n      renderer,\n      plane,\n      camera\n    }\n  }\n\n\n  // 开始创建\n\n  var commonObj = common()\n  var cubeGeometry = new THREE.BoxGeometry(5,5,5)\n  var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\n  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n\n  // 打开立方体的阴影\n  cube.castShadow = true\n  cube.position.set(-4, 2.5, 0)\n  \n  commonObj.scene.add(cube)\n  // 调整相机位置\n  commonObj.camera.position.set(-25, 20, 25)\n  // 镜头朝向舞台中央\n  commonObj.camera.lookAt(commonObj.scene.position)\n\n  // 环境光\n  commonObj.scene.add(new THREE.AmbientLight())\n  \n  document.body.appendChild(commonObj.renderer.domElement)\n  commonObj.renderer.render(commonObj.scene, commonObj.camera)\n</script>\n</html>\n```\n\n\n\n\n\n\n\n","source":"_posts/【Three】Three-js光源入门之环境光.md","raw":"---\ntitle: 【Three】Three.js光源入门之环境光\ndate: 2019-04-04 17:47:05\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n环境光是环境整体的光照效果， 是场景内若干光源的多次反射形成的一种亮度一致的效果\n\n\n## 环境光\n> AmbientLight \n\n它是一种基础光源， 影响整个场景的光源\n\n环境光没有明确的光源位置， 在各处形成的亮度也是一致的。\n\n它不会影响阴影的产生。\n\n不能将环境光作为场景中唯一的光源。\n\n### 在Three中使用\n> THREE.AmbientLight(hex)\n\n> add(color) 添加到当前颜色上\n\n> clone 复制当前颜色\n\n\n如果只有环境光没有物同样是看不见东西的， 所以想测试环境光， 得先创建物体， \n\n看一下下面两幅图:\n\n\n这是正常环境光情况下的物体\n![正常环境光](http://img.nixiaolei.com/three-ambientLight.png)\n\n\n然后我们把环境光调暗一点:\n\n![调暗环境光](http://img.nixiaolei.com/three-ambientLight-darker.png)\n\n\n可以看到， 两张图中鲜艳的绿色明显的暗淡了\n\n### 环境光换色\n\n刚刚我们只是调整了亮度明暗， 现在我们试试给环境光换个颜色， 就换个红色吧， 红色的灯感觉蛮吓人的\n\n\n![红色环境光](http://img.nixiaolei.com/three-ambientLight-red02.png)\n\n\n我们发现， 立方体好像少了一个， 这是因为一个不透明的物体 ， 我们所看到的颜色其实是他反射出来的颜色， 而绿色立方体无法反射红色通道的颜色， 所以， 绿色立方体在我们看上去就像是隐藏了一样， 实际上是黑了， 而我们的白色， 他能反射所有颜色， 所以是他就变红了\n\n\n## 如何添加\n```Js\nscene.add(new THREE.AmbientLight(0xff0000))\n```\n\n## 实际操作一下\n大体思路， 我们创建一个面，和一个立方体， 先不投射任何的光，看看是什么效果， 然后我们最后放上环境光，看一下效果\n\n\n### 第一步-创建好立方体和面\n\n\n```Js\n var commonObj = common()\n  var cubeGeometry = new THREE.BoxGeometry(5,5,5)\n  var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\n  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n\n  // 打开立方体的阴影\n  cube.castShadow = true\n  cube.position.set(-4, 2.5, 0)\n  \n  commonObj.scene.add(cube)\n  // 调整相机位置\n  commonObj.camera.position.set(-25, 20, 25)\n  // 镜头朝向舞台中央\n  commonObj.camera.lookAt(commonObj.scene.position)\n\n\n  document.body.appendChild(commonObj.renderer.domElement)\n  commonObj.renderer.render(commonObj.scene, commonObj.camera)\n```\n\n此时浏览器中的效果\n![无光环境](http://img.nixiaolei.com/three-ambientLight-nolight.png)\n\n可以看到， 此时尽管我们给物体设定了他的颜色， 但我们看到的不管是面还是立方体都依旧是黑色。\n\n### 第二步-添加光源\n上帝说要有光， 我们给添加一个环境光试试\n\n```Js\n// 环境光\ncommonObj.scene.add(new THREE.AmbientLight()) // 默认白光\n```\n\n好， 就这行代码，就算是加上了\n\n![有光环境](http://img.nixiaolei.com/three-ambientLight-haslight.png)\n\n### 第三步-改变环境光颜色\n环境光默认是白色， 那我们可不可以试着改变一下， 把环境光改为红色？ 是不是会很吓人\n\n```Js\n// 环境光\ncommonObj.scene.add(new THREE.AmbientLight(0xff0000)) // 设置红色\n```\n\n\n![红色环境光](http://img.nixiaolei.com/three-ambientLight-redlight.png)\n\n此时原本白色的面，也变为了红色， 感觉好刺眼， 吓得我赶紧关了\n\n\n\n\n\n## 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script src=\"../common/common.js\"></script>\n<script>\n  // 公共的方法\n  function common() {\n    var scene = new THREE.Scene()\n    \n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0))\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    renderer.shadowMapEnabled = true\n    // 创建面\n    var planeGeometry = new THREE.PlaneGeometry(60, 30)\n    // 材质\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff})\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    \n    plane.rotation.x = -0.5 * Math.PI\n    plane.position.set(15, 0, 10)\n    scene.add(plane)\n\n    var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)\n\n    return {\n      scene,\n      renderer,\n      plane,\n      camera\n    }\n  }\n\n\n  // 开始创建\n\n  var commonObj = common()\n  var cubeGeometry = new THREE.BoxGeometry(5,5,5)\n  var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\n  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n\n  // 打开立方体的阴影\n  cube.castShadow = true\n  cube.position.set(-4, 2.5, 0)\n  \n  commonObj.scene.add(cube)\n  // 调整相机位置\n  commonObj.camera.position.set(-25, 20, 25)\n  // 镜头朝向舞台中央\n  commonObj.camera.lookAt(commonObj.scene.position)\n\n  // 环境光\n  commonObj.scene.add(new THREE.AmbientLight())\n  \n  document.body.appendChild(commonObj.renderer.domElement)\n  commonObj.renderer.render(commonObj.scene, commonObj.camera)\n</script>\n</html>\n```\n\n\n\n\n\n\n\n","slug":"【Three】Three-js光源入门之环境光","published":1,"updated":"2019-09-09T16:57:46.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tg003zaas6ihgpqghl"},{"title":"【Three】Three.js入门之光源","date":"2019-04-04T09:47:05.000Z","_content":"\n\n光源也分为很多种\n\n* AmbientLight ---- 环境光\n* PonitLight ---- 点光源\n* SpotLight ---- 聚光灯\n* DirectionalLight ---- 平行光\n\n然后还有各种高级的光照效果\n\n## 光源种类描述\n> 具体内容在站内搜索光源的关键字， 如：环境光，  篇幅太长不在此处描述\n\n### 环境光\n> AmbientLight\n\n基础光源， 影响整个场景的光源\n\n### 点光源\n> PonitLight\n\n空间中的一个点， 朝所有方向发射光源\n\n### 聚光灯\n> SpotLight\n\n具有锥形效果的聚光灯光源\n\n### 平行光\n无限光， 模拟远处太阳的光辉\n\n### 高级光照效果\n* 半球光\n* 平面光\n* 镜头眩光\n\n\n\n\n\n\n\n\n\n","source":"_posts/【Three】Three-js入门之光源.md","raw":"---\ntitle: 【Three】Three.js入门之光源\ndate: 2019-04-04 17:47:05\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n\n光源也分为很多种\n\n* AmbientLight ---- 环境光\n* PonitLight ---- 点光源\n* SpotLight ---- 聚光灯\n* DirectionalLight ---- 平行光\n\n然后还有各种高级的光照效果\n\n## 光源种类描述\n> 具体内容在站内搜索光源的关键字， 如：环境光，  篇幅太长不在此处描述\n\n### 环境光\n> AmbientLight\n\n基础光源， 影响整个场景的光源\n\n### 点光源\n> PonitLight\n\n空间中的一个点， 朝所有方向发射光源\n\n### 聚光灯\n> SpotLight\n\n具有锥形效果的聚光灯光源\n\n### 平行光\n无限光， 模拟远处太阳的光辉\n\n### 高级光照效果\n* 半球光\n* 平面光\n* 镜头眩光\n\n\n\n\n\n\n\n\n\n","slug":"【Three】Three-js入门之光源","published":1,"updated":"2019-09-09T16:57:46.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4th0041aas6fas4kawz"},{"title":"【Three】Three.js光源入门之聚光灯","date":"2019-04-04T09:47:05.000Z","_content":"\n聚光灯是一特殊的光源， 聚光灯能朝一个方向投射出锥形的光线。\n\n## 基础特性\n* 具有锥形效果的光源， 能够朝着一个方向投射光线\n* 最常用到的光源， 它可以产生阴影\n* 锥形效果， 类似电筒光照效果\n\n### 光照效果样例\n\n![光照效果样例](http://img.nixiaolei.com/three-SpotLight.png)\n\n## 使用方式\n> THREE.SpotLight(hex, intensity, distance, angle, exponent)\n\n`castShadow` ---- 如果设置为`true`, 这个光源就会产生阴影。\ntarget ---- 决定光照方向。\nangle ---- 光照的角度， 默认值是 `Math.PI / 3`\n\n\n## 实践一下\n按照惯例， 我们测试灯光需要有几何物体才能体现出来， 因为聚光灯是中心最亮， 逐渐向外变暗， 所以我们创建几个立方体， 然后想办法摆动一下聚光灯的位置和角度看看具体效果\n\n### 第一步-创建立方体\n```JS\n// 立方体\nvar cubeGeometry = new THREE.BoxGeometry(5,5,5)\nvar cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\nvar cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n// 打开立方体的阴影\ncube.castShadow = true\ncube.position.set(-4, 2.5, 0)\ncommonObj.scene.add(cube) // 调整相机位置\n```\n\n### 第二步-创建球体\n```Js\n// 圆球\nvar sphereGeometry = new THREE.SphereGeometry(4, 20, 30)\nvar sphreMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\nvar sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)\nsphere.position.set(20, 6, 0)\ncommonObj.scene.add(sphere)\n```\n\n### 第三步-创建聚光灯\n创建聚光灯并将聚光灯的目标调整为刚才创建的 球体\n\n```Js\n // 聚光灯光源\nvar spotLight = new THREE.SpotLight('#ffffff')\nspotLight.position.x = -40\nspotLight.position.y = 60\nspotLight.position.z = -12\n// 选择照射目标\nsphere.target = sphere\n// 加入场景\ncommonObj.scene.add(spotLight)\n```\n\n### 第四步-用键盘控制聚光灯的角度及位置\n键盘方向的上下键控制聚光灯的角度，左右键控制聚光灯的位置\n\n```JS\n// 设置初始角度\nvar angleNUM = 3\ndocument.onkeydown = function (e) {\n  // 上键 控制聚光灯角度\n  switch(e.keyCode) {\n    case 38:\n      angleNUM += 1\n      break;\n      // 下键\n    case 40: \n      angleNUM -= 1\n      if( angleNUM < 1 ) {\n        angleNUM = 1\n      }\n      break\n    // 左右键控制聚光灯位移\n    case 37:\n      spotLight.position.x += 2\n      break\n    case 39:\n      spotLight.position.x -= 2\n      break\n  }\n}\n```\n\n\n### 第五步-实时渲染\n在每一帧时根据当前的情况调整聚光灯的角度\n\n```js\nfunction render() {\n  window.requestAnimationFrame(render)\n  commonObj.renderer.render(commonObj.scene, commonObj.camera)\n  spotLight.angle = Math.PI / angleNUM\n}\n```\n\n\n\n### 最终效果\n\n该图中， 前半段我先按了上下键来调整聚光灯角度， 后半段我按了左右键来控制聚光灯位置\n\n![聚光灯效果](http://img.nixiaolei.com/three-juguangdeng-keymove.gif)\n\n\n## 完整代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<script src=\"../common/common.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script src=\"../common/common.js\"></script>\n<script>\n  var commonObj = common()\n\n  // 立方体\n  var cubeGeometry = new THREE.BoxGeometry(5,5,5)\n  var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\n  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n  // 打开立方体的阴影\n  cube.castShadow = true\n  cube.position.set(-4, 2.5, 0)\n  commonObj.scene.add(cube) // 调整相机位置\n  \n  // 圆球\n  var sphereGeometry = new THREE.SphereGeometry(4, 20, 30)\n  var sphreMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\n  var sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)\n  sphere.position.set(20, 6, 0)\n  commonObj.scene.add(sphere)\n\n\n  commonObj.camera.position.set(-25, 20, 25) // 镜头朝向舞台中央\n  commonObj.camera.lookAt(commonObj.scene.position)\n\n  // 聚光灯光源\n  var spotLight = new THREE.SpotLight('#ffffff')\n  spotLight.position.x = -40\n  spotLight.position.y = 60\n  spotLight.position.z = -12\n  // 选择照射目标\n  sphere.target = sphere\n  commonObj.scene.add(spotLight)\n\n\n  function render() {\n    window.requestAnimationFrame(render)\n    commonObj.renderer.render(commonObj.scene, commonObj.camera)\n    spotLight.angle = Math.PI / angleNUM\n  }\n\n  // 设置初始角度\n  var angleNUM = 3\n  document.onkeydown = function (e) {\n    // 上键 控制聚光灯角度\n    switch(e.keyCode) {\n      case 38:\n        angleNUM += 1\n        break;\n        // 下键\n      case 40: \n        angleNUM -= 1\n        if( angleNUM < 1 ) {\n          angleNUM = 1\n        }\n        break\n      // 聚光灯位移\n      case 37:\n        spotLight.position.x += 2\n        break\n      case 39:\n        spotLight.position.x -= 2\n        break\n    }\n  }\n\n\n  render()\n  document.body.appendChild(commonObj.renderer.domElement)\n</script>\n</html>\n```\n","source":"_posts/【Three】Three-js光源入门之聚光灯.md","raw":"---\ntitle: 【Three】Three.js光源入门之聚光灯\ndate: 2019-04-04 17:47:05\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n聚光灯是一特殊的光源， 聚光灯能朝一个方向投射出锥形的光线。\n\n## 基础特性\n* 具有锥形效果的光源， 能够朝着一个方向投射光线\n* 最常用到的光源， 它可以产生阴影\n* 锥形效果， 类似电筒光照效果\n\n### 光照效果样例\n\n![光照效果样例](http://img.nixiaolei.com/three-SpotLight.png)\n\n## 使用方式\n> THREE.SpotLight(hex, intensity, distance, angle, exponent)\n\n`castShadow` ---- 如果设置为`true`, 这个光源就会产生阴影。\ntarget ---- 决定光照方向。\nangle ---- 光照的角度， 默认值是 `Math.PI / 3`\n\n\n## 实践一下\n按照惯例， 我们测试灯光需要有几何物体才能体现出来， 因为聚光灯是中心最亮， 逐渐向外变暗， 所以我们创建几个立方体， 然后想办法摆动一下聚光灯的位置和角度看看具体效果\n\n### 第一步-创建立方体\n```JS\n// 立方体\nvar cubeGeometry = new THREE.BoxGeometry(5,5,5)\nvar cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\nvar cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n// 打开立方体的阴影\ncube.castShadow = true\ncube.position.set(-4, 2.5, 0)\ncommonObj.scene.add(cube) // 调整相机位置\n```\n\n### 第二步-创建球体\n```Js\n// 圆球\nvar sphereGeometry = new THREE.SphereGeometry(4, 20, 30)\nvar sphreMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\nvar sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)\nsphere.position.set(20, 6, 0)\ncommonObj.scene.add(sphere)\n```\n\n### 第三步-创建聚光灯\n创建聚光灯并将聚光灯的目标调整为刚才创建的 球体\n\n```Js\n // 聚光灯光源\nvar spotLight = new THREE.SpotLight('#ffffff')\nspotLight.position.x = -40\nspotLight.position.y = 60\nspotLight.position.z = -12\n// 选择照射目标\nsphere.target = sphere\n// 加入场景\ncommonObj.scene.add(spotLight)\n```\n\n### 第四步-用键盘控制聚光灯的角度及位置\n键盘方向的上下键控制聚光灯的角度，左右键控制聚光灯的位置\n\n```JS\n// 设置初始角度\nvar angleNUM = 3\ndocument.onkeydown = function (e) {\n  // 上键 控制聚光灯角度\n  switch(e.keyCode) {\n    case 38:\n      angleNUM += 1\n      break;\n      // 下键\n    case 40: \n      angleNUM -= 1\n      if( angleNUM < 1 ) {\n        angleNUM = 1\n      }\n      break\n    // 左右键控制聚光灯位移\n    case 37:\n      spotLight.position.x += 2\n      break\n    case 39:\n      spotLight.position.x -= 2\n      break\n  }\n}\n```\n\n\n### 第五步-实时渲染\n在每一帧时根据当前的情况调整聚光灯的角度\n\n```js\nfunction render() {\n  window.requestAnimationFrame(render)\n  commonObj.renderer.render(commonObj.scene, commonObj.camera)\n  spotLight.angle = Math.PI / angleNUM\n}\n```\n\n\n\n### 最终效果\n\n该图中， 前半段我先按了上下键来调整聚光灯角度， 后半段我按了左右键来控制聚光灯位置\n\n![聚光灯效果](http://img.nixiaolei.com/three-juguangdeng-keymove.gif)\n\n\n## 完整代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<script src=\"../common/common.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script src=\"../common/common.js\"></script>\n<script>\n  var commonObj = common()\n\n  // 立方体\n  var cubeGeometry = new THREE.BoxGeometry(5,5,5)\n  var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })\n  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n  // 打开立方体的阴影\n  cube.castShadow = true\n  cube.position.set(-4, 2.5, 0)\n  commonObj.scene.add(cube) // 调整相机位置\n  \n  // 圆球\n  var sphereGeometry = new THREE.SphereGeometry(4, 20, 30)\n  var sphreMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\n  var sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)\n  sphere.position.set(20, 6, 0)\n  commonObj.scene.add(sphere)\n\n\n  commonObj.camera.position.set(-25, 20, 25) // 镜头朝向舞台中央\n  commonObj.camera.lookAt(commonObj.scene.position)\n\n  // 聚光灯光源\n  var spotLight = new THREE.SpotLight('#ffffff')\n  spotLight.position.x = -40\n  spotLight.position.y = 60\n  spotLight.position.z = -12\n  // 选择照射目标\n  sphere.target = sphere\n  commonObj.scene.add(spotLight)\n\n\n  function render() {\n    window.requestAnimationFrame(render)\n    commonObj.renderer.render(commonObj.scene, commonObj.camera)\n    spotLight.angle = Math.PI / angleNUM\n  }\n\n  // 设置初始角度\n  var angleNUM = 3\n  document.onkeydown = function (e) {\n    // 上键 控制聚光灯角度\n    switch(e.keyCode) {\n      case 38:\n        angleNUM += 1\n        break;\n        // 下键\n      case 40: \n        angleNUM -= 1\n        if( angleNUM < 1 ) {\n          angleNUM = 1\n        }\n        break\n      // 聚光灯位移\n      case 37:\n        spotLight.position.x += 2\n        break\n      case 39:\n        spotLight.position.x -= 2\n        break\n    }\n  }\n\n\n  render()\n  document.body.appendChild(commonObj.renderer.domElement)\n</script>\n</html>\n```\n","slug":"【Three】Three-js光源入门之聚光灯","published":1,"updated":"2019-09-09T16:57:46.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ti0045aas6w82snmc7"},{"title":"【Three】Three.js入门之添加动画","date":"2019-04-03T09:47:05.000Z","_content":"\n本文基于\"Three.js入门之添加材质和灯光\" 文章之后\n\n\n## 帧率辅助库\n> 在官网下载到的three文件中的 `/examples/js/libs/stats.min.js` 可以找到\n\n这个是一个three 开发者之一写的库， 可以给我提供检测动画流畅度的数据， 引入方式和`three`一样\n\n\n如何使用呢， \n\n### 创建一个dom\n\n我们给他预留一个`dom`\n```html\n<body>\n  <div id=\"stats-output\"></div>\n</body>\n```\n\n### 初始化统计对象\n```Js\n// 初始化统计对象\nfunction initStats() {\n  // 创建实例\n  var stats = new Stats()\n  // 设置模式， 0 显示 fps, 1 检测渲染时间\n  stats.setMode(0) \n  // 样式设置\n  stats.domElement.style.position = 'absolute'\n  stats.domElement.style.left = \"0px\"\n  stats.domElement.style.top = \"0px\"\n  // 加入刚才的dom\n  document.getElementById('stats-output').appendChild(stats.domElement)\n  return stats\n}\n```\n\n### 在每一帧动画期间更新\n因为这里我们的动画使用的是`requestAnimationFrame`, 所以我们在每次调用该方法时， 去更新一下统计对象即可\n\n```Js\nfunction render() {\n  // 更新统计对象\n  stats.update()\n\n  // 主循环\n  requestAnimationFrame(render)\n  // 渲染当前的场景\n  renderer.render(scene, camera)\n}\n```\n\n### 查看一下结果\n这些都做好以后，打开浏览器， 左上角就可以看到我们刚刚创建的统计对象了\n\n![统计对象](http://img.nixiaolei.com/2019-05-03-20-55-25.png)\n\n\n\n## 创建动画\n因为js定时器的种种问题， 计时不准确，  无法预估浏览器算力等等问题， 所以`requestAnimationFrame`\n是我们做动画时的首选， 它可以根据浏览器的具体繁忙情况自动控制帧率\n\n### 创建主循环\n先把之前的最后一步的渲染操作放入`requestAnimationFrame` 这个主循环， \n\n```Js\nfunction render() {\n  stats.update() // 上面👆使用的帧率统计\n  // 回调传入自身\n  requestAnimationFrame(render)\n  renderer.render(scene, camera)\n}\n\n\n // 将renderer的输出挂到body\ndocument.body.appendChild(renderer.domElement)\nrender()\n```\n\n这样，我们的主循环就创建好了， 但是还不够， 如果你刷新浏览器， 你看到的依旧是静止的， 因为你的代码没有任何变化， 所以， 我们就尝试着让他发生一些变化\n\n\n### 让正方体动起来\n我们让正方体旋转起来， 我们在每一帧都修改一下这个正方体的 `x,y,z` 坐标位置\n\n```Js\nfunction render() {\n  stats.update() // 上面👆使用的帧率统计\n\n  // -------转动方块--------\n  cube.rotation.x += 0.02\n  cube.rotation.y += 0.02\n  cube.rotation.z += 0.02\n  // ----------------------\n\n  requestAnimationFrame(render)\n  renderer.render(scene, camera)\n}\n```\n\n就这三行代码就可以了， 让我们看看现在的效果\n\n\n![旋转立方体](http://img.nixiaolei.com/J2oeAVFEnQ.gif)\n\n我们可以看到， 立方体运动行径诡异啊， 但是很cool\n\n\n### 让球动起来\n\n让球动起来也很简单， 但是我们想让他动的稍微炫酷一点， 让他跳来跳去， 这就需要用到一点数学知识了， 利用三角函数我们实现一下球的弹跳\n\n我们在函数外记录了一个 `Step` 用来每次增长， 然后球的`x, y` 就会每次都根据三角函数的曲线规律来造成一高一低的效果， 而且是抛物线\n\n```Js\nvar step = 0;\nfunction render() {\n    stats.update()\n    // 转动方块\n    cube.rotation.x += 0.02\n    cube.rotation.y += 0.02\n    cube.rotation.z += 0.02\n    \n    // --------球体跳跃------------\n    step += 0.04;\n    sphere.position.x = 20 + ( 10 * Math.cos( step ))\n    sphere.position.y = 2 + ( 10 * Math.abs( Math.sin(step) ))\n    // ---------------------------\n\n    requestAnimationFrame(render)\n    renderer.render(scene, camera)\n}\n```\n\n看一下现在的效果图\n![球体运动](http://img.nixiaolei.com/three-ball-action.gif)\n\n\n\n\n\n## 全部代码\n> git地址: https://0x9.me/ohetH\n\n\n\n```html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n    body {\n        margin: 0;\n        overflow: hidden;\n    }\n</style>\n<body>\n    <div id=\"stats-output\"></div>\n</body>\n<script src=\"../three.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script>\n    // 增加统计功能\n    var stats = initStats()\n\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 30\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    // 打开阴影\n    renderer.shadowMapEnabled = true\n\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n\n    plane.receiveShadow = true\n    // 加入场景\n    scene.add(plane)\n\n    // 设置立方体\n    var cubeGeometry = new THREE.CubeGeometry(4, 4, 4)  //设置宽高和段度\n    // 设置基础材质\n    var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000}) // 设置颜色和打开线框\n    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n    // 设置坐标\n    cube.position.x = 4\n    cube.position.y = 3\n    cube.position.z = 0\n    cube.castShadow = true\n\n    // 加入场景\n    scene.add(cube)\n\n    // 设置球面体\n    var sphereGemometry = new THREE.SphereGeometry(4, 20, 20)\n    var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\n    var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)\n    sphere.position.x = 20\n    sphere.position.y = 4\n    sphere.position.z = -2\n    sphere.castShadow = true \n    scene.add(sphere)\n\n    /*\n    *\n    *  添加材质和灯光\n    *\n    * */\n\n    // 设置点光源\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    // 设置位置\n    spotLight.position.set(-40, 60, -10)\n    spotLight.castShadow = true\n    // 添加进点光源\n    scene.add(spotLight)\n\n    \n    \n    /*\n    *\n    * 引入动画\n    *\n    * */\n\n    var step = 0;\n\n    function render() {\n        stats.update()\n        // 转动方块\n        cube.rotation.x += 0.02\n        cube.rotation.y += 0.02\n        cube.rotation.z += 0.02\n        \n        // 球体跳跃\n        step += 0.04;\n        sphere.position.x = 20 + ( 10 * Math.cos( step ))\n        sphere.position.y = 2 + ( 10 * Math.abs( Math.sin(step) ))\n\n        requestAnimationFrame(render)\n        renderer.render(scene, camera)\n    }\n \n\n\n\n\n\n\n\n\n\n    /*\n    *\n    * 输出\n    *\n    * */\n\n    // 初始化统计对象\n\n    function initStats() {\n        var stats = new Stats()\n        stats.setMode(0) // 0 显示fps, 1 检测渲染时间\n        stats.domElement.style.position = 'absolute'\n        stats.domElement.style.left = \"0px\"\n        stats.domElement.style.top = \"0px\"\n        document.getElementById('stats-output').appendChild(stats.domElement)\n        return stats\n    }\n\n\n\n    // 将renderer的输出挂到body\n    document.body.appendChild(renderer.domElement)\n    render()\n\n\n\n</script>\n</html>\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【Three】Three-js入门之添加动画.md","raw":"---\ntitle: 【Three】Three.js入门之添加动画\ndate: 2019-04-03 17:47:05\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n本文基于\"Three.js入门之添加材质和灯光\" 文章之后\n\n\n## 帧率辅助库\n> 在官网下载到的three文件中的 `/examples/js/libs/stats.min.js` 可以找到\n\n这个是一个three 开发者之一写的库， 可以给我提供检测动画流畅度的数据， 引入方式和`three`一样\n\n\n如何使用呢， \n\n### 创建一个dom\n\n我们给他预留一个`dom`\n```html\n<body>\n  <div id=\"stats-output\"></div>\n</body>\n```\n\n### 初始化统计对象\n```Js\n// 初始化统计对象\nfunction initStats() {\n  // 创建实例\n  var stats = new Stats()\n  // 设置模式， 0 显示 fps, 1 检测渲染时间\n  stats.setMode(0) \n  // 样式设置\n  stats.domElement.style.position = 'absolute'\n  stats.domElement.style.left = \"0px\"\n  stats.domElement.style.top = \"0px\"\n  // 加入刚才的dom\n  document.getElementById('stats-output').appendChild(stats.domElement)\n  return stats\n}\n```\n\n### 在每一帧动画期间更新\n因为这里我们的动画使用的是`requestAnimationFrame`, 所以我们在每次调用该方法时， 去更新一下统计对象即可\n\n```Js\nfunction render() {\n  // 更新统计对象\n  stats.update()\n\n  // 主循环\n  requestAnimationFrame(render)\n  // 渲染当前的场景\n  renderer.render(scene, camera)\n}\n```\n\n### 查看一下结果\n这些都做好以后，打开浏览器， 左上角就可以看到我们刚刚创建的统计对象了\n\n![统计对象](http://img.nixiaolei.com/2019-05-03-20-55-25.png)\n\n\n\n## 创建动画\n因为js定时器的种种问题， 计时不准确，  无法预估浏览器算力等等问题， 所以`requestAnimationFrame`\n是我们做动画时的首选， 它可以根据浏览器的具体繁忙情况自动控制帧率\n\n### 创建主循环\n先把之前的最后一步的渲染操作放入`requestAnimationFrame` 这个主循环， \n\n```Js\nfunction render() {\n  stats.update() // 上面👆使用的帧率统计\n  // 回调传入自身\n  requestAnimationFrame(render)\n  renderer.render(scene, camera)\n}\n\n\n // 将renderer的输出挂到body\ndocument.body.appendChild(renderer.domElement)\nrender()\n```\n\n这样，我们的主循环就创建好了， 但是还不够， 如果你刷新浏览器， 你看到的依旧是静止的， 因为你的代码没有任何变化， 所以， 我们就尝试着让他发生一些变化\n\n\n### 让正方体动起来\n我们让正方体旋转起来， 我们在每一帧都修改一下这个正方体的 `x,y,z` 坐标位置\n\n```Js\nfunction render() {\n  stats.update() // 上面👆使用的帧率统计\n\n  // -------转动方块--------\n  cube.rotation.x += 0.02\n  cube.rotation.y += 0.02\n  cube.rotation.z += 0.02\n  // ----------------------\n\n  requestAnimationFrame(render)\n  renderer.render(scene, camera)\n}\n```\n\n就这三行代码就可以了， 让我们看看现在的效果\n\n\n![旋转立方体](http://img.nixiaolei.com/J2oeAVFEnQ.gif)\n\n我们可以看到， 立方体运动行径诡异啊， 但是很cool\n\n\n### 让球动起来\n\n让球动起来也很简单， 但是我们想让他动的稍微炫酷一点， 让他跳来跳去， 这就需要用到一点数学知识了， 利用三角函数我们实现一下球的弹跳\n\n我们在函数外记录了一个 `Step` 用来每次增长， 然后球的`x, y` 就会每次都根据三角函数的曲线规律来造成一高一低的效果， 而且是抛物线\n\n```Js\nvar step = 0;\nfunction render() {\n    stats.update()\n    // 转动方块\n    cube.rotation.x += 0.02\n    cube.rotation.y += 0.02\n    cube.rotation.z += 0.02\n    \n    // --------球体跳跃------------\n    step += 0.04;\n    sphere.position.x = 20 + ( 10 * Math.cos( step ))\n    sphere.position.y = 2 + ( 10 * Math.abs( Math.sin(step) ))\n    // ---------------------------\n\n    requestAnimationFrame(render)\n    renderer.render(scene, camera)\n}\n```\n\n看一下现在的效果图\n![球体运动](http://img.nixiaolei.com/three-ball-action.gif)\n\n\n\n\n\n## 全部代码\n> git地址: https://0x9.me/ohetH\n\n\n\n```html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n    body {\n        margin: 0;\n        overflow: hidden;\n    }\n</style>\n<body>\n    <div id=\"stats-output\"></div>\n</body>\n<script src=\"../three.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script>\n    // 增加统计功能\n    var stats = initStats()\n\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 30\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    // 打开阴影\n    renderer.shadowMapEnabled = true\n\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n\n    plane.receiveShadow = true\n    // 加入场景\n    scene.add(plane)\n\n    // 设置立方体\n    var cubeGeometry = new THREE.CubeGeometry(4, 4, 4)  //设置宽高和段度\n    // 设置基础材质\n    var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000}) // 设置颜色和打开线框\n    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n    // 设置坐标\n    cube.position.x = 4\n    cube.position.y = 3\n    cube.position.z = 0\n    cube.castShadow = true\n\n    // 加入场景\n    scene.add(cube)\n\n    // 设置球面体\n    var sphereGemometry = new THREE.SphereGeometry(4, 20, 20)\n    var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\n    var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)\n    sphere.position.x = 20\n    sphere.position.y = 4\n    sphere.position.z = -2\n    sphere.castShadow = true \n    scene.add(sphere)\n\n    /*\n    *\n    *  添加材质和灯光\n    *\n    * */\n\n    // 设置点光源\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    // 设置位置\n    spotLight.position.set(-40, 60, -10)\n    spotLight.castShadow = true\n    // 添加进点光源\n    scene.add(spotLight)\n\n    \n    \n    /*\n    *\n    * 引入动画\n    *\n    * */\n\n    var step = 0;\n\n    function render() {\n        stats.update()\n        // 转动方块\n        cube.rotation.x += 0.02\n        cube.rotation.y += 0.02\n        cube.rotation.z += 0.02\n        \n        // 球体跳跃\n        step += 0.04;\n        sphere.position.x = 20 + ( 10 * Math.cos( step ))\n        sphere.position.y = 2 + ( 10 * Math.abs( Math.sin(step) ))\n\n        requestAnimationFrame(render)\n        renderer.render(scene, camera)\n    }\n \n\n\n\n\n\n\n\n\n\n    /*\n    *\n    * 输出\n    *\n    * */\n\n    // 初始化统计对象\n\n    function initStats() {\n        var stats = new Stats()\n        stats.setMode(0) // 0 显示fps, 1 检测渲染时间\n        stats.domElement.style.position = 'absolute'\n        stats.domElement.style.left = \"0px\"\n        stats.domElement.style.top = \"0px\"\n        document.getElementById('stats-output').appendChild(stats.domElement)\n        return stats\n    }\n\n\n\n    // 将renderer的输出挂到body\n    document.body.appendChild(renderer.domElement)\n    render()\n\n\n\n</script>\n</html>\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【Three】Three-js入门之添加动画","published":1,"updated":"2019-09-09T16:57:46.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tk0048aas60stvkzgi"},{"title":"【Three】Three.js入门之添加材质和灯光","date":"2019-04-03T09:16:47.000Z","_content":"\n本文基于\"Three.js入门之绘制三维对象\" 文章之后\n\n\n## 材质与光源\n可以对光产生反应的材质\n* MeshLamberMaterial 材质\n* MeshPhongMaterial 材质\n* 加入阴影效果\n\n\n\n\n\n## 添加灯光\n\n```Js\nvar spotLight = new THREE.SpootLight(0xffffff);\n// 设置位置\nspotLight.position.set(-40, 60, -10)\n// 将光源添加进场景\nscene.add(spotLight)\n```\n\n\n\n\n当我们将三维物体的所有材质都替换为`MeshLamberMaterial` 时, 效果如下\n\n\n\n![替换材质后效果](http://img.nixiaolei.com/2019-05-03-17-30-33.png)\n\n\n我们看到这些三维物体上确实都有了些反光的效果\n\n但是， 有反光还不够， 既然有光那肯定要有阴影， 但是绘制阴影是比较耗费性能的，所以`Three.js` 默认不会打开， 但是我们想绘制也是比较容易的\n\n## 给各个物体打开阴影\n\n首先给绘制对象打开阴影设置\n```Js\nrenderer.shadowMapEnabled = true\n```\n\n然后将几个三维对象分别打开\n```Js\n// 打开面的阴影\nplane.receiveShadow = true\n\n//........\n\n// 打开立方体的阴影\ncube.castShadow = true\n\n//........\n\n// 打开球面体的阴影\nsphere.castShadow = true \n```\n\n最后还需要给光源定义一下阴影， 让他可以生成阴影\n\n```Js\nspotLight.castShadow = true\n```\n\n\n## 最终效果\n添加完阴影后，我们刷新一下浏览器， 阴影出来了， 只是有些粗糙\n\n![阴影](http://img.nixiaolei.com/2019-05-03-17-44-10.png)\n\n\n\n## 完整代码\n> git地址: https://0x9.me/ohetH\n\n\n```html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n    body {\n        margin: 0;\n        overflow: hidden;\n    }\n</style>\n<body>\n\n</body>\n<script src=\"../three.js\"></script>\n<script>\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 30\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    // 打开阴影\n    renderer.shadowMapEnabled = true\n\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n\n    plane.receiveShadow = true\n    // 加入场景\n    scene.add(plane)\n\n    // 设置立方体\n    var cubeGeometry = new THREE.CubeGeometry(4, 4, 4)  //设置宽高和段度\n    // 设置基础材质\n    var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000}) // 设置颜色和打开线框\n    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n    // 设置坐标\n    cube.position.x = 4\n    cube.position.y = 3\n    cube.position.z = 0\n    cube.castShadow = true\n\n    // 加入场景\n    scene.add(cube)\n\n    // 设置球面体\n    var sphereGemometry = new THREE.SphereGeometry(4, 20, 20)\n    var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\n    var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)\n    sphere.position.x = 20\n    sphere.position.y = 4\n    sphere.position.z = -2\n    sphere.castShadow = true \n    scene.add(sphere)\n\n    /*\n    *\n    *  添加材质和灯光\n    *\n    * */\n\n    // 设置点光源\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    // 设置位置\n    spotLight.position.set(-40, 60, -10)\n    spotLight.castShadow = true\n    // 添加进点光源\n    scene.add(spotLight)\n\n    \n\n\n\n\n\n\n    /*\n    *\n    * 输出\n    *\n    * */\n\n    // 将renderer的输出挂到body\n    document.body.appendChild(renderer.domElement)\n    renderer.render(scene, camera)\n\n\n\n\n</script>\n</html>\n```\n\n\n","source":"_posts/【Three】Three-js入门之添加材质和灯光.md","raw":"---\ntitle: 【Three】Three.js入门之添加材质和灯光\ndate: 2019-04-03 17:16:47\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n本文基于\"Three.js入门之绘制三维对象\" 文章之后\n\n\n## 材质与光源\n可以对光产生反应的材质\n* MeshLamberMaterial 材质\n* MeshPhongMaterial 材质\n* 加入阴影效果\n\n\n\n\n\n## 添加灯光\n\n```Js\nvar spotLight = new THREE.SpootLight(0xffffff);\n// 设置位置\nspotLight.position.set(-40, 60, -10)\n// 将光源添加进场景\nscene.add(spotLight)\n```\n\n\n\n\n当我们将三维物体的所有材质都替换为`MeshLamberMaterial` 时, 效果如下\n\n\n\n![替换材质后效果](http://img.nixiaolei.com/2019-05-03-17-30-33.png)\n\n\n我们看到这些三维物体上确实都有了些反光的效果\n\n但是， 有反光还不够， 既然有光那肯定要有阴影， 但是绘制阴影是比较耗费性能的，所以`Three.js` 默认不会打开， 但是我们想绘制也是比较容易的\n\n## 给各个物体打开阴影\n\n首先给绘制对象打开阴影设置\n```Js\nrenderer.shadowMapEnabled = true\n```\n\n然后将几个三维对象分别打开\n```Js\n// 打开面的阴影\nplane.receiveShadow = true\n\n//........\n\n// 打开立方体的阴影\ncube.castShadow = true\n\n//........\n\n// 打开球面体的阴影\nsphere.castShadow = true \n```\n\n最后还需要给光源定义一下阴影， 让他可以生成阴影\n\n```Js\nspotLight.castShadow = true\n```\n\n\n## 最终效果\n添加完阴影后，我们刷新一下浏览器， 阴影出来了， 只是有些粗糙\n\n![阴影](http://img.nixiaolei.com/2019-05-03-17-44-10.png)\n\n\n\n## 完整代码\n> git地址: https://0x9.me/ohetH\n\n\n```html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n    body {\n        margin: 0;\n        overflow: hidden;\n    }\n</style>\n<body>\n\n</body>\n<script src=\"../three.js\"></script>\n<script>\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 30\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    // 打开阴影\n    renderer.shadowMapEnabled = true\n\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n\n    plane.receiveShadow = true\n    // 加入场景\n    scene.add(plane)\n\n    // 设置立方体\n    var cubeGeometry = new THREE.CubeGeometry(4, 4, 4)  //设置宽高和段度\n    // 设置基础材质\n    var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000}) // 设置颜色和打开线框\n    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n    // 设置坐标\n    cube.position.x = 4\n    cube.position.y = 3\n    cube.position.z = 0\n    cube.castShadow = true\n\n    // 加入场景\n    scene.add(cube)\n\n    // 设置球面体\n    var sphereGemometry = new THREE.SphereGeometry(4, 20, 20)\n    var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })\n    var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)\n    sphere.position.x = 20\n    sphere.position.y = 4\n    sphere.position.z = -2\n    sphere.castShadow = true \n    scene.add(sphere)\n\n    /*\n    *\n    *  添加材质和灯光\n    *\n    * */\n\n    // 设置点光源\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    // 设置位置\n    spotLight.position.set(-40, 60, -10)\n    spotLight.castShadow = true\n    // 添加进点光源\n    scene.add(spotLight)\n\n    \n\n\n\n\n\n\n    /*\n    *\n    * 输出\n    *\n    * */\n\n    // 将renderer的输出挂到body\n    document.body.appendChild(renderer.domElement)\n    renderer.render(scene, camera)\n\n\n\n\n</script>\n</html>\n```\n\n\n","slug":"【Three】Three-js入门之添加材质和灯光","published":1,"updated":"2019-09-09T16:57:46.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tm004caas6gpjjh4t9"},{"title":"【Three】Three.js入门之绘制三维对象","date":"2019-04-02T01:47:58.000Z","_content":"\n* Plane ( 平面 ) 二维矩形，渲染结果是在屏幕中央有个灰色矩形\n* Cube (方块) 三维立方体。\n* Sphere ( 球体 ) 三维球体。\n* Camera ( 相机 ) 决定视点的位置， 和最终观察结果\n* Axes ( 轴 ) 辅助测试工具\n\n\n\n## 第一步-设置场景\n变量`Scene`是一个容器， 它用来保存并且跟踪我们想渲染的物体\n```Js\nvar scene = new THREE.Scene();\n```\n\n具体内容我们后续会添加到 `scene`中\n\n## 第二步-设置相机\n`camera`用来控制我们所看到的方向角度\n```Js\n// 设置相机                    视角,  宽度/高度,   近距离点,  远距点\nvar camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000)\n// 设置坐标\ncamera.position.x = -30\ncamera.position.y = 40\ncamera.position.z = 30\n// 设置朝向\ncamera.lookAt(scene.position) // 看向场景的中央\n```\n\n\n## 第三步-设置绘制对象\n我们创建一个基于`webgl`的渲染器, 当然还有其他的渲染器( canvas ,svg渲染器等)\n```Js\nvar renderer = new THREE.WebGLRenderer()\n// 设置背景颜色\nrenderer.setClearColor(new THREE.Color(0xeeeeee));\n// 控制渲染尺寸\nrenderer.setSize(window.innerWidth, window.innerHeight)\n```\n\n## 第四步-设置辅助测试工具\n```Js\n// 设置辅助测试工具\nvar axes = new THREE.AxisHelper(20)\nscene.add(axes)\n```\n\n\n## 第五步-创建集合体\n\n### 创建一个平面\n```Js\n  // 设置平面\n  var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n  var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n  var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n  // 设置旋转角度\n  plane.rotation.x = -0.5 * Math.PI;\n  // 设置坐标\n  plane.position.x = 15\n  plane.position.y = 0\n  plane.position.z = 0\n  // 加入场景\n  scene.add(plane)\n```\n\n\n### 创建一个立方体\n```Js\n// 设置立方体\nvar cubeGeometry = new THREE.CubeGeometry(4, 4, 4)  //设置宽高和段度\n// 设置基础材质\nvar cubeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true}) // 设置颜色和打开线框\nvar cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n// 设置坐标\ncube.position.x = 4\ncube.position.y = 3\ncube.position.z = 0\n// 加入场景\nscene.add(cube)\n```\n\n\n### 创建一个球体\n```Js\n// 设置球面体\nvar sphereGemometry = new THREE.SphereGeometry(4, 20, 20)\nvar sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x7777ff, wireframe: true })\nvar sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)\nsphere.position.x = 20\nsphere.position.y = 4\nsphere.position.z = -2\nscene.add(sphere)\n```\n\n\n## 最后一步-输出到body\n```Js\n// 将renderer的输出挂到body\ndocument.body.appendChild(renderer.domElement)\nrenderer.render(scene, camera)\n```\n\n## 最终效果\n![最终效果](http://img.nixiaolei.com/2019-05-02-12-02-43.png)\n\n\n\n## 完整代码\n> git地址: https://0x9.me/ohetH\n\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n    body {\n        margin: 0;\n        overflow: hidden;\n    }\n</style>\n<body>\n\n</body>\n<script src=\"../three.js\"></script>\n<script>\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 30\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n    // 加入场景\n    scene.add(plane)\n\n    // 设置立方体\n    var cubeGeometry = new THREE.CubeGeometry(4, 4, 4)  //设置宽高和段度\n    // 设置基础材质\n    var cubeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true}) // 设置颜色和打开线框\n    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n    // 设置坐标\n    cube.position.x = 4\n    cube.position.y = 3\n    cube.position.z = 0\n    // 加入场景\n    scene.add(cube)\n\n    // 设置球面体\n    var sphereGemometry = new THREE.SphereGeometry(4, 20, 20)\n    var sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x7777ff, wireframe: true })\n    var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)\n    sphere.position.x = 20\n    sphere.position.y = 4\n    sphere.position.z = -2\n    scene.add(sphere)\n\n    // 将renderer的输出挂到body\n    document.body.appendChild(renderer.domElement)\n    renderer.render(scene, camera)\n\n</script>\n</html>\n```","source":"_posts/【Three】Three-js入门之绘制三维对象.md","raw":"---\ntitle: 【Three】Three.js入门之绘制三维对象\ndate: 2019-04-02 09:47:58\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n* Plane ( 平面 ) 二维矩形，渲染结果是在屏幕中央有个灰色矩形\n* Cube (方块) 三维立方体。\n* Sphere ( 球体 ) 三维球体。\n* Camera ( 相机 ) 决定视点的位置， 和最终观察结果\n* Axes ( 轴 ) 辅助测试工具\n\n\n\n## 第一步-设置场景\n变量`Scene`是一个容器， 它用来保存并且跟踪我们想渲染的物体\n```Js\nvar scene = new THREE.Scene();\n```\n\n具体内容我们后续会添加到 `scene`中\n\n## 第二步-设置相机\n`camera`用来控制我们所看到的方向角度\n```Js\n// 设置相机                    视角,  宽度/高度,   近距离点,  远距点\nvar camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000)\n// 设置坐标\ncamera.position.x = -30\ncamera.position.y = 40\ncamera.position.z = 30\n// 设置朝向\ncamera.lookAt(scene.position) // 看向场景的中央\n```\n\n\n## 第三步-设置绘制对象\n我们创建一个基于`webgl`的渲染器, 当然还有其他的渲染器( canvas ,svg渲染器等)\n```Js\nvar renderer = new THREE.WebGLRenderer()\n// 设置背景颜色\nrenderer.setClearColor(new THREE.Color(0xeeeeee));\n// 控制渲染尺寸\nrenderer.setSize(window.innerWidth, window.innerHeight)\n```\n\n## 第四步-设置辅助测试工具\n```Js\n// 设置辅助测试工具\nvar axes = new THREE.AxisHelper(20)\nscene.add(axes)\n```\n\n\n## 第五步-创建集合体\n\n### 创建一个平面\n```Js\n  // 设置平面\n  var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n  var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n  var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n  // 设置旋转角度\n  plane.rotation.x = -0.5 * Math.PI;\n  // 设置坐标\n  plane.position.x = 15\n  plane.position.y = 0\n  plane.position.z = 0\n  // 加入场景\n  scene.add(plane)\n```\n\n\n### 创建一个立方体\n```Js\n// 设置立方体\nvar cubeGeometry = new THREE.CubeGeometry(4, 4, 4)  //设置宽高和段度\n// 设置基础材质\nvar cubeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true}) // 设置颜色和打开线框\nvar cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n// 设置坐标\ncube.position.x = 4\ncube.position.y = 3\ncube.position.z = 0\n// 加入场景\nscene.add(cube)\n```\n\n\n### 创建一个球体\n```Js\n// 设置球面体\nvar sphereGemometry = new THREE.SphereGeometry(4, 20, 20)\nvar sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x7777ff, wireframe: true })\nvar sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)\nsphere.position.x = 20\nsphere.position.y = 4\nsphere.position.z = -2\nscene.add(sphere)\n```\n\n\n## 最后一步-输出到body\n```Js\n// 将renderer的输出挂到body\ndocument.body.appendChild(renderer.domElement)\nrenderer.render(scene, camera)\n```\n\n## 最终效果\n![最终效果](http://img.nixiaolei.com/2019-05-02-12-02-43.png)\n\n\n\n## 完整代码\n> git地址: https://0x9.me/ohetH\n\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n    body {\n        margin: 0;\n        overflow: hidden;\n    }\n</style>\n<body>\n\n</body>\n<script src=\"../three.js\"></script>\n<script>\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 30\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n    // 加入场景\n    scene.add(plane)\n\n    // 设置立方体\n    var cubeGeometry = new THREE.CubeGeometry(4, 4, 4)  //设置宽高和段度\n    // 设置基础材质\n    var cubeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true}) // 设置颜色和打开线框\n    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n    // 设置坐标\n    cube.position.x = 4\n    cube.position.y = 3\n    cube.position.z = 0\n    // 加入场景\n    scene.add(cube)\n\n    // 设置球面体\n    var sphereGemometry = new THREE.SphereGeometry(4, 20, 20)\n    var sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x7777ff, wireframe: true })\n    var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)\n    sphere.position.x = 20\n    sphere.position.y = 4\n    sphere.position.z = -2\n    scene.add(sphere)\n\n    // 将renderer的输出挂到body\n    document.body.appendChild(renderer.domElement)\n    renderer.render(scene, camera)\n\n</script>\n</html>\n```","slug":"【Three】Three-js入门之绘制三维对象","published":1,"updated":"2019-09-09T16:57:46.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tn004faas6x30sp4ar"},{"title":"【Three】Three.js入门学习笔记","date":"2019-04-02T01:47:55.000Z","_content":"\n\n## 简介\nWebGL是基于OpenGl ES 2.0的Web标准， 可以通过HTML5 Canvas 元素作为Dom接口访问。\n\nWebGl 灵活且复杂。\n\n**Three.js 是一个3D JavaScript 库， Three.js 库可简化 WebGL 开发。**\n\n**Three.js 封装了底层的图形接口， 能够在无需掌握繁冗的图形学知识的情况下， 也能用简单的代码实现三位场景的渲染**\n\n\n\n\n\n## Three.js用途\n\n* 创建三维图形\n* 在三维场景中生成动画\n* 在物体上应用纹理和材质。\n* 从三维建模软件中加载图形\n* 创建基于样条曲线的二维图形\n\n\n\n\n## 其他web3D引擎\n\n插件式:\n* Flash\n* O3D\n* Unity3d\n\n原生:\n* GLGE\n* X3DOM\n* PhiloGL\n* CopperLicht\n\n\n\n## 优势\n* 浏览器原生支持， 不需要安装插件\n* 对操作系统、 浏览器兼容性高， 支持移动平台\n* 基于HTML5/WebGL, 是 Web开发的主流； 开发维护非常活跃\n* 组件及案例丰富， 易于学习掌握； 设计优雅、 灵活， 方便以及增加新的特性\n\n*** \n* 基于 WebGL/OpenGL ES 2.0\n* 使用熟悉的HTML/JavaScript\n* 对底层的WebGl的高级封装\n* 保留底层开发的特性\n* 结构严谨灵活、 易于扩展\n\n\n","source":"_posts/【Three】Three-js入门学习笔记.md","raw":"---\ntitle: 【Three】Three.js入门学习笔记\ndate: 2019-04-02 09:47:55\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n\n## 简介\nWebGL是基于OpenGl ES 2.0的Web标准， 可以通过HTML5 Canvas 元素作为Dom接口访问。\n\nWebGl 灵活且复杂。\n\n**Three.js 是一个3D JavaScript 库， Three.js 库可简化 WebGL 开发。**\n\n**Three.js 封装了底层的图形接口， 能够在无需掌握繁冗的图形学知识的情况下， 也能用简单的代码实现三位场景的渲染**\n\n\n\n\n\n## Three.js用途\n\n* 创建三维图形\n* 在三维场景中生成动画\n* 在物体上应用纹理和材质。\n* 从三维建模软件中加载图形\n* 创建基于样条曲线的二维图形\n\n\n\n\n## 其他web3D引擎\n\n插件式:\n* Flash\n* O3D\n* Unity3d\n\n原生:\n* GLGE\n* X3DOM\n* PhiloGL\n* CopperLicht\n\n\n\n## 优势\n* 浏览器原生支持， 不需要安装插件\n* 对操作系统、 浏览器兼容性高， 支持移动平台\n* 基于HTML5/WebGL, 是 Web开发的主流； 开发维护非常活跃\n* 组件及案例丰富， 易于学习掌握； 设计优雅、 灵活， 方便以及增加新的特性\n\n*** \n* 基于 WebGL/OpenGL ES 2.0\n* 使用熟悉的HTML/JavaScript\n* 对底层的WebGl的高级封装\n* 保留底层开发的特性\n* 结构严谨灵活、 易于扩展\n\n\n","slug":"【Three】Three-js入门学习笔记","published":1,"updated":"2019-09-09T16:57:46.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tq004jaas6hev0fztx"},{"title":"【canvas】如何处理Retina屏模糊问题","date":"2019-05-21T14:28:40.000Z","_content":"\n\n## 什么是Retina屏？\n所谓“Retina”是一种显示标准，是把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。由摩托罗拉公司研发。最初该技术是用于Moto Aura上。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。也被称为视网膜显示屏。\n\n\n## canvas在Retina 屏幕模糊怎么办\n> DPI（Dots Per Inch，每英寸点数）是一个量度单位，用于点阵数码影像，指每一英寸长度中，取样、可显示或输出点的数目。\n\n利用获取设备的dpi, 将canvas 画布扩大至dpi的倍数， 然后将其缩小， 就可以得到清晰的canvas 效果\n\n\n\n\n\n\n\n\n\n","source":"_posts/【canvas】如何处理Retina屏模糊问题.md","raw":"---\ntitle: 【canvas】如何处理Retina屏模糊问题\ndate: 2019-05-21 22:28:40\ncategories: Canvas\ntags: Canvas\n---\n\n\n## 什么是Retina屏？\n所谓“Retina”是一种显示标准，是把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。由摩托罗拉公司研发。最初该技术是用于Moto Aura上。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。也被称为视网膜显示屏。\n\n\n## canvas在Retina 屏幕模糊怎么办\n> DPI（Dots Per Inch，每英寸点数）是一个量度单位，用于点阵数码影像，指每一英寸长度中，取样、可显示或输出点的数目。\n\n利用获取设备的dpi, 将canvas 画布扩大至dpi的倍数， 然后将其缩小， 就可以得到清晰的canvas 效果\n\n\n\n\n\n\n\n\n\n","slug":"【canvas】如何处理Retina屏模糊问题","published":1,"updated":"2019-09-09T16:57:46.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tr004kaas6d0fzuyai"},{"title":"【css-doodle】 css web-component入门","date":"2019-03-16T12:36:22.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n首先祭出 css-doodle的官网， 真的老厉害了， 使用它能够轻松的实现各种炫酷特效\n> https://css-doodle.com/\n\n\n`<css-doodle />`基于 Shadow DOM v1和 Custom Elements v1。您可以立即在最新的Chrome，Safari和Firefox上使用它，而无需使用polyfill。\n该组件将根据其中的规则（纯CSS）生成div网格。您可以使用CSS轻松操作这些单元格，以获得图形模式或动画图形。限制是CSS本身的限制。\n\n\n\n既然它这么牛逼， 那怎么用呢？\n\n我们一起来搭几个demo\n\n## css-doodle入门\n> 此处用到的语法或api有不了解的 请看页面下方的“释义” 区域\n\n动手过程中需要注意， 不要在`css-doodle`内部写注释， 会导致样式无效\n\n\n首先搭建好运行`css-doodle`的环境\n```HTML\n<!-- 引入CDN -->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.5.1/css-doodle.min.js\"></script>\n\n<!-- 页面上加入 css-doodle -->\n\n<css-doodle>\n<!-- 我们将在这里写代码 -->\n</css-doodle>\n```\n\n此时如果我们打开页面， 你会发现是空空如也的， 因为这个元素既没有宽高也没有背景颜色， 我们当然看不到。\n\n现在我们给他加点料。\n\n```HTML\n<css-doodle>\n  width: 100px;\n  height: 100px;\n  background: red;\n</css-doodle>\n```\n\n此时我们再看看页面， 就出现了一个`100 x 100`的红色小方块，\n\n![红色方块](http://img.nixiaolei.com/2019-03-16-21-22-36.png)\n\n\n好，这个相当于hello world 级别的练习就完成了， \n\n\n我们再来点难的：\n\n**我想要一个10 x 10 个的小方块组成的大正方形!**\n\n正好我们可以借此尝试使用一下它提供的API\n\n\n```\n<css-doodle>\n  :doodle {\n    @grid: 10x10 / 500px;\n  }\n  background: #60569e;\n</css-doodle>\n```\n\n出现了！ 我们要的 10 x 10 个小方块组成的大正方， 并且还把颜色换成了骚骚的紫色\n\n\n![10x10的大正方](http://img.nixiaolei.com/2019-03-16-21-28-29.png)\n\n\n好既然实现了， 那现在需求升级了\n\n**那我要10个长方形怎么办， 并且我还要长短不一的！**\n\n我去，还要长短不一， 咋整呢\n\n别慌\n\n机制的你一定可以在官网找到有一个获取当前小方块顺序的的参数 \n`@index` 严格的来说他会返回当前单元格的索引值\n\n既然有方法了那我们也有思路了， 二话不说开始动手。\n\n```HTML\n<!-- 首先把 10 x 10 小方块变为10个长方形 -->\n<!-- 然后根据 @index 获取当前单元格的索引 -->\n<css-doodle>\n  :doodle {\n    @grid: 1x10 / 61.8vmin;\n  }\n  background: #60569e;\n  @size: calc(@index() * 1vmin);\n</css-doodle>\n<!-- 根据 index 这个索引值乘以高度 -->\n```\n\nduang!\n\n这就是我们想要的结果了， 虽然还有点不完美， 其实每个紫色都是一个正方形， 但所在的单元格是长方形没跑了\n\n\n![10个长方形](http://img.nixiaolei.com/2019-03-16-21-45-14.png)\n\n\n我们再给他加上`border-radius: 50%;` 它就变成10个球了\n\n\n![10个球](http://img.nixiaolei.com/2019-03-16-21-50-12.png)\n\n\n此时需求又来了\n\n**甲方：可不可以弄10个光环？还是渐变的那种?**\n\n行吧， 试试喽谁怕谁\n\n我们可以举一反三， 利用`@index`这个好东西来修改`hsla`产生不同的颜色， 当然修改`rgba` 也是可以的\n\n```\n<!-- 根据index 每个的单元格递增20的色调， 再调整出不同的透明度 -->\n<css-doodle>\n  :doodle {\n    @grid: 1x10 / 61.8vmin;\n  }\n  border-color: hsla(\n    calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8)\n  );\n  @size: calc(@index() * 10%);\n  border-style: dashed;\n  border-radius: 50%;\n</css-doodle>\n```\n\n好， 甲方爸爸， 你的需求我做到了\n\n\n\n![渐变光环](http://img.nixiaolei.com/2019-03-16-22-11-38.png)\n\n\n**甲方: 还不够，我要的是同心圆**\n\n我。。。。。\n\n得嘞，您说是啥就是啥\n\n同心圆， 你第一反应想到的是不是使用`position: absolute;` ? \n不 ，那太low 了\n我们只需要 `@place-cell: center;` 这个参数就搞定了， 它会将每个单元格都摆放至中间\n\n```HTML\n<css-doodle>\n  :doodle {\n    @grid: 1x10 / 61.8vmin;\n  }\n\n  @place-cell: center;\n  <!-- ...省略之前的代码 -->\n</css-doodle>\n```\n然后去看一下效果， 卧槽\n\n![我把背景色调成深色方便大家观看](http://img.nixiaolei.com/2019-03-16-22-20-13.png)\n\n\n\n### 进阶\n基础学的差不多了， 其他的一些api有了上面的参照都应该思路了吧\n\n既然是进阶篇， 我们就做点难的， 我们看看能不能利用这些特性和 CSS动画结合一下\n\n我们先让光环变粗一点， 让他呈现扇叶的形状\n\n```\nborder-width: calc(@index() * 10px);\n```\n\n\n然后让我们用上 `keyframes` ， 为他添加动画\n\n为每个单元格注册几个css变量（css的新特性），  \n\n* 变量`--speed`控制动画的持续时间，也就是速度。\n* `--start` 控制当前光环的起始角度\n* `--direction`: 控制方向， 因为`turn`表示一圈， 所以 `1turn` 就是正的转一圈,`-1turn` 就是反着转一圈， 利用`@pick`方法来随机取一个值\n\n\n\n\n```HTML\n<css-doodle>\n  <!-- ...省略之前的代码 -->\n\n  <!-- 动画执行时间在20秒 - 40秒之间取值-->\n  --speed: @rand(20s, 40s);\n  <!-- 360度里取随机数 -->\n  --start: @rand(360deg);\n  <!-- 顺时针 或 逆时针 -->\n  --direction: calc(var(--start) + @pick(1turn, -1turn));\n\n  animation: demo var(--speed) linear infinite;\n\n  @keyframes demo {\n    form {\n      <!-- 填入起始角度 -->\n      transform: rotate(var(--start));\n    }\n    to {\n      <!-- 随机顺时针和逆时针旋转 -->\n      transform: rotate(var(--direction));\n    }\n  }\n</css-doodle>\n```\n\n看看效果\n\n\n![随机旋转效果](http://img.nixiaolei.com/KUXh4tYGe4.gif)\n\n\n炫酷不？\n\n能不能再酷一点？\n\n可以， 我们再给他添一笔， \n\n给他加上一个自定义的贝塞尔\n\n贝塞尔可以去这个网站，根据需要生成\n> http://cubic-bezier.com/#1,.25,.83,.67\n\n\n![贝塞尔](http://img.nixiaolei.com/2019-03-16-23-11-46.png)\n\n\n\n然后我们你所需要的贝塞尔去更改`animation` 的参数\n```HTML\nanimation: demo var(--speed) cubic-bezier(0,.88,.42,.99)  infinite;\n```\n\n根据贝塞尔曲线完成了加速减速的动画效果\n\n\n![添加了贝塞尔曲线的动画](http://img.nixiaolei.com/ApPKe0brCf.gif )\n\n\n\n😎cool~\n\n还有更多更酷的特效等着大家去探索~\n\n\n\n\n**切记`css-doodle` 中不能写注释，大家拷贝的时候记得删掉**\n\n## 释义\n* `:doodle` 选择器会创建一个`display: grid;` 的布局\n* `@grid`提供布局， 用法为 `@grid: 行 x 列 /  总宽高` \n* `@index` 返回当前单元格的索引\n* `hsla` 此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度。\n  * H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360\n  * S：Saturation(饱和度)。取值为：0.0% - 100.0%\n  * L：Lightness(亮度)。取值为：0.0% - 100.0%\n  * A：Alpha透明度。取值0~1之间。\n* `@place-cell` 调整单元格相对于网格放置。\n* `@pick`： 从给定列表中随机选择一个值。\n* `turn`: 转、圈（Turns）。一个圆共1圈 ( 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad )\n  * `1turn` 就是1圈\n\n\n\n\n\n\n## 完整的代码\n```HTML\n<css-doodle>\n  :doodle {\n    @grid: 1x10 / 61.8vmin;\n  }\n  @place-cell: center;\n  border-color: hsla(\n    calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8)\n  );\n  border-width: calc(@index() * 10px);\n  @size: calc(@index() * 10%);\n  border-style: dashed;\n  border-radius: 50%;\n  --speed: @rand(20s, 40s);\n  --start: @rand(360deg);\n  --direction: calc(var(--start) + @pick(1turn, -1turn));\n  animation: demo var(--speed) cubic-bezier(0,.88,.42,.99)  infinite;\n\n  @keyframes demo {\n    form {\n      transform: rotate(var(--start));\n    }\n    to {\n      transform: rotate(var(--direction));\n    }\n  }\n</css-doodle>\n```","source":"_posts/【css-doodle】css-web-component入门.md","raw":"---\ntitle: 【css-doodle】 css web-component入门\ndate: 2019-03-16 20:36:22\ncategories: CSS\ntags: [css, web-component, 特效]\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n首先祭出 css-doodle的官网， 真的老厉害了， 使用它能够轻松的实现各种炫酷特效\n> https://css-doodle.com/\n\n\n`<css-doodle />`基于 Shadow DOM v1和 Custom Elements v1。您可以立即在最新的Chrome，Safari和Firefox上使用它，而无需使用polyfill。\n该组件将根据其中的规则（纯CSS）生成div网格。您可以使用CSS轻松操作这些单元格，以获得图形模式或动画图形。限制是CSS本身的限制。\n\n\n\n既然它这么牛逼， 那怎么用呢？\n\n我们一起来搭几个demo\n\n## css-doodle入门\n> 此处用到的语法或api有不了解的 请看页面下方的“释义” 区域\n\n动手过程中需要注意， 不要在`css-doodle`内部写注释， 会导致样式无效\n\n\n首先搭建好运行`css-doodle`的环境\n```HTML\n<!-- 引入CDN -->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.5.1/css-doodle.min.js\"></script>\n\n<!-- 页面上加入 css-doodle -->\n\n<css-doodle>\n<!-- 我们将在这里写代码 -->\n</css-doodle>\n```\n\n此时如果我们打开页面， 你会发现是空空如也的， 因为这个元素既没有宽高也没有背景颜色， 我们当然看不到。\n\n现在我们给他加点料。\n\n```HTML\n<css-doodle>\n  width: 100px;\n  height: 100px;\n  background: red;\n</css-doodle>\n```\n\n此时我们再看看页面， 就出现了一个`100 x 100`的红色小方块，\n\n![红色方块](http://img.nixiaolei.com/2019-03-16-21-22-36.png)\n\n\n好，这个相当于hello world 级别的练习就完成了， \n\n\n我们再来点难的：\n\n**我想要一个10 x 10 个的小方块组成的大正方形!**\n\n正好我们可以借此尝试使用一下它提供的API\n\n\n```\n<css-doodle>\n  :doodle {\n    @grid: 10x10 / 500px;\n  }\n  background: #60569e;\n</css-doodle>\n```\n\n出现了！ 我们要的 10 x 10 个小方块组成的大正方， 并且还把颜色换成了骚骚的紫色\n\n\n![10x10的大正方](http://img.nixiaolei.com/2019-03-16-21-28-29.png)\n\n\n好既然实现了， 那现在需求升级了\n\n**那我要10个长方形怎么办， 并且我还要长短不一的！**\n\n我去，还要长短不一， 咋整呢\n\n别慌\n\n机制的你一定可以在官网找到有一个获取当前小方块顺序的的参数 \n`@index` 严格的来说他会返回当前单元格的索引值\n\n既然有方法了那我们也有思路了， 二话不说开始动手。\n\n```HTML\n<!-- 首先把 10 x 10 小方块变为10个长方形 -->\n<!-- 然后根据 @index 获取当前单元格的索引 -->\n<css-doodle>\n  :doodle {\n    @grid: 1x10 / 61.8vmin;\n  }\n  background: #60569e;\n  @size: calc(@index() * 1vmin);\n</css-doodle>\n<!-- 根据 index 这个索引值乘以高度 -->\n```\n\nduang!\n\n这就是我们想要的结果了， 虽然还有点不完美， 其实每个紫色都是一个正方形， 但所在的单元格是长方形没跑了\n\n\n![10个长方形](http://img.nixiaolei.com/2019-03-16-21-45-14.png)\n\n\n我们再给他加上`border-radius: 50%;` 它就变成10个球了\n\n\n![10个球](http://img.nixiaolei.com/2019-03-16-21-50-12.png)\n\n\n此时需求又来了\n\n**甲方：可不可以弄10个光环？还是渐变的那种?**\n\n行吧， 试试喽谁怕谁\n\n我们可以举一反三， 利用`@index`这个好东西来修改`hsla`产生不同的颜色， 当然修改`rgba` 也是可以的\n\n```\n<!-- 根据index 每个的单元格递增20的色调， 再调整出不同的透明度 -->\n<css-doodle>\n  :doodle {\n    @grid: 1x10 / 61.8vmin;\n  }\n  border-color: hsla(\n    calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8)\n  );\n  @size: calc(@index() * 10%);\n  border-style: dashed;\n  border-radius: 50%;\n</css-doodle>\n```\n\n好， 甲方爸爸， 你的需求我做到了\n\n\n\n![渐变光环](http://img.nixiaolei.com/2019-03-16-22-11-38.png)\n\n\n**甲方: 还不够，我要的是同心圆**\n\n我。。。。。\n\n得嘞，您说是啥就是啥\n\n同心圆， 你第一反应想到的是不是使用`position: absolute;` ? \n不 ，那太low 了\n我们只需要 `@place-cell: center;` 这个参数就搞定了， 它会将每个单元格都摆放至中间\n\n```HTML\n<css-doodle>\n  :doodle {\n    @grid: 1x10 / 61.8vmin;\n  }\n\n  @place-cell: center;\n  <!-- ...省略之前的代码 -->\n</css-doodle>\n```\n然后去看一下效果， 卧槽\n\n![我把背景色调成深色方便大家观看](http://img.nixiaolei.com/2019-03-16-22-20-13.png)\n\n\n\n### 进阶\n基础学的差不多了， 其他的一些api有了上面的参照都应该思路了吧\n\n既然是进阶篇， 我们就做点难的， 我们看看能不能利用这些特性和 CSS动画结合一下\n\n我们先让光环变粗一点， 让他呈现扇叶的形状\n\n```\nborder-width: calc(@index() * 10px);\n```\n\n\n然后让我们用上 `keyframes` ， 为他添加动画\n\n为每个单元格注册几个css变量（css的新特性），  \n\n* 变量`--speed`控制动画的持续时间，也就是速度。\n* `--start` 控制当前光环的起始角度\n* `--direction`: 控制方向， 因为`turn`表示一圈， 所以 `1turn` 就是正的转一圈,`-1turn` 就是反着转一圈， 利用`@pick`方法来随机取一个值\n\n\n\n\n```HTML\n<css-doodle>\n  <!-- ...省略之前的代码 -->\n\n  <!-- 动画执行时间在20秒 - 40秒之间取值-->\n  --speed: @rand(20s, 40s);\n  <!-- 360度里取随机数 -->\n  --start: @rand(360deg);\n  <!-- 顺时针 或 逆时针 -->\n  --direction: calc(var(--start) + @pick(1turn, -1turn));\n\n  animation: demo var(--speed) linear infinite;\n\n  @keyframes demo {\n    form {\n      <!-- 填入起始角度 -->\n      transform: rotate(var(--start));\n    }\n    to {\n      <!-- 随机顺时针和逆时针旋转 -->\n      transform: rotate(var(--direction));\n    }\n  }\n</css-doodle>\n```\n\n看看效果\n\n\n![随机旋转效果](http://img.nixiaolei.com/KUXh4tYGe4.gif)\n\n\n炫酷不？\n\n能不能再酷一点？\n\n可以， 我们再给他添一笔， \n\n给他加上一个自定义的贝塞尔\n\n贝塞尔可以去这个网站，根据需要生成\n> http://cubic-bezier.com/#1,.25,.83,.67\n\n\n![贝塞尔](http://img.nixiaolei.com/2019-03-16-23-11-46.png)\n\n\n\n然后我们你所需要的贝塞尔去更改`animation` 的参数\n```HTML\nanimation: demo var(--speed) cubic-bezier(0,.88,.42,.99)  infinite;\n```\n\n根据贝塞尔曲线完成了加速减速的动画效果\n\n\n![添加了贝塞尔曲线的动画](http://img.nixiaolei.com/ApPKe0brCf.gif )\n\n\n\n😎cool~\n\n还有更多更酷的特效等着大家去探索~\n\n\n\n\n**切记`css-doodle` 中不能写注释，大家拷贝的时候记得删掉**\n\n## 释义\n* `:doodle` 选择器会创建一个`display: grid;` 的布局\n* `@grid`提供布局， 用法为 `@grid: 行 x 列 /  总宽高` \n* `@index` 返回当前单元格的索引\n* `hsla` 此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度。\n  * H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360\n  * S：Saturation(饱和度)。取值为：0.0% - 100.0%\n  * L：Lightness(亮度)。取值为：0.0% - 100.0%\n  * A：Alpha透明度。取值0~1之间。\n* `@place-cell` 调整单元格相对于网格放置。\n* `@pick`： 从给定列表中随机选择一个值。\n* `turn`: 转、圈（Turns）。一个圆共1圈 ( 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad )\n  * `1turn` 就是1圈\n\n\n\n\n\n\n## 完整的代码\n```HTML\n<css-doodle>\n  :doodle {\n    @grid: 1x10 / 61.8vmin;\n  }\n  @place-cell: center;\n  border-color: hsla(\n    calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8)\n  );\n  border-width: calc(@index() * 10px);\n  @size: calc(@index() * 10%);\n  border-style: dashed;\n  border-radius: 50%;\n  --speed: @rand(20s, 40s);\n  --start: @rand(360deg);\n  --direction: calc(var(--start) + @pick(1turn, -1turn));\n  animation: demo var(--speed) cubic-bezier(0,.88,.42,.99)  infinite;\n\n  @keyframes demo {\n    form {\n      transform: rotate(var(--start));\n    }\n    to {\n      transform: rotate(var(--direction));\n    }\n  }\n</css-doodle>\n```","slug":"【css-doodle】css-web-component入门","published":1,"updated":"2019-09-09T16:57:46.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tt004paas6oqi1vgb2"},{"title":"【imooc】HTML5&CSS3","date":"2019-04-10T14:40:47.000Z","_content":"\n\n\n\n# HTML5 + CSS3\n\n## 语义化标签\n\n| 标签名 |   作用   |\n| :----: | :------: |\n|  nav   | 导航 |\n|header|页眉|\n|footer|文档或者页的页脚|\n|main|主要内容|\n|article|文章或热点区|\n|aside|主题内容之外|\n\n## 语义化标签的兼容性\n\n\n\n* IE9: 行级元素在设置宽度的时候失效, 解决方法: display : block\n* IE8: 完全不支持语义标签( 不支持html5 )  ,解决方法: `document.createElement('header')` 或引入第三方插件 ` html5shiv`\n\n\n\n## form 新增的属性\n\n* autofocus 浏览器打开自动获得焦点\n* autocomplete=\"on\"   表单内容自动完成,前提: 必须成功提交过  , 该标签必须有name 属性\n* required 必须输入\n* pattern=\" \"    正则表达式验证\n* multiple  对于file 标签使用,  同时选择多个文件, 对于email 标签使用, 可以同时输入多个邮箱\n* form=\"表单form 的 id \"  可以让在form 表单外部的 表单数据也参与提交\n* oninvalid 当验证不通过时触发的事件\n* this.setCustomValidity(\" 请输入合法的手机号 \")     这个js api 可以修改默认的h5表单 提示内容\n* `dom.dataset[ \"myTest\" ]`  获取自定义的data-my-Test的值 ,获取时要变成驼峰命名\n\n## form 新增的元素\n* datalist   可以输入的下拉列表 (   firfox 中不支持 )   需要通过  list=\"datalist的id\" 建立联系\n\t* \t如果 input 的type 类型是url ,那么value值必须添加 http://  ,因为不加的话识别为不合法\n```\n    <!-- 建立关联   list=\"datalist的id\" -->\n    <input type=\"text\" list=\"dt\">\n    <datalist id=\"dt\">\n        <option value=\"哈哈\" label=\"10人\">哈哈哈</option>\n        <option value=\"前端牛逼\" label=\"18人\">前端牛逼</option>\n    </datalist>\n```\n\n*  keygen标签       h5 提供的加密  , 部分浏览器不支持 , 将表单信息进的是非对称加密,\n  * 生成公钥和私钥,   提交数据的时候  信息+私钥 => 二次加密   然后发送给服务器,  服务器用接收到的 公钥进行解密数据\n*  output  显示输出信息, 只能显示不能修改\n  * 语义性更强\n  * 值需要你去设置, 不能自动计算\n\n## 多媒体标签\n* embed  直接插入视频文件， 它的本质是调用本机上已经安装的软件  有兼容性\n\n* flash插件   安装flash   1.学习flash,增加使用成本    2.苹果设备不支持flash\n\n* audio 音频 \n\n  *   src : 播放音频文件的路径\n  * controls: 音频播放器的控制面板\n  *  autoplay: 自动播放\n  * loop: 循环\n\n* video 视频 \n  *   src : 播放音频文件的路径\n\n  * controls: 音频播放器的控制面板\n\n  *  autoplay: 自动播放\n\n  * loop: 循环\n\n  *  width:宽度 \n\n  * height:高度\n\n  *  poster: 当视频还没完全下载，  或者用户还没点击播放前的默认显示的封面， 默认是显示当前视频文件的第一帧\n\n  * 设置宽高的时候，一般情况下只会设置宽度或者高度 让其自动等比缩放， 如果同时设置宽度和高度，那么视频不会真正的调整到设置的高度，除非设置刚好等比例\n\n  * 多个source 让浏览器自动选择支持的视频格式 先看第一个支不支持再看第二个 \n\n  * ```\n     <video  autoplay controls width=\"600px\">\n            <!-- 多个source 让浏览器自动选择支持的视频格式 先看第一个支不支持再看第二个 -->\n            <source src=\"http://www.baidu.com\" type=\"video/mp4\">\n            <source src=\"http://wxhboy.com/login/movies/w.mp4\" type=\"video/mp4\">\n                您的浏览器不支持当前的视频播放\n        </video>\n     ```\n\n\n\n## 操作class的API\n\n* `dom.classList.add('bg')` 增加class\n* `obj.classList.remove('bg')`  删除class\n* `obj.classList.toggle('bg')` 切换class  如果存在就删除,如果不存在就增加该class\n* `obj.classList.contains('bg')`  判断是否存在某个class  , 返回布尔型 \n\n\n\n## H5新增的接口 API\n\n* ononline  网络连通时触发这个事件 ，只在window上 \n* onoffline  网络断开时触发事件\n* `element.requestFullscreen` 开启全屏 ，需要加浏览器前缀\n  *  需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o \n* `document.cancelFullScreen` 取消全屏，只能是document对象\n\n  *  需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o \n* `document.fullscreenElement` 取消全屏，只能是document对象\n\n   - 需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o \n* ` var reader = new FileReader()   reader.readAsDataURL(file[0])   `读取文件斌转为base64\n  * 没有返回值,但是它会将读取的结果存储在文件读取对象的result中 \n  * FileReader 提供一个完整的事件模型, 用来捕获读取文件时的状态\n  * onabort: 读取文件中断片时触发\n  * onerror: 读取文件错误时触发\n  * onload: 文件读取成功完成时触发\n           *  onloadend: 读取完成时触发,无论成功还是失败\n         * onloadstart: 开始读取文件时触发\n         * onprogress: 读取文件过程中持续触发\n\n# CSS3 选择器\n\n## 属性选择器\n> 属性时相对于标签而言的\n> 就是根据指定名称的属性的值来查找元素\n\n*  `li[style]` 查找只要拥有 style 属性的标签\n*  `li[class = red ]`  严格匹配  拥有class 样式并且等于某值\n*  `li[class*= red ]`  查找class 中包含 red 的标签\n*  `li[class^= red ]`  查找class 中以red 开头的li标签\n*  `li[class$= red ]`  查找class 中以red 结尾的li标签\n\n## 伪类选择器\n### 兄弟伪类\n* `+` 获取当前元素相邻的满足条件的元素，必须是相邻的\n* `~` 获取当前元素的满足条件的兄弟元素  可以不相邻 ，所有兄弟元素\n\n### 相对于父级选择器\n* `ul> li:first-child` 查找ul下第一个元素，如果第一个不是li 那就不生效\n* `ul> li:last-child`  查找ul下最后一个元素\n* `li:first-of-type`   查找的时候指挥查找满足类型条件的第一个元素，过滤掉其他类型的元素\n* `li:last-of-type`   查找的时候指挥查找满足类型条件的最后一个元素\n* `li:nth-child()` 指定索引位置 nth-child(从1开始的所以||关键字||表达式) /  该方法同样 > 如果第一个不是li 那就不生效\n  * even 偶数\n  * odd  奇数\n* ` li:nth-of-type(even) `    指定类型的 所有偶数 li \n* `li:nth-of-type(-n+5) `    只选择前5个li\n* `li:nth-last-of-type(-n+5) `    只选择最后5个li\n* `li:empty `     选择内容为空的li\n\n## 伪类样式\n* ` h2:target ` 可以为锚点目标元素添加样式，当目标元素被触发为当前锚链接的目标时，调用此伪类样式\n\n## 伪元素\n> 是一个行内元素， 如果想设置宽高需要转换成block|| float || postition\n> 必须添加 content, 哪怕不设置内容， 也要 content:\"\"\n\n* `e::before`\n* `e::after`\n* `e::first-letter`  文本的第一个字母或字(不是词组) \n  * 依靠float 实现首字下沉\n* `e::first-line`   文本第一行  ，  如果第一个字设置了`::first-letter` 这些样式都对它无效\n* `e::selection`  可改变选中文本的样式，只能设置显示的样式，而不能设置内容的大小\n\n## 渐变\n\n>  shape : 渐变的形状\n>\n> ellipse 表示椭圆形（适配当前的形状），circle 表示正圆形 \n>\n> 如果宽 高不一样  默认效果切换到 ellipse\n\n\n\n## 多列布局\n> 固定列数时可以使用\n> 有点类似表格布局\n> 比较适合文字\n\n* 只需再父容器上 加上 `column-count: 3`  想要几列就写几\n* `  column-rule:dashed 3px red;` 设置边框样式，这是虚线边框\n* ` column-gap: 0px;`   设置列与列之间的间距 , 为0时是没有边框的\n* ` column-width: 500px;`  \n  *  取大优先，看看是自动计算的宽度大还是你设置的大\n\n    * 但是会填充整个屏幕 ，意味最终的宽度可能会大于设置的宽度--\n\n    ​        填充满整个屏幕\n\n    * 如果人为设置宽度更小，使用自动计算的宽度\n* `column-span: all;` 使某文字或某元素占满一整行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【imooc】HTML5-CSS3.md","raw":"---\ntitle: 【imooc】HTML5&CSS3\ndate: 2019-04-10 22:40:47\ncategories: HTML\ntags: [HTML, css]\n---\n\n\n\n\n# HTML5 + CSS3\n\n## 语义化标签\n\n| 标签名 |   作用   |\n| :----: | :------: |\n|  nav   | 导航 |\n|header|页眉|\n|footer|文档或者页的页脚|\n|main|主要内容|\n|article|文章或热点区|\n|aside|主题内容之外|\n\n## 语义化标签的兼容性\n\n\n\n* IE9: 行级元素在设置宽度的时候失效, 解决方法: display : block\n* IE8: 完全不支持语义标签( 不支持html5 )  ,解决方法: `document.createElement('header')` 或引入第三方插件 ` html5shiv`\n\n\n\n## form 新增的属性\n\n* autofocus 浏览器打开自动获得焦点\n* autocomplete=\"on\"   表单内容自动完成,前提: 必须成功提交过  , 该标签必须有name 属性\n* required 必须输入\n* pattern=\" \"    正则表达式验证\n* multiple  对于file 标签使用,  同时选择多个文件, 对于email 标签使用, 可以同时输入多个邮箱\n* form=\"表单form 的 id \"  可以让在form 表单外部的 表单数据也参与提交\n* oninvalid 当验证不通过时触发的事件\n* this.setCustomValidity(\" 请输入合法的手机号 \")     这个js api 可以修改默认的h5表单 提示内容\n* `dom.dataset[ \"myTest\" ]`  获取自定义的data-my-Test的值 ,获取时要变成驼峰命名\n\n## form 新增的元素\n* datalist   可以输入的下拉列表 (   firfox 中不支持 )   需要通过  list=\"datalist的id\" 建立联系\n\t* \t如果 input 的type 类型是url ,那么value值必须添加 http://  ,因为不加的话识别为不合法\n```\n    <!-- 建立关联   list=\"datalist的id\" -->\n    <input type=\"text\" list=\"dt\">\n    <datalist id=\"dt\">\n        <option value=\"哈哈\" label=\"10人\">哈哈哈</option>\n        <option value=\"前端牛逼\" label=\"18人\">前端牛逼</option>\n    </datalist>\n```\n\n*  keygen标签       h5 提供的加密  , 部分浏览器不支持 , 将表单信息进的是非对称加密,\n  * 生成公钥和私钥,   提交数据的时候  信息+私钥 => 二次加密   然后发送给服务器,  服务器用接收到的 公钥进行解密数据\n*  output  显示输出信息, 只能显示不能修改\n  * 语义性更强\n  * 值需要你去设置, 不能自动计算\n\n## 多媒体标签\n* embed  直接插入视频文件， 它的本质是调用本机上已经安装的软件  有兼容性\n\n* flash插件   安装flash   1.学习flash,增加使用成本    2.苹果设备不支持flash\n\n* audio 音频 \n\n  *   src : 播放音频文件的路径\n  * controls: 音频播放器的控制面板\n  *  autoplay: 自动播放\n  * loop: 循环\n\n* video 视频 \n  *   src : 播放音频文件的路径\n\n  * controls: 音频播放器的控制面板\n\n  *  autoplay: 自动播放\n\n  * loop: 循环\n\n  *  width:宽度 \n\n  * height:高度\n\n  *  poster: 当视频还没完全下载，  或者用户还没点击播放前的默认显示的封面， 默认是显示当前视频文件的第一帧\n\n  * 设置宽高的时候，一般情况下只会设置宽度或者高度 让其自动等比缩放， 如果同时设置宽度和高度，那么视频不会真正的调整到设置的高度，除非设置刚好等比例\n\n  * 多个source 让浏览器自动选择支持的视频格式 先看第一个支不支持再看第二个 \n\n  * ```\n     <video  autoplay controls width=\"600px\">\n            <!-- 多个source 让浏览器自动选择支持的视频格式 先看第一个支不支持再看第二个 -->\n            <source src=\"http://www.baidu.com\" type=\"video/mp4\">\n            <source src=\"http://wxhboy.com/login/movies/w.mp4\" type=\"video/mp4\">\n                您的浏览器不支持当前的视频播放\n        </video>\n     ```\n\n\n\n## 操作class的API\n\n* `dom.classList.add('bg')` 增加class\n* `obj.classList.remove('bg')`  删除class\n* `obj.classList.toggle('bg')` 切换class  如果存在就删除,如果不存在就增加该class\n* `obj.classList.contains('bg')`  判断是否存在某个class  , 返回布尔型 \n\n\n\n## H5新增的接口 API\n\n* ononline  网络连通时触发这个事件 ，只在window上 \n* onoffline  网络断开时触发事件\n* `element.requestFullscreen` 开启全屏 ，需要加浏览器前缀\n  *  需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o \n* `document.cancelFullScreen` 取消全屏，只能是document对象\n\n  *  需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o \n* `document.fullscreenElement` 取消全屏，只能是document对象\n\n   - 需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o \n* ` var reader = new FileReader()   reader.readAsDataURL(file[0])   `读取文件斌转为base64\n  * 没有返回值,但是它会将读取的结果存储在文件读取对象的result中 \n  * FileReader 提供一个完整的事件模型, 用来捕获读取文件时的状态\n  * onabort: 读取文件中断片时触发\n  * onerror: 读取文件错误时触发\n  * onload: 文件读取成功完成时触发\n           *  onloadend: 读取完成时触发,无论成功还是失败\n         * onloadstart: 开始读取文件时触发\n         * onprogress: 读取文件过程中持续触发\n\n# CSS3 选择器\n\n## 属性选择器\n> 属性时相对于标签而言的\n> 就是根据指定名称的属性的值来查找元素\n\n*  `li[style]` 查找只要拥有 style 属性的标签\n*  `li[class = red ]`  严格匹配  拥有class 样式并且等于某值\n*  `li[class*= red ]`  查找class 中包含 red 的标签\n*  `li[class^= red ]`  查找class 中以red 开头的li标签\n*  `li[class$= red ]`  查找class 中以red 结尾的li标签\n\n## 伪类选择器\n### 兄弟伪类\n* `+` 获取当前元素相邻的满足条件的元素，必须是相邻的\n* `~` 获取当前元素的满足条件的兄弟元素  可以不相邻 ，所有兄弟元素\n\n### 相对于父级选择器\n* `ul> li:first-child` 查找ul下第一个元素，如果第一个不是li 那就不生效\n* `ul> li:last-child`  查找ul下最后一个元素\n* `li:first-of-type`   查找的时候指挥查找满足类型条件的第一个元素，过滤掉其他类型的元素\n* `li:last-of-type`   查找的时候指挥查找满足类型条件的最后一个元素\n* `li:nth-child()` 指定索引位置 nth-child(从1开始的所以||关键字||表达式) /  该方法同样 > 如果第一个不是li 那就不生效\n  * even 偶数\n  * odd  奇数\n* ` li:nth-of-type(even) `    指定类型的 所有偶数 li \n* `li:nth-of-type(-n+5) `    只选择前5个li\n* `li:nth-last-of-type(-n+5) `    只选择最后5个li\n* `li:empty `     选择内容为空的li\n\n## 伪类样式\n* ` h2:target ` 可以为锚点目标元素添加样式，当目标元素被触发为当前锚链接的目标时，调用此伪类样式\n\n## 伪元素\n> 是一个行内元素， 如果想设置宽高需要转换成block|| float || postition\n> 必须添加 content, 哪怕不设置内容， 也要 content:\"\"\n\n* `e::before`\n* `e::after`\n* `e::first-letter`  文本的第一个字母或字(不是词组) \n  * 依靠float 实现首字下沉\n* `e::first-line`   文本第一行  ，  如果第一个字设置了`::first-letter` 这些样式都对它无效\n* `e::selection`  可改变选中文本的样式，只能设置显示的样式，而不能设置内容的大小\n\n## 渐变\n\n>  shape : 渐变的形状\n>\n> ellipse 表示椭圆形（适配当前的形状），circle 表示正圆形 \n>\n> 如果宽 高不一样  默认效果切换到 ellipse\n\n\n\n## 多列布局\n> 固定列数时可以使用\n> 有点类似表格布局\n> 比较适合文字\n\n* 只需再父容器上 加上 `column-count: 3`  想要几列就写几\n* `  column-rule:dashed 3px red;` 设置边框样式，这是虚线边框\n* ` column-gap: 0px;`   设置列与列之间的间距 , 为0时是没有边框的\n* ` column-width: 500px;`  \n  *  取大优先，看看是自动计算的宽度大还是你设置的大\n\n    * 但是会填充整个屏幕 ，意味最终的宽度可能会大于设置的宽度--\n\n    ​        填充满整个屏幕\n\n    * 如果人为设置宽度更小，使用自动计算的宽度\n* `column-span: all;` 使某文字或某元素占满一整行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【imooc】HTML5-CSS3","published":1,"updated":"2019-09-09T16:57:46.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tu004raas65nql53rn"},{"title":"【容器】docker命令手册","date":"2019-03-17T02:33:00.000Z","_content":"\n\n\n**使用`docker` 查看所有命令**\n\n\n## 基本命令\n\n\n| 命令 | 功能 | 示例 |\n| :------:| :------: | :------: |\n| FROM | 声明底包来源 | FROM centos | \n| RUN | 构建命令--只在构建镜像中使用  | RUN yum install wget -y |\n| WORKDIR | docker中必须用此切换目录  | WORKDIR Python-3.7.0 |\n| CMD | 运行命令  | CMD python3 -m http.server |\n| docker build 'dockerfile的路径' | 构建新镜像  |  |\n\n## 进程相关命令\n> 在docker client中使用\n\n| 命令 | 功能 | 示例 |\n| :------:| :------: | :------: |\n| docker ps | 查看进城 | docker ps | \n| docker kill 'id' | 杀死指定容器 | docker kill 123 | \n| docker rename | 容器改名 |  | \n| docker restart  | 重启容器 |  | \n| docker rm  | 移除一个或多个'容器'(停止状态的容器) |  |\n| docker rmi  | 移除一个或多个'镜像' |  |\n\n\n\n\n\n\n\n## python项目配置文件分析\n\n```DockerFile\n# 前两行固定写法~\n# 你的底包来源\nFROM centos\n# 作者(用于上传时使用)\nMAINTAINER nxl <nxl3477@foxmail.com>\n\n# RUN构建命令--只在构建镜像中使用    ( -y 表示全部yes)\nRUN yum install gcc automake autoconf libtool make -y  \n# python 依赖于 zlib\nRUN yum install zlib zlib-devel libffi-devel -y\n# 安装 wget\nRUN yum install wget -y\n# 下载python安装包\nRUN wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz\n# 解压缩\nRUN tar -zxvf Python-3.7.0.tgz\n# 切换目录\nWORKDIR Python-3.7.0\n\n# 编译安装\nRUN ./configure\nRUN ls -al\nRUN make && make install \n\n# CMD 运行命令， 唤起python自带的服务器\nCMD python3 -m http.server\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【容器】docker命令手册.md","raw":"---\ntitle: 【容器】docker命令手册\ndate: 2019-03-17 10:33:00\ncategories: 容器技术\ntags: [Docker, 容器技术]\n---\n\n\n\n**使用`docker` 查看所有命令**\n\n\n## 基本命令\n\n\n| 命令 | 功能 | 示例 |\n| :------:| :------: | :------: |\n| FROM | 声明底包来源 | FROM centos | \n| RUN | 构建命令--只在构建镜像中使用  | RUN yum install wget -y |\n| WORKDIR | docker中必须用此切换目录  | WORKDIR Python-3.7.0 |\n| CMD | 运行命令  | CMD python3 -m http.server |\n| docker build 'dockerfile的路径' | 构建新镜像  |  |\n\n## 进程相关命令\n> 在docker client中使用\n\n| 命令 | 功能 | 示例 |\n| :------:| :------: | :------: |\n| docker ps | 查看进城 | docker ps | \n| docker kill 'id' | 杀死指定容器 | docker kill 123 | \n| docker rename | 容器改名 |  | \n| docker restart  | 重启容器 |  | \n| docker rm  | 移除一个或多个'容器'(停止状态的容器) |  |\n| docker rmi  | 移除一个或多个'镜像' |  |\n\n\n\n\n\n\n\n## python项目配置文件分析\n\n```DockerFile\n# 前两行固定写法~\n# 你的底包来源\nFROM centos\n# 作者(用于上传时使用)\nMAINTAINER nxl <nxl3477@foxmail.com>\n\n# RUN构建命令--只在构建镜像中使用    ( -y 表示全部yes)\nRUN yum install gcc automake autoconf libtool make -y  \n# python 依赖于 zlib\nRUN yum install zlib zlib-devel libffi-devel -y\n# 安装 wget\nRUN yum install wget -y\n# 下载python安装包\nRUN wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz\n# 解压缩\nRUN tar -zxvf Python-3.7.0.tgz\n# 切换目录\nWORKDIR Python-3.7.0\n\n# 编译安装\nRUN ./configure\nRUN ls -al\nRUN make && make install \n\n# CMD 运行命令， 唤起python自带的服务器\nCMD python3 -m http.server\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【容器】docker命令手册","published":1,"updated":"2019-09-09T16:57:46.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tv004vaas68e7g35vv"},{"title":"【win10】解决经常性内存爆满100%","date":"2019-04-10T14:23:47.000Z","_content":"\n\n\n问题解决，killer网卡驱动与ndu网络驱动冲突，导致wfpn与ndnb标签池有内存泄漏。解决方法：管理员运行cmd，然后\n\n```shell\nsc config Ndu start=disabled\n```\n\n\n参考文献:\n* http://bbs.pcbeta.com/forum.php?mod=viewthread&tid=1737577&highlight=\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【win10】解决经常性内存爆满100.md","raw":"---\ntitle: 【win10】解决经常性内存爆满100%\ndate: 2019-04-10 22:23:47\ncategories:\ntags:\n---\n\n\n\n问题解决，killer网卡驱动与ndu网络驱动冲突，导致wfpn与ndnb标签池有内存泄漏。解决方法：管理员运行cmd，然后\n\n```shell\nsc config Ndu start=disabled\n```\n\n\n参考文献:\n* http://bbs.pcbeta.com/forum.php?mod=viewthread&tid=1737577&highlight=\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【win10】解决经常性内存爆满100","published":1,"updated":"2019-09-09T16:57:46.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4tx004waas65id5ms67"},{"title":"HTML和CSS巩固","date":"2019-04-10T14:38:41.000Z","_content":"\n\n\n\n# HTML\n> 如何理解HTML\n> html \"文档\"\n> 描述文档的\"结构\"\n> 有区块和大纲\n* `<base href=\"/\">` 指定基础路径 ,只有所有的链接都是以该路径为基准来进行计算\n* `label` 中 ` for` = 表单项的`id` 可以和表单项关联, 你点击这个`label`就好比点击这个表单项本身 \n* `button tyle=\"reset\">`  初始化表单\n*  jQurey 的  `$(\"form\").serialize()`  的方法可以批量获得表单的属性\n*  了解下html 5的 `内容模型` 分类规则 `https://www.w3.org/TR/html5/text-level-semantics.html#the-a-element`\n* 块级元素不一定能包含块级元素  如: p 中不能包含div  ,强行包裹渲染时浏览器会进行容错模式会以为你写错了, p的开始标签会被当成一个标签,div 还是div ,p 的结束标签又会被当成一个独立的标签\n* 行内元素一般不能包含块级元素 ,  但也有例外, 比如:  a  但在html4中是不合法的,,h5中计算时会将其透明化,也就是说计算合法性时会不考虑 a , 但比如  a>div 这样包裹,还是要取决于 它们外部时什么元素才能决定是否合法\n* a 中同样不能包含  a  强行包裹渲染时会被分离\n\n## html 元素默认样式\n> 默认样式的意义在于, 你可以直接书写代码就会在页面上出现效果,而不是每创建一个元素都要去临时给他 宽高颜色之类的 才会在页面上出现\\\n> 但也会带来一些问题, 有时会导致和我预期想要实现效果截然不同的情况\n> 所以需要适当清除默认样式  叫做 `css Reset`  可以去百度下著名的写法,比如 : 雅虎 YUI  的 css reset 写法 或者是 `Normalize.css` 让默认样式有效化\n\n## 面试题\n* doctype的意义是什么\n  * 让浏览器以标准模式渲染\n  * 让浏览器知道元素的合法性\n* html、xhtml、html5之间的关系\n  * HTML属于SGML\n  * XHTML 属于XML, 是XTML进行xml严格化的结果\n  * HTML5不属于SGML或XML,比XHTML宽松\n* HTML 5 有什么变化\n  * 新的语义化元素\n  * 表单增强\n  * 新的API (离线、音视频、实时通信、本地存储、设备能力  )\n  * 分类和嵌套变更\n* em 和 i 有什么区别\n  * em是语义化的标签, 表强调\n  * i 是纯样式的标签, 表示斜体\n  * HTML5中 i 不推荐使用, 一般用作图标\n* 语义化的意义是什么\n  * 开发者容易理解\n  * 机器容易理解结构  (搜索、读屏软件)   ,比如 大纲算法\n  * 有助于 SEO \n  * semantic microdata  增强语义化   , 详细的需要去百度\n* 哪些元素可以自闭和 ( 就是在该标签内部不能再带其他东西了 )\n  * 表单元素 Input\n  * 图片 img\n  * br hr\n  * meta link\n* HTML 和 DOM 的关系\n  * HTML是 \" 死 \" 的\n  * DOM 由HTML解析而来, 是活的\n  * js 可以维护DOM\n* property 和 attribute 的区别\n  * attribute 是 \"死\" 的  , 是你写在HTML上的属性\n  * property  是 \" 活 \" 的 , 是dom 解析后获得的\n* form的作用有哪些\n  * 直接提交表单\n  * 使用submit / reset 按钮\n  * 便于浏览器保存表单\n  * 第三库可以整体提取值 如: JQuery\n  * 第三方库可以进行表单验证, 比如 angular\n\n\n\n# css\n\n## 基础\n> 全称  Cascading Style Sheet 层叠样式表\n* id选择器 样式的权重优先级最高 class选择器 其次\n* 解析方式, `body div a { }` 这样的一个css 浏览器是先找到a标签,再找到它父级有没有 div ,再去找 body  ,总结就是: 从右往左解析,目的就是加快 浏览器对css 的解析速度,更快确定是哪些元素\n* 伪类和伪元素的区别\n\n## 选择器\n### 选择器分类\n* 元素选择器 a{}\n* 伪元素选择器 ::before{}\n* 类选择器 .link{}\n* 属性选择器 [type = radio] {}\n* 伪类选择器 :hover{}\n* id选择器 #id{}\n* 组合选择器 [type=checkbox] + label{}\n* 否定选择器 :not(.link){}\n* 通用选择器 * {}\n### 选择器权重\n> 必须遵守的是  只要有id 选择器 永远比 class 选择器要大, 并不能通过选择器数量盖过 id 选择器的权重,  官大一级压死人  , class再多  权重 也无法 从 十位 进到 百位, 因为权重不进位\n>\n\n* ID 选择器 #id{}  +100\n* 类  属性  伪类 选择器  +10\n* 元素 伪元素   +1\n* 其他选择器   +0\n* 还有一些需要注意的\n  * !important 优先级最高 ( 不管你出现在哪,不管是谁写的 ,永远最高 )\n  * 元素属性 优先级高  ==> 比ID 选择器还要高  ( 元素属性上写style 比外联和内嵌样式表优先级高 )\n  * 相同权重 后写的生效\n\n## 行高\n* line-hight 会撑起 block 元素, inline 则本身无变化,但实际占用高度会被影响\n* 图片下方会出现空隙的原因 : 因为图片是 按inline 来排版, 参照的是基线 ( base-line ), 而基线和底线又有一定的距离,这个距离视字体大小而定 , 例如当12px时 ,这个距离大约是3px \n\n## css  Hack\n> 在一部分浏览器上生效的写法\n* Hack 即不合法但生效的写法\n* 主要用于区分不同浏览器\n* 缺点: 难理解  难维护 易失效\n* 替代方案: 特性检测\n* 替代方案: 针对性加 class\n\n## 取色方式\n* RGB 方式 (方便,但是人眼对rgb不是很敏感)\n    * #fff\n    * rgb\n    * rgba\n* hsl ( 色相, 饱和度,  亮度) \n    * hsl \n    * hsla( 色相, 饱和度,  亮度, 透明度) \n## 字体\n### 载入自定义字体\n```css\n@font-face{\n    font-family:\"IF\";\n    src: url(\"./IndieFlower.ttf\")\n}\n.test{\n    font-family: IF;\n}\n\n```\n## 面试题\n* css 样式 ( 选择器 ) 的优先级\n  * 计算权重确定\n  * !important\n  * 内联样式\n  * 后写的优先级高\n* 雪碧图的作用\n  * 减少http请求次数 提高加载性能\n  * 有些情况下可以减少图片大小\n* 自定义字体的使用场景\n  * 1.宣传 / 品牌 / Banner等固定文案\n  * 2.字体图标\n* base64 的使用\n  * 减少http请求\n  * 适用于小图片\n  * base64的体积约为原图 4 / 3\n* 伪类和伪元素的区别\n  * 伪类表状态\n  * 伪元素是真的有元素\n  * 前者单冒号, 后者双冒号\n* 如何梅花checkbox\n  * label [ for ] 和 id\n  * 隐藏原生 Input\n  * :checked + label\n\n# postcss \n> npm install  postcss  -g\n> 文件输出命令 \n> postcss  src/aa.css   -o  bb.css \n\n## autoprefixer 自动加前缀\n> npm install  autoprefixer\n\n## psostcss-import 模块化css\n> npm install  postcss-import\n\n## cssnano  压缩css代码\n> npm install  cssnano\n\n##  cssnext    使用浏览器未支持的css\n> npm install  postcss-cssnext\n\n## precss  用预处理的语法写css /循环/变量\n```\nconst autoprefixer = require('autoprefixer')\nconst atImport = require('postcss-import')\nmodule.exports = {\n    plugins: [\n        atImport,\n        autoprefixer(\n            {\n            browsers:['>0%']\n        }\n    )\n    ]\n}\n```\n\n# webpack\n## webpack 打包后js 与 css 分离\n> npm install extract-text-webpack-plugin\n\n\n\n\n\n> ![1528628764809](C:\\Users\\Lei\\AppData\\Local\\Temp\\1528628764809.png)\n\n* loader 配置\n\n![1528628596610](C:\\Users\\Lei\\AppData\\Local\\Temp\\1528628596610.png)\n\n\n\n* 文件输出\n\n  ![1528628686140](C:\\Users\\Lei\\AppData\\Local\\Temp\\1528628686140.png)\n\n\n\n\n\n# css布局\n\n## 面试题\n\n* 实现两栏 ( 三栏 ) 布局\n  * 表格布局\n  * float + margin 布局\n  * inline-block布局\n  * flexbox布局\n* position:absolute / fixed 有什么区别\n  * 前者相对最近的absolute / relative 进行定位\n  * 后者相对屏幕 或 移动端的 viewport 进行定位\n* display:inline-block 的间隙\n  * 原因: 字符间距\n  * 解决: 消灭字符或者消灭间距\n* 如何清楚浮动\n  * 让盒子负责自己的布局\n  * overflow:hidden( auto )\n  * ::after{ clear:both }\n* 如何适配移动端页面\n  * viewport\n  * rem / viewport / media query\n  * 设计上: 隐藏  折行  自适应\n\n\n\n# 浏览器小技巧\n\n* `$0` 获取当前选中的元素DOM\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【imooc】HTML和CSS知识巩固.md","raw":"---\ntitle: HTML和CSS巩固\ndate: 2019-04-10 22:38:41\ncategories: HTML\ntags: [HTML, css]\n---\n\n\n\n\n# HTML\n> 如何理解HTML\n> html \"文档\"\n> 描述文档的\"结构\"\n> 有区块和大纲\n* `<base href=\"/\">` 指定基础路径 ,只有所有的链接都是以该路径为基准来进行计算\n* `label` 中 ` for` = 表单项的`id` 可以和表单项关联, 你点击这个`label`就好比点击这个表单项本身 \n* `button tyle=\"reset\">`  初始化表单\n*  jQurey 的  `$(\"form\").serialize()`  的方法可以批量获得表单的属性\n*  了解下html 5的 `内容模型` 分类规则 `https://www.w3.org/TR/html5/text-level-semantics.html#the-a-element`\n* 块级元素不一定能包含块级元素  如: p 中不能包含div  ,强行包裹渲染时浏览器会进行容错模式会以为你写错了, p的开始标签会被当成一个标签,div 还是div ,p 的结束标签又会被当成一个独立的标签\n* 行内元素一般不能包含块级元素 ,  但也有例外, 比如:  a  但在html4中是不合法的,,h5中计算时会将其透明化,也就是说计算合法性时会不考虑 a , 但比如  a>div 这样包裹,还是要取决于 它们外部时什么元素才能决定是否合法\n* a 中同样不能包含  a  强行包裹渲染时会被分离\n\n## html 元素默认样式\n> 默认样式的意义在于, 你可以直接书写代码就会在页面上出现效果,而不是每创建一个元素都要去临时给他 宽高颜色之类的 才会在页面上出现\\\n> 但也会带来一些问题, 有时会导致和我预期想要实现效果截然不同的情况\n> 所以需要适当清除默认样式  叫做 `css Reset`  可以去百度下著名的写法,比如 : 雅虎 YUI  的 css reset 写法 或者是 `Normalize.css` 让默认样式有效化\n\n## 面试题\n* doctype的意义是什么\n  * 让浏览器以标准模式渲染\n  * 让浏览器知道元素的合法性\n* html、xhtml、html5之间的关系\n  * HTML属于SGML\n  * XHTML 属于XML, 是XTML进行xml严格化的结果\n  * HTML5不属于SGML或XML,比XHTML宽松\n* HTML 5 有什么变化\n  * 新的语义化元素\n  * 表单增强\n  * 新的API (离线、音视频、实时通信、本地存储、设备能力  )\n  * 分类和嵌套变更\n* em 和 i 有什么区别\n  * em是语义化的标签, 表强调\n  * i 是纯样式的标签, 表示斜体\n  * HTML5中 i 不推荐使用, 一般用作图标\n* 语义化的意义是什么\n  * 开发者容易理解\n  * 机器容易理解结构  (搜索、读屏软件)   ,比如 大纲算法\n  * 有助于 SEO \n  * semantic microdata  增强语义化   , 详细的需要去百度\n* 哪些元素可以自闭和 ( 就是在该标签内部不能再带其他东西了 )\n  * 表单元素 Input\n  * 图片 img\n  * br hr\n  * meta link\n* HTML 和 DOM 的关系\n  * HTML是 \" 死 \" 的\n  * DOM 由HTML解析而来, 是活的\n  * js 可以维护DOM\n* property 和 attribute 的区别\n  * attribute 是 \"死\" 的  , 是你写在HTML上的属性\n  * property  是 \" 活 \" 的 , 是dom 解析后获得的\n* form的作用有哪些\n  * 直接提交表单\n  * 使用submit / reset 按钮\n  * 便于浏览器保存表单\n  * 第三库可以整体提取值 如: JQuery\n  * 第三方库可以进行表单验证, 比如 angular\n\n\n\n# css\n\n## 基础\n> 全称  Cascading Style Sheet 层叠样式表\n* id选择器 样式的权重优先级最高 class选择器 其次\n* 解析方式, `body div a { }` 这样的一个css 浏览器是先找到a标签,再找到它父级有没有 div ,再去找 body  ,总结就是: 从右往左解析,目的就是加快 浏览器对css 的解析速度,更快确定是哪些元素\n* 伪类和伪元素的区别\n\n## 选择器\n### 选择器分类\n* 元素选择器 a{}\n* 伪元素选择器 ::before{}\n* 类选择器 .link{}\n* 属性选择器 [type = radio] {}\n* 伪类选择器 :hover{}\n* id选择器 #id{}\n* 组合选择器 [type=checkbox] + label{}\n* 否定选择器 :not(.link){}\n* 通用选择器 * {}\n### 选择器权重\n> 必须遵守的是  只要有id 选择器 永远比 class 选择器要大, 并不能通过选择器数量盖过 id 选择器的权重,  官大一级压死人  , class再多  权重 也无法 从 十位 进到 百位, 因为权重不进位\n>\n\n* ID 选择器 #id{}  +100\n* 类  属性  伪类 选择器  +10\n* 元素 伪元素   +1\n* 其他选择器   +0\n* 还有一些需要注意的\n  * !important 优先级最高 ( 不管你出现在哪,不管是谁写的 ,永远最高 )\n  * 元素属性 优先级高  ==> 比ID 选择器还要高  ( 元素属性上写style 比外联和内嵌样式表优先级高 )\n  * 相同权重 后写的生效\n\n## 行高\n* line-hight 会撑起 block 元素, inline 则本身无变化,但实际占用高度会被影响\n* 图片下方会出现空隙的原因 : 因为图片是 按inline 来排版, 参照的是基线 ( base-line ), 而基线和底线又有一定的距离,这个距离视字体大小而定 , 例如当12px时 ,这个距离大约是3px \n\n## css  Hack\n> 在一部分浏览器上生效的写法\n* Hack 即不合法但生效的写法\n* 主要用于区分不同浏览器\n* 缺点: 难理解  难维护 易失效\n* 替代方案: 特性检测\n* 替代方案: 针对性加 class\n\n## 取色方式\n* RGB 方式 (方便,但是人眼对rgb不是很敏感)\n    * #fff\n    * rgb\n    * rgba\n* hsl ( 色相, 饱和度,  亮度) \n    * hsl \n    * hsla( 色相, 饱和度,  亮度, 透明度) \n## 字体\n### 载入自定义字体\n```css\n@font-face{\n    font-family:\"IF\";\n    src: url(\"./IndieFlower.ttf\")\n}\n.test{\n    font-family: IF;\n}\n\n```\n## 面试题\n* css 样式 ( 选择器 ) 的优先级\n  * 计算权重确定\n  * !important\n  * 内联样式\n  * 后写的优先级高\n* 雪碧图的作用\n  * 减少http请求次数 提高加载性能\n  * 有些情况下可以减少图片大小\n* 自定义字体的使用场景\n  * 1.宣传 / 品牌 / Banner等固定文案\n  * 2.字体图标\n* base64 的使用\n  * 减少http请求\n  * 适用于小图片\n  * base64的体积约为原图 4 / 3\n* 伪类和伪元素的区别\n  * 伪类表状态\n  * 伪元素是真的有元素\n  * 前者单冒号, 后者双冒号\n* 如何梅花checkbox\n  * label [ for ] 和 id\n  * 隐藏原生 Input\n  * :checked + label\n\n# postcss \n> npm install  postcss  -g\n> 文件输出命令 \n> postcss  src/aa.css   -o  bb.css \n\n## autoprefixer 自动加前缀\n> npm install  autoprefixer\n\n## psostcss-import 模块化css\n> npm install  postcss-import\n\n## cssnano  压缩css代码\n> npm install  cssnano\n\n##  cssnext    使用浏览器未支持的css\n> npm install  postcss-cssnext\n\n## precss  用预处理的语法写css /循环/变量\n```\nconst autoprefixer = require('autoprefixer')\nconst atImport = require('postcss-import')\nmodule.exports = {\n    plugins: [\n        atImport,\n        autoprefixer(\n            {\n            browsers:['>0%']\n        }\n    )\n    ]\n}\n```\n\n# webpack\n## webpack 打包后js 与 css 分离\n> npm install extract-text-webpack-plugin\n\n\n\n\n\n> ![1528628764809](C:\\Users\\Lei\\AppData\\Local\\Temp\\1528628764809.png)\n\n* loader 配置\n\n![1528628596610](C:\\Users\\Lei\\AppData\\Local\\Temp\\1528628596610.png)\n\n\n\n* 文件输出\n\n  ![1528628686140](C:\\Users\\Lei\\AppData\\Local\\Temp\\1528628686140.png)\n\n\n\n\n\n# css布局\n\n## 面试题\n\n* 实现两栏 ( 三栏 ) 布局\n  * 表格布局\n  * float + margin 布局\n  * inline-block布局\n  * flexbox布局\n* position:absolute / fixed 有什么区别\n  * 前者相对最近的absolute / relative 进行定位\n  * 后者相对屏幕 或 移动端的 viewport 进行定位\n* display:inline-block 的间隙\n  * 原因: 字符间距\n  * 解决: 消灭字符或者消灭间距\n* 如何清楚浮动\n  * 让盒子负责自己的布局\n  * overflow:hidden( auto )\n  * ::after{ clear:both }\n* 如何适配移动端页面\n  * viewport\n  * rem / viewport / media query\n  * 设计上: 隐藏  折行  自适应\n\n\n\n# 浏览器小技巧\n\n* `$0` 获取当前选中的元素DOM\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【imooc】HTML和CSS知识巩固","published":1,"updated":"2019-09-09T16:57:46.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u10050aas6m1ufc2ij"},{"title":"【容器】Docker入门教程","date":"2019-03-16T10:00:14.000Z","_content":"\n## 1.1 Docker简介\n\n\n* Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。\n* Docker通常用于如下场景：\n  * web应用的自动化打包和发布；\n  * 自动化测试和持续集成、发布；\n  * 在服务型环境中部署和调整数据库或其他的后台应用；\n  * 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。\n\n\n\n## 2.1 Docker vs. VM\n* VM：\n  * 运行在宿主机之上的完整的操作系统\n  * 运行自身操作系统会占用较多的资源\n* Docker：\n  * Docker更加轻量高效\n  * 对系统资源的利用率很高\n  * 比虚拟机技术更为轻便、快捷\n  * 隔离效果不如VM\n\n\n![Docker与VM](http://img.nixiaolei.com/2019-04-06-22-42-11.png)\n\n*** \n总的来说， 虚拟机是在操作系统上又装了一个操作系统，运行操作系统特别消耗资源\n\n而`Docker`是一种类似于隔离的技术， 由`CPU` 和`Linux`内核提供的虚拟化技术， 公用你宿主机上的内核， 在`Docker`中再装了一层`shell`, 并且`Docker`和其他`Docker`之间是可以通过内核相互进行通信的(`Linux`进程之间必须经过内核)\n\n\n## 3.1 镜像与容器\n\nimage是静态的概念， 比如： 你的`exe`文件\n\ncontainer是动态的概念， 比如： 你执行`exe`后的进程\n\n## 4.1 Docker相关概念\n* Docker是CS架构，主要有两个概念：\n* Docker daemon:\n  * 运行在宿主机上\n  * Docker守护进程\n  * 用户通过Docker client(Docker命令)与Docker daemon交互\n* Docker client:\n  * Docker 命令行工具，是用户使用Docker的主要方式\n  * Docker client与Docker daemon通信并将结果返回给用户\n  * Docker client也可以通过socket或者RESTful api访问远程的\n  * Docker daemon\n\n## 4.2 相关概念详解\n\n`Docker`最底层是宿主的操作系统内核， \n\n再上层就是底包， 底包就是存放`bash`以及`bash`所依赖的基本环境， 每个系统都有不一样的底包， 你可以自己去做底包， 也可以到[dockerHub](https://www.docker.com/products/docker-hub)里找\n\n![Docker结构](http://img.nixiaolei.com/2019-04-06-22-56-37.png)\n\n\n在此之上一层一层的往上累加，比如`Node`、`Mysql`啥的, 最后扔到容器里跑, 就像下面这张图， 一层一层的往上叠加，跟码头的集装箱一样\n\n![Docker上层结构](http://img.nixiaolei.com/2019-04-06-23-14-37.png)\n\n\n## 5.1 Dockerfile 脚本\n> 规定了如何创建Image\n\n* Dockerfile 概念\n* Dockerfile 文件格式\n* 构建镜像\n* 镜像标签\n* 修改容器内容\n\n\n![配置文件](http://img.nixiaolei.com/2019-04-07-10-26-12.png)\n\n\n## 6.1 配置文件分析\n\n```DockerFile\n# 前两行固定写法~\n# 你的底包来源\nFROM centos\n# 作者(用于上传时使用)\nMAINTAINER nxl <nxl3477@foxmail.com>\n\n# RUN构建命令--只在构建镜像中使用    ( -y 表示全部yes)\nRUN yum install gcc automake autoconf libtool make -y  \n# python 依赖于 zlib\nRUN yum install zlib zlib-devel libffi-devel -y\n# 安装 wget\nRUN yum install wget -y\n# 下载python安装包\nRUN wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz\n# 解压缩\nRUN tar -zxvf Python-3.7.0.tgz\n# 切换目录\nWORKDIR Python-3.7.0\n\n# 编译安装\nRUN ./configure\nRUN ls -al\nRUN make && make install \n\n# CMD 运行命令， 唤起python自带的服务器\nCMD python3 -m http.server\n```","source":"_posts/【容器】Docker入门教程.md","raw":"---\ntitle: 【容器】Docker入门教程\ndate: 2019-03-16 18:00:14\ncategories: 容器技术\ntags: [Docker, 容器技术]\n---\n\n## 1.1 Docker简介\n\n\n* Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。\n* Docker通常用于如下场景：\n  * web应用的自动化打包和发布；\n  * 自动化测试和持续集成、发布；\n  * 在服务型环境中部署和调整数据库或其他的后台应用；\n  * 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。\n\n\n\n## 2.1 Docker vs. VM\n* VM：\n  * 运行在宿主机之上的完整的操作系统\n  * 运行自身操作系统会占用较多的资源\n* Docker：\n  * Docker更加轻量高效\n  * 对系统资源的利用率很高\n  * 比虚拟机技术更为轻便、快捷\n  * 隔离效果不如VM\n\n\n![Docker与VM](http://img.nixiaolei.com/2019-04-06-22-42-11.png)\n\n*** \n总的来说， 虚拟机是在操作系统上又装了一个操作系统，运行操作系统特别消耗资源\n\n而`Docker`是一种类似于隔离的技术， 由`CPU` 和`Linux`内核提供的虚拟化技术， 公用你宿主机上的内核， 在`Docker`中再装了一层`shell`, 并且`Docker`和其他`Docker`之间是可以通过内核相互进行通信的(`Linux`进程之间必须经过内核)\n\n\n## 3.1 镜像与容器\n\nimage是静态的概念， 比如： 你的`exe`文件\n\ncontainer是动态的概念， 比如： 你执行`exe`后的进程\n\n## 4.1 Docker相关概念\n* Docker是CS架构，主要有两个概念：\n* Docker daemon:\n  * 运行在宿主机上\n  * Docker守护进程\n  * 用户通过Docker client(Docker命令)与Docker daemon交互\n* Docker client:\n  * Docker 命令行工具，是用户使用Docker的主要方式\n  * Docker client与Docker daemon通信并将结果返回给用户\n  * Docker client也可以通过socket或者RESTful api访问远程的\n  * Docker daemon\n\n## 4.2 相关概念详解\n\n`Docker`最底层是宿主的操作系统内核， \n\n再上层就是底包， 底包就是存放`bash`以及`bash`所依赖的基本环境， 每个系统都有不一样的底包， 你可以自己去做底包， 也可以到[dockerHub](https://www.docker.com/products/docker-hub)里找\n\n![Docker结构](http://img.nixiaolei.com/2019-04-06-22-56-37.png)\n\n\n在此之上一层一层的往上累加，比如`Node`、`Mysql`啥的, 最后扔到容器里跑, 就像下面这张图， 一层一层的往上叠加，跟码头的集装箱一样\n\n![Docker上层结构](http://img.nixiaolei.com/2019-04-06-23-14-37.png)\n\n\n## 5.1 Dockerfile 脚本\n> 规定了如何创建Image\n\n* Dockerfile 概念\n* Dockerfile 文件格式\n* 构建镜像\n* 镜像标签\n* 修改容器内容\n\n\n![配置文件](http://img.nixiaolei.com/2019-04-07-10-26-12.png)\n\n\n## 6.1 配置文件分析\n\n```DockerFile\n# 前两行固定写法~\n# 你的底包来源\nFROM centos\n# 作者(用于上传时使用)\nMAINTAINER nxl <nxl3477@foxmail.com>\n\n# RUN构建命令--只在构建镜像中使用    ( -y 表示全部yes)\nRUN yum install gcc automake autoconf libtool make -y  \n# python 依赖于 zlib\nRUN yum install zlib zlib-devel libffi-devel -y\n# 安装 wget\nRUN yum install wget -y\n# 下载python安装包\nRUN wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz\n# 解压缩\nRUN tar -zxvf Python-3.7.0.tgz\n# 切换目录\nWORKDIR Python-3.7.0\n\n# 编译安装\nRUN ./configure\nRUN ls -al\nRUN make && make install \n\n# CMD 运行命令， 唤起python自带的服务器\nCMD python3 -m http.server\n```","slug":"【容器】Docker入门教程","published":1,"updated":"2019-09-09T16:57:46.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u20053aas6n82w4d4g"},{"title":"【工程化】webpack 编译后文件解析","date":"2019-09-15T06:18:51.000Z","_content":"\n\nwebpack 为什么这么神奇？ 为什么能把 es6的模块化，node js 的模块化变成能让浏览器支持的代码？？\n\n让我们看看一个最简单的`bundle`文件， 一探究竟\n\n## 如何实现模块化\n![2019-09-15-14-21-44](http://img.nixiaolei.com/2019-09-15-14-21-44.png)\n\n这是一个简简单单的代码，编译后的一个文件， 实际代码如下\n![2019-09-15-14-23-33](http://img.nixiaolei.com/2019-09-15-14-23-33.png)\n\n\n这也证明了 webpack 不管你干了啥都会往你的代码里赛进这么一坨东西。\n\n好的， 现在让我们把代码折叠起来然后删除没用的注释， 先不管细节，看看他的整体脉络\n![2019-09-15-14-39-09](http://img.nixiaolei.com/2019-09-15-14-39-09.png)\n\n我们可以看到， 这就是我们最最熟悉的IIFE，  原来神秘的webapck 无非也就是做了一件事， 将现在的模块化转变成为上古时代的模块化。\n\n并且一个个模块， 都已以其文件路径作为key , 具体的业务逻辑作为value ,  这里我们就可以清晰的看到， 一个`src/index.js` 的文件路径后面跟着的一个函数 ， 里面就大大的写着 \n\n```js\neval(\"console.log(\\\"你好，webpack\\\")\\n\\n//# sourceURL=webpack:///./src/index.js?\");\n```\n\n这里顺带一嘴， 这里生成的\n```js\n(\\\"你好，webpack\\\")\\n\n```\n这样字符串就是我们当初玩弄 AST 时，看到的 `raw`, 也就是带转译的元数据， 当然， 这里如果不实用整个就无法运行了，对吧\n\n\n#### 为什么是eval\nwebpack 在 development 模式下产出的就是 `eavl` ， 如果是 production 生产环境模式， 是绝对不会有这样的形式代码\n\n生产环境下的产出:\n![2019-09-15-14-59-15](http://img.nixiaolei.com/2019-09-15-14-59-15.png)\n\n那 webapck 为什么会这样选择呢?\n1. 生成`eavl` 方便开发环境下的热更新\n2. 生产环境不使用 `eval` 是因为 eval的性能不高，并且不安全， 容易被人XSS\n\n\n\n\n\n\n","source":"_posts/【工程化】webpack-编译后文件解析.md","raw":"---\ntitle: 【工程化】webpack 编译后文件解析\ndate: 2019-09-15 14:18:51\ncategories: 工程化\ntags:  [webpack, 工程化]\n---\n\n\nwebpack 为什么这么神奇？ 为什么能把 es6的模块化，node js 的模块化变成能让浏览器支持的代码？？\n\n让我们看看一个最简单的`bundle`文件， 一探究竟\n\n## 如何实现模块化\n![2019-09-15-14-21-44](http://img.nixiaolei.com/2019-09-15-14-21-44.png)\n\n这是一个简简单单的代码，编译后的一个文件， 实际代码如下\n![2019-09-15-14-23-33](http://img.nixiaolei.com/2019-09-15-14-23-33.png)\n\n\n这也证明了 webpack 不管你干了啥都会往你的代码里赛进这么一坨东西。\n\n好的， 现在让我们把代码折叠起来然后删除没用的注释， 先不管细节，看看他的整体脉络\n![2019-09-15-14-39-09](http://img.nixiaolei.com/2019-09-15-14-39-09.png)\n\n我们可以看到， 这就是我们最最熟悉的IIFE，  原来神秘的webapck 无非也就是做了一件事， 将现在的模块化转变成为上古时代的模块化。\n\n并且一个个模块， 都已以其文件路径作为key , 具体的业务逻辑作为value ,  这里我们就可以清晰的看到， 一个`src/index.js` 的文件路径后面跟着的一个函数 ， 里面就大大的写着 \n\n```js\neval(\"console.log(\\\"你好，webpack\\\")\\n\\n//# sourceURL=webpack:///./src/index.js?\");\n```\n\n这里顺带一嘴， 这里生成的\n```js\n(\\\"你好，webpack\\\")\\n\n```\n这样字符串就是我们当初玩弄 AST 时，看到的 `raw`, 也就是带转译的元数据， 当然， 这里如果不实用整个就无法运行了，对吧\n\n\n#### 为什么是eval\nwebpack 在 development 模式下产出的就是 `eavl` ， 如果是 production 生产环境模式， 是绝对不会有这样的形式代码\n\n生产环境下的产出:\n![2019-09-15-14-59-15](http://img.nixiaolei.com/2019-09-15-14-59-15.png)\n\n那 webapck 为什么会这样选择呢?\n1. 生成`eavl` 方便开发环境下的热更新\n2. 生产环境不使用 `eval` 是因为 eval的性能不高，并且不安全， 容易被人XSS\n\n\n\n\n\n\n","slug":"【工程化】webpack-编译后文件解析","published":1,"updated":"2019-09-15T07:09:12.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u30058aas6cyq06c0p"},{"title":"【容器】搭建第一个docker环境","date":"2019-03-28T13:01:02.000Z","_content":"\n\n## 初始化一个NodeJs程序\n\n以下操作必须已经安装了了NodeJS。\n首先创建一个空文件夹。并创建以下⽂文件：\n* server.js\n* package.json\n* Dockerfile\n* .dockerignore\n\n```shell\nmkdir docker_demo\ncd docker_demo\ntouch server.js\ntouch package.json\ntouch Dockerfile\ntouch .dockerignore\n```\n\n然后在server.js写⼊入\n\n```JavaScript\nconst Koa = require('koa');\nconst app = new Koa();\napp.use(async ctx => {\n  ctx.body = 'Hello docker';\n});\napp.listen(3000);\n```\n\n在package.json中写入\n\n```Json\n{\n  \"name\": \"docker_demo\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node server.js\"\n  },\n  \"dependencies\": {\n    \"koa\": \"^2.5.0\"\n  }\n}\n```\n\n测试程序。控制台输⼊\n```Shell\nnpm start \n```\n浏览器打开本地测试,如果如图所示。表示demo创建成功。请继续往下。\n\n\n![本地测试](http://img.nixiaolei.com/2019-04-08-21-05-28.png)\n\n\n\n## 创建dockerfile文件\n\nDockerfile是由一系列命令和参数构成的脚本，一个Dockerfile⾥里里⾯面包含了构建整个image的完整命令。Docker通过docker build执行Dockerfile中的一系列列命令自动构建image. 在.dockerignore文件里面写入代码。表示过滤该类型的文件。类似git的.gitignore\n\n```docker\n# Logs\nlogs\n*.log\nnpm-debug.log*\n# Runtime data\npids\n*.pid\n*.seed\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n# Coverage directory used by tools like istanbul\n\ncoverage\n# nyc test coverage\n.nyc_output\n# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n# node-waf configuration\n.lock-wscript\n# Compiled binary addons (http://nodejs.org/api/addons.html)\nbuild/Release\n# Dependency directories\nnode_modules\njspm_packages\n# Optional npm cache directory\n.npm\n# Optional REPL history\n.node_repl_history\n.idea\n.node_modules\nnode_modules\n.vscode\n```\n\n在Dockerfile文件中写入以下代码：\n```docker\n#制定node镜像的版本\nFROM node:8.9-alpine\n#声明作者\nMAINTAINER evilboy\n#移动当前⽬目录下⾯面的⽂文件到app⽬目录下\nADD . /app/\n#进⼊入到app⽬目录下⾯面，类似cd\nWORKDIR /app\n#安装依赖\nRUN npm install\n#对外暴暴露露的端⼝口\nEXPOSE 3000\n#程序启动脚本\nCMD [\"npm\", \"start\"]\n```\n\n\n## 构建镜像\n> 使用build命令构造镜像,注意后⾯面那个“.”不不能少。\n\n```shell\n[root@Sandbox-N ~]# docker build -t docker_demo .\nSending build context to Docker daemon 39.94kB\nStep 1/7 : FROM node:8.9-alpine\n---> 406f227b21f5\nStep 2/7 : MAINTAINER robin\n---> Using cache\n---> 78d6cdbcfee2\nStep 3/7 : ADD . /app/\n---> 2cb30678612d\nStep 4/7 : WORKDIR /app\nRemoving intermediate container e51377081039\n---> c2b7d0f37d2d\nStep 5/7 : RUN npm install\n---> Running in da0c3946ca8d\nnpm notice created a lockfile as package-lock.json. You should commit\nthis file.\nadded 38 packages in 3.323s\nRemoving intermediate container da0c3946ca8d\n---> eecee87f10e2\nStep 6/7 : EXPOSE 3000\n---> Running in f3973cc168a4\nRemoving intermediate container f3973cc168a4\n---> 2671a4c6deb4\nStep 7/7 : CMD [\"npm\", \"start\"]\n---> Running in dec529f754aa\nRemoving intermediate container dec529f754aa\n---> 6ec73793d353\nSuccessfully built 6ec73793d353\nSuccessfully tagged docker_demo:latest\n```\n\n\n等待镜像构造完成。然后使用 images命令查看镜像。\n\n![查看镜像](http://img.nixiaolei.com/2019-04-08-21-08-27.png)\n\n\n此时可以看到images已经构造完成。现在开始启动images，并测试。\n\n```shell\n#启动镜像 -d表示后台执⾏行行，-p 9000:3000表示指定本地的9000端⼝口隐射到容器器内的3000端⼝口，\ndocker_demo为镜像名称\ndocker run -d -p 9000:3000 docker_demo\n#查看容器器\ndocker ps\n```\n\n![查看容器](http://img.nixiaolei.com/2019-04-08-21-09-13.png)\n\n\n此时浏览器打开http://localhost:9000/,如果如图所示。表示容器运行正常。\n\n![正常情况](http://img.nixiaolei.com/2019-04-08-21-10-04.png)\n\n\n\n\n\n如果此时本地无法打开。可以使用log命令查看日志。根据日志修改对应出现的对方。","source":"_posts/【容器】搭建第一个docker环境.md","raw":"---\ntitle: 【容器】搭建第一个docker环境\ndate: 2019-03-28 21:01:02\ncategories: 容器技术\ntags: [Docker, 容器技术]\n---\n\n\n## 初始化一个NodeJs程序\n\n以下操作必须已经安装了了NodeJS。\n首先创建一个空文件夹。并创建以下⽂文件：\n* server.js\n* package.json\n* Dockerfile\n* .dockerignore\n\n```shell\nmkdir docker_demo\ncd docker_demo\ntouch server.js\ntouch package.json\ntouch Dockerfile\ntouch .dockerignore\n```\n\n然后在server.js写⼊入\n\n```JavaScript\nconst Koa = require('koa');\nconst app = new Koa();\napp.use(async ctx => {\n  ctx.body = 'Hello docker';\n});\napp.listen(3000);\n```\n\n在package.json中写入\n\n```Json\n{\n  \"name\": \"docker_demo\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node server.js\"\n  },\n  \"dependencies\": {\n    \"koa\": \"^2.5.0\"\n  }\n}\n```\n\n测试程序。控制台输⼊\n```Shell\nnpm start \n```\n浏览器打开本地测试,如果如图所示。表示demo创建成功。请继续往下。\n\n\n![本地测试](http://img.nixiaolei.com/2019-04-08-21-05-28.png)\n\n\n\n## 创建dockerfile文件\n\nDockerfile是由一系列命令和参数构成的脚本，一个Dockerfile⾥里里⾯面包含了构建整个image的完整命令。Docker通过docker build执行Dockerfile中的一系列列命令自动构建image. 在.dockerignore文件里面写入代码。表示过滤该类型的文件。类似git的.gitignore\n\n```docker\n# Logs\nlogs\n*.log\nnpm-debug.log*\n# Runtime data\npids\n*.pid\n*.seed\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n# Coverage directory used by tools like istanbul\n\ncoverage\n# nyc test coverage\n.nyc_output\n# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n# node-waf configuration\n.lock-wscript\n# Compiled binary addons (http://nodejs.org/api/addons.html)\nbuild/Release\n# Dependency directories\nnode_modules\njspm_packages\n# Optional npm cache directory\n.npm\n# Optional REPL history\n.node_repl_history\n.idea\n.node_modules\nnode_modules\n.vscode\n```\n\n在Dockerfile文件中写入以下代码：\n```docker\n#制定node镜像的版本\nFROM node:8.9-alpine\n#声明作者\nMAINTAINER evilboy\n#移动当前⽬目录下⾯面的⽂文件到app⽬目录下\nADD . /app/\n#进⼊入到app⽬目录下⾯面，类似cd\nWORKDIR /app\n#安装依赖\nRUN npm install\n#对外暴暴露露的端⼝口\nEXPOSE 3000\n#程序启动脚本\nCMD [\"npm\", \"start\"]\n```\n\n\n## 构建镜像\n> 使用build命令构造镜像,注意后⾯面那个“.”不不能少。\n\n```shell\n[root@Sandbox-N ~]# docker build -t docker_demo .\nSending build context to Docker daemon 39.94kB\nStep 1/7 : FROM node:8.9-alpine\n---> 406f227b21f5\nStep 2/7 : MAINTAINER robin\n---> Using cache\n---> 78d6cdbcfee2\nStep 3/7 : ADD . /app/\n---> 2cb30678612d\nStep 4/7 : WORKDIR /app\nRemoving intermediate container e51377081039\n---> c2b7d0f37d2d\nStep 5/7 : RUN npm install\n---> Running in da0c3946ca8d\nnpm notice created a lockfile as package-lock.json. You should commit\nthis file.\nadded 38 packages in 3.323s\nRemoving intermediate container da0c3946ca8d\n---> eecee87f10e2\nStep 6/7 : EXPOSE 3000\n---> Running in f3973cc168a4\nRemoving intermediate container f3973cc168a4\n---> 2671a4c6deb4\nStep 7/7 : CMD [\"npm\", \"start\"]\n---> Running in dec529f754aa\nRemoving intermediate container dec529f754aa\n---> 6ec73793d353\nSuccessfully built 6ec73793d353\nSuccessfully tagged docker_demo:latest\n```\n\n\n等待镜像构造完成。然后使用 images命令查看镜像。\n\n![查看镜像](http://img.nixiaolei.com/2019-04-08-21-08-27.png)\n\n\n此时可以看到images已经构造完成。现在开始启动images，并测试。\n\n```shell\n#启动镜像 -d表示后台执⾏行行，-p 9000:3000表示指定本地的9000端⼝口隐射到容器器内的3000端⼝口，\ndocker_demo为镜像名称\ndocker run -d -p 9000:3000 docker_demo\n#查看容器器\ndocker ps\n```\n\n![查看容器](http://img.nixiaolei.com/2019-04-08-21-09-13.png)\n\n\n此时浏览器打开http://localhost:9000/,如果如图所示。表示容器运行正常。\n\n![正常情况](http://img.nixiaolei.com/2019-04-08-21-10-04.png)\n\n\n\n\n\n如果此时本地无法打开。可以使用log命令查看日志。根据日志修改对应出现的对方。","slug":"【容器】搭建第一个docker环境","published":1,"updated":"2019-09-09T16:57:46.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u4005baas623gvmjnc"},{"title":"【数据结构】什么是树","date":"2019-06-02T14:14:50.000Z","_content":"\n树是由若干个有限节点组成的一个具有层次关系的集合\n\n## 树的特点\n\n* 数学基础是: 图论\n* 一棵树中每两个点之间都有且只有一条路\n* 一颗有N个点的树有N-1条边\n\n## 结构与名称\n![树的结构图](http://img.nixiaolei.com/structure-tree.png)\n\n像图中的圈我们称之为“节点”， 节点与节点之间的线称之为“边”， 最起始的节点叫“根”\n\n一个节点下面的节点成为该节点的子节点， 该节点是其子节点的父节点\n\n节点的层级用“深”来表示， 并且以0开始计数\n\n当节点不再分叉时， 末尾的节点称为“叶子节点”\n\n一个节点的子节点数量称为“度”， 如果一个节点有3个子节点， 那么它的度为3， 当度为0时就是叶子节点\n\n一个节点到另一个节点之间的连线 称为“路径”\n\n\n## 树和非树的典型\n> 空树是指，有了树的结构， 但是还没有填充节点\n\n\n![树和非树](http://img.nixiaolei.com/treeAndNoTree.png)\n\n## 树的遍历\n> 树的遍历分为，两大类， 四小类\n\n按照某种规则， 不重复地访问某种树的所有节点\n\n* 先序遍历(深度优先)\n* 中序遍历(深度优先)\n* 后续遍历(深度优先)\n* 层序遍历(广度优先)\n\n> 先、 中、后都是针对的根节点来说的， 并且树是一种自相似的结构， 可以采用递归， 所以比较好记忆\n\n### 1.先序遍历\n> 左、中、右\n\n优先访问根节点， 然后访问其左子树， 如果左子节点还有其左子节点， 再继续往下访问其左子节点， 直至没有， 然后访问其节点的父节点， 最后访问其父节点的右子节点， 就这样一层一层向上，直至根节点的整个左子树遍历完， 去对右子树做同样的操作\n\n\n\n![先序遍历](http://img.nixiaolei.com/tree-first-order.png)\n\n\n### 2. 中序遍历\n> 中、左、右\n\n优先访问左子树， 然后访问根节点，  最后访问右节点\n\n![中序遍历](http://img.nixiaolei.com/tree-zhong-order.png)\n\n\n\n### 3. 后序遍历\n\n> 左、 右、 中\n\n优先访问左子树、 然后访问右子树， 最后访问根节点\n\n![后序遍历](http://img.nixiaolei.com/tree-after-order.png)\n\n\n### 4. 层序遍历\n广度优先逐层访问节点， 直至该层没有， 然后再往下扎\n\n![层序遍历](http://img.nixiaolei.com/cengxu.png)\n\n\n\n## 树的衍生\n\n无序树: 树中任意节点的子节点之间没有顺序关系， 这种树称为无序树， 也称为自由树\n\n有序树： 树中任意节点的子结点之间有顺序关系\n\n二叉树： 每个节点最多含有两个子树的树称为二叉树\n\n完全二叉树： 除了最后一层， 其他各层节点数都达到最大\n\n满二叉树： 每一层上的节点数都是最大节点数\n\n霍夫曼树： 带权路径最短的二叉树， 也叫最优二叉树\n\n## 排序算法的复杂度与稳定性\n\n![2019-06-09-21-32-43](http://img.nixiaolei.com/2019-06-09-21-32-43.png)\n\n## 关于查找算法\n![2019-06-09-21-36-02](http://img.nixiaolei.com/2019-06-09-21-36-02.png) \n\n\n\n","source":"_posts/【数据结构】什么是树.md","raw":"---\ntitle: 【数据结构】什么是树\ndate: 2019-06-02 22:14:50\ncategories: 数据结构\ntags: 数据结构\n---\n\n树是由若干个有限节点组成的一个具有层次关系的集合\n\n## 树的特点\n\n* 数学基础是: 图论\n* 一棵树中每两个点之间都有且只有一条路\n* 一颗有N个点的树有N-1条边\n\n## 结构与名称\n![树的结构图](http://img.nixiaolei.com/structure-tree.png)\n\n像图中的圈我们称之为“节点”， 节点与节点之间的线称之为“边”， 最起始的节点叫“根”\n\n一个节点下面的节点成为该节点的子节点， 该节点是其子节点的父节点\n\n节点的层级用“深”来表示， 并且以0开始计数\n\n当节点不再分叉时， 末尾的节点称为“叶子节点”\n\n一个节点的子节点数量称为“度”， 如果一个节点有3个子节点， 那么它的度为3， 当度为0时就是叶子节点\n\n一个节点到另一个节点之间的连线 称为“路径”\n\n\n## 树和非树的典型\n> 空树是指，有了树的结构， 但是还没有填充节点\n\n\n![树和非树](http://img.nixiaolei.com/treeAndNoTree.png)\n\n## 树的遍历\n> 树的遍历分为，两大类， 四小类\n\n按照某种规则， 不重复地访问某种树的所有节点\n\n* 先序遍历(深度优先)\n* 中序遍历(深度优先)\n* 后续遍历(深度优先)\n* 层序遍历(广度优先)\n\n> 先、 中、后都是针对的根节点来说的， 并且树是一种自相似的结构， 可以采用递归， 所以比较好记忆\n\n### 1.先序遍历\n> 左、中、右\n\n优先访问根节点， 然后访问其左子树， 如果左子节点还有其左子节点， 再继续往下访问其左子节点， 直至没有， 然后访问其节点的父节点， 最后访问其父节点的右子节点， 就这样一层一层向上，直至根节点的整个左子树遍历完， 去对右子树做同样的操作\n\n\n\n![先序遍历](http://img.nixiaolei.com/tree-first-order.png)\n\n\n### 2. 中序遍历\n> 中、左、右\n\n优先访问左子树， 然后访问根节点，  最后访问右节点\n\n![中序遍历](http://img.nixiaolei.com/tree-zhong-order.png)\n\n\n\n### 3. 后序遍历\n\n> 左、 右、 中\n\n优先访问左子树、 然后访问右子树， 最后访问根节点\n\n![后序遍历](http://img.nixiaolei.com/tree-after-order.png)\n\n\n### 4. 层序遍历\n广度优先逐层访问节点， 直至该层没有， 然后再往下扎\n\n![层序遍历](http://img.nixiaolei.com/cengxu.png)\n\n\n\n## 树的衍生\n\n无序树: 树中任意节点的子节点之间没有顺序关系， 这种树称为无序树， 也称为自由树\n\n有序树： 树中任意节点的子结点之间有顺序关系\n\n二叉树： 每个节点最多含有两个子树的树称为二叉树\n\n完全二叉树： 除了最后一层， 其他各层节点数都达到最大\n\n满二叉树： 每一层上的节点数都是最大节点数\n\n霍夫曼树： 带权路径最短的二叉树， 也叫最优二叉树\n\n## 排序算法的复杂度与稳定性\n\n![2019-06-09-21-32-43](http://img.nixiaolei.com/2019-06-09-21-32-43.png)\n\n## 关于查找算法\n![2019-06-09-21-36-02](http://img.nixiaolei.com/2019-06-09-21-36-02.png) \n\n\n\n","slug":"【数据结构】什么是树","published":1,"updated":"2019-09-09T16:57:46.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u5005gaas6qey7129b"},{"title":"【工程化】babel简单原理及简单实现","date":"2019-09-14T13:36:45.000Z","_content":"\n\n我们知道babel 的原理是通过转换为Ast的方式， 进行一系列的处理， 然后最终得到了我们看到的代码。\n\n这就是它强大之处。\n\n如果让你来实现一个babel 这样的转换代码工具， 你会如何去做呢？\n\n是不是首先会想到使用正则呢， 但实际上， 正则无法很好的满足需求， 这是因为： \n1. 需要针对各个类库编写相关正则\n2. 当类库内部实现改变则正则也要改变\n3. 正则的匹配需要区分注释情况， 有写代码被注释掉如果也被正则匹配了那就会影响实现， 比如`requireJs`就是使用正则匹配的， 导致注释掉相关方法还是调用了\n\n\n综上所诉， 最终我们的解决方案应该是 AST!\n\n如何实现一个简单的babel 呢： \n\n我们需要有将代码转换为 AST 的工具， 处理AST 的工具， AST 转回代码的工具！\n\n让我们来做一个 es6 变量转为es5变量的小工具， 让我们开始动手吧\n\n让我们先 从字符串转为AST：\n\n```js\nconst esprima = require('esprima')\nconst estraverse = require('estraverse')\nconst code = ` const view = {\n    a: 3,\n    init: () => {\n      view.a = 5\n    },\n    render: () => {\n\n    }\n  }\n`\nconst ast = esprima.parse(code)\n```\n\n让我们看看上面构建的这段代码字符串会被转换为什么\n\n\n\n![2019-09-14-22-50-42](http://img.nixiaolei.com/2019-09-14-22-50-42.png)\n\n\n看到了结果， 我们也看到了我们需要的关键字`const` ， 是不是我们只要把它改为var 就可以了呢， 哈哈， 动手试试吧\n\n```js\nconst esprima = require('esprima')\nconst estraverse = require('estraverse')\nconst escodegen = require('escodegen')\n// mock 一段代码\nconst code = ` const view = {\n  a: 3,\n  init: () => {\n    view.a = 5\n  },\n  render: () => {\n\n  }\n}\n`\n// 将代码转为 ast\nconst ast = esprima.parse(code)\nconsole.log(ast)\n// 遍历ast 修改相关操作\nestraverse.traverse(ast, {\n  enter(node) {\n    if( node.type === \"VariableDeclaration\" ) {\n      node.kind = 'var'\n    }\n  }\n})\n// 得到经过ast处理的 js 代码 \nconst reg_code = escodegen.generate(ast)\nconsole.log('--------- 输出结果 ---------------')\nconsole.log(JSON.stringify(reg_code, null,4))\n\n```\n\n\n此时的输出:\n\n![2019-09-14-23-00-49](http://img.nixiaolei.com/2019-09-14-23-00-49.png)\n\n可以看到最下面的字符串， const 被成功替换为了 var ， 完美！\n\n一个最小最简陋的babel 就这么实现了！\n\n\n","source":"_posts/【工程化】babel简单原理及简单实现.md","raw":"---\ntitle: 【工程化】babel简单原理及简单实现\ndate: 2019-09-14 21:36:45\ncategories: 工程化\ntags:  [babel, 工程化, Ast]\n---\n\n\n我们知道babel 的原理是通过转换为Ast的方式， 进行一系列的处理， 然后最终得到了我们看到的代码。\n\n这就是它强大之处。\n\n如果让你来实现一个babel 这样的转换代码工具， 你会如何去做呢？\n\n是不是首先会想到使用正则呢， 但实际上， 正则无法很好的满足需求， 这是因为： \n1. 需要针对各个类库编写相关正则\n2. 当类库内部实现改变则正则也要改变\n3. 正则的匹配需要区分注释情况， 有写代码被注释掉如果也被正则匹配了那就会影响实现， 比如`requireJs`就是使用正则匹配的， 导致注释掉相关方法还是调用了\n\n\n综上所诉， 最终我们的解决方案应该是 AST!\n\n如何实现一个简单的babel 呢： \n\n我们需要有将代码转换为 AST 的工具， 处理AST 的工具， AST 转回代码的工具！\n\n让我们来做一个 es6 变量转为es5变量的小工具， 让我们开始动手吧\n\n让我们先 从字符串转为AST：\n\n```js\nconst esprima = require('esprima')\nconst estraverse = require('estraverse')\nconst code = ` const view = {\n    a: 3,\n    init: () => {\n      view.a = 5\n    },\n    render: () => {\n\n    }\n  }\n`\nconst ast = esprima.parse(code)\n```\n\n让我们看看上面构建的这段代码字符串会被转换为什么\n\n\n\n![2019-09-14-22-50-42](http://img.nixiaolei.com/2019-09-14-22-50-42.png)\n\n\n看到了结果， 我们也看到了我们需要的关键字`const` ， 是不是我们只要把它改为var 就可以了呢， 哈哈， 动手试试吧\n\n```js\nconst esprima = require('esprima')\nconst estraverse = require('estraverse')\nconst escodegen = require('escodegen')\n// mock 一段代码\nconst code = ` const view = {\n  a: 3,\n  init: () => {\n    view.a = 5\n  },\n  render: () => {\n\n  }\n}\n`\n// 将代码转为 ast\nconst ast = esprima.parse(code)\nconsole.log(ast)\n// 遍历ast 修改相关操作\nestraverse.traverse(ast, {\n  enter(node) {\n    if( node.type === \"VariableDeclaration\" ) {\n      node.kind = 'var'\n    }\n  }\n})\n// 得到经过ast处理的 js 代码 \nconst reg_code = escodegen.generate(ast)\nconsole.log('--------- 输出结果 ---------------')\nconsole.log(JSON.stringify(reg_code, null,4))\n\n```\n\n\n此时的输出:\n\n![2019-09-14-23-00-49](http://img.nixiaolei.com/2019-09-14-23-00-49.png)\n\n可以看到最下面的字符串， const 被成功替换为了 var ， 完美！\n\n一个最小最简陋的babel 就这么实现了！\n\n\n","slug":"【工程化】babel简单原理及简单实现","published":1,"updated":"2019-09-15T06:19:07.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u6005jaas67e4b92te"},{"title":"【数据结构】什么是图","date":"2019-06-08T14:24:29.000Z","_content":"\n\n由顶点的集合（不能是空集） 和边的集合组成的结构， 表现的是多对多的关系\n* 数学基础是： 图论\n* 几个基本概念：\n  * 顶点（在树里叫节点）\n  * 边\n  * 权\n  * 有向图和无向图\n\n\n![图](http://img.nixiaolei.com/tu.png)\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【数据结构】什么是图.md","raw":"---\ntitle: 【数据结构】什么是图\ndate: 2019-06-08 22:24:29\ncategories: 数据结构\ntags: 数据结构\n---\n\n\n由顶点的集合（不能是空集） 和边的集合组成的结构， 表现的是多对多的关系\n* 数学基础是： 图论\n* 几个基本概念：\n  * 顶点（在树里叫节点）\n  * 边\n  * 权\n  * 有向图和无向图\n\n\n![图](http://img.nixiaolei.com/tu.png)\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【数据结构】什么是图","published":1,"updated":"2019-09-09T16:57:46.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u7005maas6613s4d35"},{"title":"【数据结构】什么是集合","date":"2019-05-01T15:03:47.000Z","_content":"\n\n\n\n\n## 集合\n数据结构中的集合关系就类似于数学中的集合。\n1. 集合中的数据成员是无序的。\n2. 每个数据成员在集合中不能重复，仅且只出现一次。\n\n![集合](http://img.nixiaolei.com/2019-05-01-22-59-42.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【数据结构】什么是集合.md","raw":"---\ntitle: 【数据结构】什么是集合\ndate: 2019-05-01 23:03:47\ncategories: 数据结构\ntags: 数据结构\n---\n\n\n\n\n\n## 集合\n数据结构中的集合关系就类似于数学中的集合。\n1. 集合中的数据成员是无序的。\n2. 每个数据成员在集合中不能重复，仅且只出现一次。\n\n![集合](http://img.nixiaolei.com/2019-05-01-22-59-42.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【数据结构】什么是集合","published":1,"updated":"2019-09-09T16:57:46.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u8005paas650hrm8go"},{"title":"【数据结构】什么是线性表","date":"2019-05-01T15:06:06.000Z","_content":"\n\n\n\n## 线性表\n线性结构中的数据元素之间是一对一的关系。也就是数据元素一个接一个\n地排列。\n1. 用来存放特定的某一个类型的元素\n2. 物理结构为顺序表和链表（链式结构）\n\n\n关于存放特定类型元素的解释:\n> Java等语言的泛型实际上也是在遵守这一规则， 因为他们的基类相同\n> JS也是如此， 因为js万物皆对象， 存储时都会被一个容器给包裹了， 所以类型相同\n\n### 顺序表与链表对比\n* 顺序表: 不灵活，省内存\n* 链表： 灵活， 多耗一点内存\n\n顺序表的优势在于比链表要更节省内存， 因为无需存储额外的指针\n\n但缺点在于， 线性表申请完内存后， 无法进行缩放内存， 你需要用多大你就一次性连续申请多大， 如果你后期需要变更， 只能申请新的\n\n\n\n\n### 线性表的衍生结构\n> 可在本站中搜索\n\n1. 栈\n2. 队列\n3. 串\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【数据结构】什么是线性表.md","raw":"---\ntitle: 【数据结构】什么是线性表\ndate: 2019-05-01 23:06:06\ncategories: 数据结构\ntags: 数据结构\n---\n\n\n\n\n## 线性表\n线性结构中的数据元素之间是一对一的关系。也就是数据元素一个接一个\n地排列。\n1. 用来存放特定的某一个类型的元素\n2. 物理结构为顺序表和链表（链式结构）\n\n\n关于存放特定类型元素的解释:\n> Java等语言的泛型实际上也是在遵守这一规则， 因为他们的基类相同\n> JS也是如此， 因为js万物皆对象， 存储时都会被一个容器给包裹了， 所以类型相同\n\n### 顺序表与链表对比\n* 顺序表: 不灵活，省内存\n* 链表： 灵活， 多耗一点内存\n\n顺序表的优势在于比链表要更节省内存， 因为无需存储额外的指针\n\n但缺点在于， 线性表申请完内存后， 无法进行缩放内存， 你需要用多大你就一次性连续申请多大， 如果你后期需要变更， 只能申请新的\n\n\n\n\n### 线性表的衍生结构\n> 可在本站中搜索\n\n1. 栈\n2. 队列\n3. 串\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【数据结构】什么是线性表","published":1,"updated":"2019-09-09T16:57:46.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u9005saas6jjy6lo1i"},{"title":"【数据结构】线性表之'串'","date":"2019-06-02T12:47:14.000Z","_content":"\n\n比如： 字符串、 字节流\n\n\n1. 串的概念 \n字符串简称串，是一种特殊的线性表，它的数据元素仅由一个字符组成。\n\n2. 串的定义 \n串(String)是由零个或多个字符组成的有限序列，又称字符串。\n\n\n![数据结构](http://img.nixiaolei.com/jiegou-chuan.png)\n\n串的特殊在于， 在一个大的线性表中对一个小线性表操作\n\n\n\n\n\n\n\n","source":"_posts/【数据结构】线性表之-串.md","raw":"---\ntitle: 【数据结构】线性表之'串'\ndate: 2019-06-02 20:47:14\ncategories: 数据结构\ntags: 数据结构\n---\n\n\n比如： 字符串、 字节流\n\n\n1. 串的概念 \n字符串简称串，是一种特殊的线性表，它的数据元素仅由一个字符组成。\n\n2. 串的定义 \n串(String)是由零个或多个字符组成的有限序列，又称字符串。\n\n\n![数据结构](http://img.nixiaolei.com/jiegou-chuan.png)\n\n串的特殊在于， 在一个大的线性表中对一个小线性表操作\n\n\n\n\n\n\n\n","slug":"【数据结构】线性表之-串","published":1,"updated":"2019-09-09T16:57:46.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4u9005uaas6nco4j6l4"},{"title":"【数据结构】线性表之'栈'","date":"2019-05-01T15:02:05.000Z","_content":"\n栈是一种被限制操作的线性表。\n\nLIFO（Last In First Out），后入先出\n\n用途：\n1. 解决括号匹配检查\n2. 浏览器的后退或编辑器的undo功能\n\n![栈](http://img.nixiaolei.com/2019-05-01-23-03-21.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【数据结构】线性表之'栈'.md","raw":"---\ntitle: 【数据结构】线性表之'栈'\ndate: 2019-05-01 23:02:05\ncategories: 数据结构\ntags: 数据结构\n---\n\n栈是一种被限制操作的线性表。\n\nLIFO（Last In First Out），后入先出\n\n用途：\n1. 解决括号匹配检查\n2. 浏览器的后退或编辑器的undo功能\n\n![栈](http://img.nixiaolei.com/2019-05-01-23-03-21.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【数据结构】线性表之'栈'","published":1,"updated":"2019-09-09T16:57:46.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ua005yaas60oyvaav0"},{"title":"【数据结构】线性表之队列","date":"2019-05-01T15:11:41.000Z","_content":"\n队列是一种被限制操作的线性表。\n\nFIFO（First In First Out）， 遵循选入先出\n\n用途：\n消息队列、视频弹幕\n\n\n![队列](http://img.nixiaolei.com/2019-05-01-23-12-36.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【数据结构】线性表之队列.md","raw":"---\ntitle: 【数据结构】线性表之队列\ndate: 2019-05-01 23:11:41\ncategories: 数据结构\ntags: 数据结构\n---\n\n队列是一种被限制操作的线性表。\n\nFIFO（First In First Out）， 遵循选入先出\n\n用途：\n消息队列、视频弹幕\n\n\n![队列](http://img.nixiaolei.com/2019-05-01-23-12-36.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【数据结构】线性表之队列","published":1,"updated":"2019-09-09T16:57:46.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ub0061aas6ju96sxme"},{"title":"【工程化】如何编写一个自己的webpack插件","date":"2019-09-14T15:05:23.000Z","_content":"\n\n\n\n## webpack 实现插件的机制\n[ 创建 ] -- webpack在其内部对象上创建各种钩子\n[ 注册 ] -- 插件将自己的方法注册到对应钩子上， 交给webpack\n[ 调用 ] -- webpack 编译过程中， 会适时地触发相应钩子， 因此也就触发了插件的方法 \n\n\n\n## 第一个demo\n不知道这么起步， 那咱就先去复制一个， 官网提供了一个最最最简易的demo\n\n> https://webpack.js.org/concepts/plugins/\n\n复制下来是这样的:\n```js\nconst pluginName = 'ConsoleLogOnBuildWebpackPlugin';\n\nclass ConsoleLogOnBuildWebpackPlugin {\n  // 每个插件必备的方法\n  apply(compiler) {\n    // compiler 是整个webpack编译的核心\n    // tap 可以理解为触发订阅\n    compiler.hooks.run.tap(pluginName, compilation => {\n      console.log('🍎The webpack build process is starting!!!');\n    });\n  }\n}\n\nmodule.exports = ConsoleLogOnBuildWebpackPlugin;\n```\n\n把这个插件引入webpack , 虽然是成功跑起来了啊， 但是一脸蒙蔽， 完全不知道在干嘛也不行啊\n\n首先每个插件都必须要有一个`apply` 方法， 它会接收一个`compiler` ， 这个`compiler` 是所有webpack的核心， 所以webpack 编译相关的内容自然也就在它上面了\n\n接着，我们看到了 complier 上有一个hooks , 后面还有一大串， 那这个`hooks`是哪里来的呢， 怎么回事呢？\n\n让我们去源码里一探究竟：\n\n![2019-09-14-23-39-17](http://img.nixiaolei.com/2019-09-14-23-39-17.png)\n\n\n哦～ 原来所有 hooks 相关的方法都在这里了， 并且我们发现 compiler 是继承自 `Tapable`\n\n不光如此， 连接受的参数中的 `compilation` 也继承自 Tapable, compilation 代表了当次编译的chunk\n\n![2019-09-15-00-16-21](http://img.nixiaolei.com/2019-09-15-00-16-21.png)\n\n那啥是 Tapable 啊？\n\n## 认识 Tapable\nTapble 是 webpack 的灵魂插件， 它是一个用于做消息通知的包.\n\n多说无用， 让我们来单独玩一下 tapable\n\n```js\nconst {\n  //同步串行的钩子， 不用关心函数的返回值\n  SyncHook,\n  // 同步串行的钩子 ， 上一个返回值不为null 跳过剩下的逻辑\n  SyncBailHook,\n  // 同步串行， 上一个值可以传递给下一个值\n  SyncWaterfallHook,\n  SyncLoopHook,\n  AsyncParallelHook,\n  AsyncParallelBailHook,\n  AsyncSeriesHook,\n  AsyncSeriesBailHook,\n  AsyncSeriesWaterfallHook \n} = require(\"tapable\");\n\n\nconst queue = new SyncHook([\"name\", \"name2\"])\n// 订阅\nqueue.tap(\"1\", function (name, name2) {\n  console.log(\"1⃣️\", name, name2)\n  return 1\n})\n\nqueue.tap(\"2\", function (name, name2) {\n  console.log(\"2⃣️\", name, name2)\n})\n\nqueue.tap(\"3\", function (name, name2) {\n  console.log(\"3⃣️\", name, name2)\n})\n\n\n// 触发整个钩子\nqueue.call('webpack', \"webpack-cli\")\n```\n\n此时的输出\n![2019-09-15-00-31-59](http://img.nixiaolei.com/2019-09-15-00-31-59.png)\n\n可以看的出 ， 当queue 的call 方法被调用时， 之前挂载的 tap 方法都被触发了， 这其实就是前端里几乎无处不在的观察者模式\n\n\n\n\n\n##  附上一个之前写的webpack 插件\n这是之前用来处理swig模版编译的plugin \n```js\n// 1. 何时才能拦截最后生成的swig\n// 2. 如何分清这个swig文件对应的Js\nclass HtmlAfterWebpackPlugin {\n  // compiler 是webpack的实例\n    apply(compiler) {\n      //  此处是实例运行期间， 可以吧 tap 当成是 on\n      // 实例上有钩子， 将插件注册到webpack实例钩子上 （run初始运行阶段, compilation: 完成阶段）\n        compiler.hooks.compilation.tap(pluginName, compilation => {\n          console.log(\"🍉webpack 构建过程开始！\");\n          // 因为webpack的版本更新不友好， 所以新的插件挂载方式需要自己从源码中查找\n          // 此阶段是 html-webpack-plugin 提供的，  所以必须在 html-webpack-plugin 之后执行\n      \n\n          // 此处是将回调挂载到 webpack 执行过程中的某个阶段， 也就是生命周期\n          // Plugin的顺序是 从上至下挂钩子， 但执行顺序不一定 \n          compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tap(pluginName, htmlPluginData => {\n            let _html = htmlPluginData.html\n            const jsResult = assetsHelp(htmlPluginData.assets) \n            // 路径别名\n            _html = _html.replace(/views:/g, \"../../\")\n            _html = _html.replace(/components:/g, \"../../../components/\")\n            // 指定位置插入js css\n            _html = _html.replace(/<!--injectjs-->/g, jsResult.js.join(\"\"))\n            _html = _html.replace(/<!--injectcss-->/g, jsResult.css.join(\"\"))\n            // _html = _html.replace(\"<!--injectjs-->\", jsResult.js.join(\"\"))\n            htmlPluginData.html = _html\n            // htmlPluginData.html = _html\n            \n          })\n        });\n    }\n}\n\n```","source":"_posts/【工程化】如何编写一个自己的webpack插件.md","raw":"---\ntitle: 【工程化】如何编写一个自己的webpack插件\ndate: 2019-09-14 23:05:23\ncategories: 工程化\ntags:  [webpack, 工程化]\n---\n\n\n\n\n## webpack 实现插件的机制\n[ 创建 ] -- webpack在其内部对象上创建各种钩子\n[ 注册 ] -- 插件将自己的方法注册到对应钩子上， 交给webpack\n[ 调用 ] -- webpack 编译过程中， 会适时地触发相应钩子， 因此也就触发了插件的方法 \n\n\n\n## 第一个demo\n不知道这么起步， 那咱就先去复制一个， 官网提供了一个最最最简易的demo\n\n> https://webpack.js.org/concepts/plugins/\n\n复制下来是这样的:\n```js\nconst pluginName = 'ConsoleLogOnBuildWebpackPlugin';\n\nclass ConsoleLogOnBuildWebpackPlugin {\n  // 每个插件必备的方法\n  apply(compiler) {\n    // compiler 是整个webpack编译的核心\n    // tap 可以理解为触发订阅\n    compiler.hooks.run.tap(pluginName, compilation => {\n      console.log('🍎The webpack build process is starting!!!');\n    });\n  }\n}\n\nmodule.exports = ConsoleLogOnBuildWebpackPlugin;\n```\n\n把这个插件引入webpack , 虽然是成功跑起来了啊， 但是一脸蒙蔽， 完全不知道在干嘛也不行啊\n\n首先每个插件都必须要有一个`apply` 方法， 它会接收一个`compiler` ， 这个`compiler` 是所有webpack的核心， 所以webpack 编译相关的内容自然也就在它上面了\n\n接着，我们看到了 complier 上有一个hooks , 后面还有一大串， 那这个`hooks`是哪里来的呢， 怎么回事呢？\n\n让我们去源码里一探究竟：\n\n![2019-09-14-23-39-17](http://img.nixiaolei.com/2019-09-14-23-39-17.png)\n\n\n哦～ 原来所有 hooks 相关的方法都在这里了， 并且我们发现 compiler 是继承自 `Tapable`\n\n不光如此， 连接受的参数中的 `compilation` 也继承自 Tapable, compilation 代表了当次编译的chunk\n\n![2019-09-15-00-16-21](http://img.nixiaolei.com/2019-09-15-00-16-21.png)\n\n那啥是 Tapable 啊？\n\n## 认识 Tapable\nTapble 是 webpack 的灵魂插件， 它是一个用于做消息通知的包.\n\n多说无用， 让我们来单独玩一下 tapable\n\n```js\nconst {\n  //同步串行的钩子， 不用关心函数的返回值\n  SyncHook,\n  // 同步串行的钩子 ， 上一个返回值不为null 跳过剩下的逻辑\n  SyncBailHook,\n  // 同步串行， 上一个值可以传递给下一个值\n  SyncWaterfallHook,\n  SyncLoopHook,\n  AsyncParallelHook,\n  AsyncParallelBailHook,\n  AsyncSeriesHook,\n  AsyncSeriesBailHook,\n  AsyncSeriesWaterfallHook \n} = require(\"tapable\");\n\n\nconst queue = new SyncHook([\"name\", \"name2\"])\n// 订阅\nqueue.tap(\"1\", function (name, name2) {\n  console.log(\"1⃣️\", name, name2)\n  return 1\n})\n\nqueue.tap(\"2\", function (name, name2) {\n  console.log(\"2⃣️\", name, name2)\n})\n\nqueue.tap(\"3\", function (name, name2) {\n  console.log(\"3⃣️\", name, name2)\n})\n\n\n// 触发整个钩子\nqueue.call('webpack', \"webpack-cli\")\n```\n\n此时的输出\n![2019-09-15-00-31-59](http://img.nixiaolei.com/2019-09-15-00-31-59.png)\n\n可以看的出 ， 当queue 的call 方法被调用时， 之前挂载的 tap 方法都被触发了， 这其实就是前端里几乎无处不在的观察者模式\n\n\n\n\n\n##  附上一个之前写的webpack 插件\n这是之前用来处理swig模版编译的plugin \n```js\n// 1. 何时才能拦截最后生成的swig\n// 2. 如何分清这个swig文件对应的Js\nclass HtmlAfterWebpackPlugin {\n  // compiler 是webpack的实例\n    apply(compiler) {\n      //  此处是实例运行期间， 可以吧 tap 当成是 on\n      // 实例上有钩子， 将插件注册到webpack实例钩子上 （run初始运行阶段, compilation: 完成阶段）\n        compiler.hooks.compilation.tap(pluginName, compilation => {\n          console.log(\"🍉webpack 构建过程开始！\");\n          // 因为webpack的版本更新不友好， 所以新的插件挂载方式需要自己从源码中查找\n          // 此阶段是 html-webpack-plugin 提供的，  所以必须在 html-webpack-plugin 之后执行\n      \n\n          // 此处是将回调挂载到 webpack 执行过程中的某个阶段， 也就是生命周期\n          // Plugin的顺序是 从上至下挂钩子， 但执行顺序不一定 \n          compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tap(pluginName, htmlPluginData => {\n            let _html = htmlPluginData.html\n            const jsResult = assetsHelp(htmlPluginData.assets) \n            // 路径别名\n            _html = _html.replace(/views:/g, \"../../\")\n            _html = _html.replace(/components:/g, \"../../../components/\")\n            // 指定位置插入js css\n            _html = _html.replace(/<!--injectjs-->/g, jsResult.js.join(\"\"))\n            _html = _html.replace(/<!--injectcss-->/g, jsResult.css.join(\"\"))\n            // _html = _html.replace(\"<!--injectjs-->\", jsResult.js.join(\"\"))\n            htmlPluginData.html = _html\n            // htmlPluginData.html = _html\n            \n          })\n        });\n    }\n}\n\n```","slug":"【工程化】如何编写一个自己的webpack插件","published":1,"updated":"2019-09-14T16:41:02.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uc0065aas65dbziali"},{"title":"【数据结构】线性表之链表","date":"2019-05-01T15:21:30.000Z","_content":"\n链表如果按存储结构来分， 是属于链式存储结构\n\n链表的每一项数据元素之间有`衔接关系`(圈起来要考)\n\n> 链表的优势在于灵活，不受申请时的内存大小约束，链表插入数据， 只需要切换一下指针即可\n\n## 链表\n链表分为： \n1. 单向链表\n2. 双向链表\n\n\n### 单向链表\n链表在每一个数据元素中分为两个部分， 一个用来存储自身的数据， 另一部分存储下一项的指针（称为后继指针）\n\n![单向链表](http://img.nixiaolei.com/2019-05-01-23-26-30.png)\n\n### 双向链表\n双向链表顾名思义， 就是支持两个方向的链表（前驱和后继）\n\n![双向链表](http://img.nixiaolei.com/2019-05-01-23-38-23.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【数据结构】线性表之链表.md","raw":"---\ntitle: 【数据结构】线性表之链表\ndate: 2019-05-01 23:21:30\ncategories: 数据结构\ntags: 数据结构\n---\n\n链表如果按存储结构来分， 是属于链式存储结构\n\n链表的每一项数据元素之间有`衔接关系`(圈起来要考)\n\n> 链表的优势在于灵活，不受申请时的内存大小约束，链表插入数据， 只需要切换一下指针即可\n\n## 链表\n链表分为： \n1. 单向链表\n2. 双向链表\n\n\n### 单向链表\n链表在每一个数据元素中分为两个部分， 一个用来存储自身的数据， 另一部分存储下一项的指针（称为后继指针）\n\n![单向链表](http://img.nixiaolei.com/2019-05-01-23-26-30.png)\n\n### 双向链表\n双向链表顾名思义， 就是支持两个方向的链表（前驱和后继）\n\n![双向链表](http://img.nixiaolei.com/2019-05-01-23-38-23.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【数据结构】线性表之链表","published":1,"updated":"2019-09-09T16:57:46.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ud0068aas6uslvswul"},{"title":"【数据结构】线性表之顺序表","date":"2019-05-01T15:45:21.000Z","_content":"\n## 顺序表\n\n\n### 优点\n顺序表的优势在于比链表要更节省内存， 因为无需存储额外的指针\n\n### 缺点\n但缺点在于， 线性表申请完内存后， 无法进行缩放内存， 你需要用多大你就一次性连续申请多大， 如果你后期需要变更， 只能申请新的\n\n并且当你需要在顺序表中插入数据时， 需要将插入目标位置后面的数据全部向后挪动， 这非常的耗费性能，  链表则不用， 只需要切换一下指针即可\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【数据结构】线性表之顺序表.md","raw":"---\ntitle: 【数据结构】线性表之顺序表\ndate: 2019-05-01 23:45:21\ncategories: 数据结构\ntags: 数据结构\n---\n\n## 顺序表\n\n\n### 优点\n顺序表的优势在于比链表要更节省内存， 因为无需存储额外的指针\n\n### 缺点\n但缺点在于， 线性表申请完内存后， 无法进行缩放内存， 你需要用多大你就一次性连续申请多大， 如果你后期需要变更， 只能申请新的\n\n并且当你需要在顺序表中插入数据时， 需要将插入目标位置后面的数据全部向后挪动， 这非常的耗费性能，  链表则不用， 只需要切换一下指针即可\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【数据结构】线性表之顺序表","published":1,"updated":"2019-09-09T16:57:46.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ud006baas6hepva46l"},{"title":"【算法】二叉树学习笔记","date":"2019-04-24T14:24:23.000Z","_content":"\n> 树由边和节点组成\n\n\n## 概念和用途\n* 树是一种非线性的数据结构， 分层存储。\n* 树被用来存储具有层级关系的数据， 还被用来存储有序列表。\n* 二叉树进行查找特别快， 为二叉树添加或删除元素也也别快\n* 集合中不允许相同成员存在。\n\n## 关键概念定义\n1. 树由一组以边连接的节点组成\n2. 一棵树最上面的节点称为根节点， 如果一个节点下面连接多个节点， 那么该节点称为父节点，  它下面的节点被称为子节点。 一个节点可以有0个、 1个或多个子节点。 没有任何子节点的节点称为叶子节点。\n3. 二叉树是一种特殊的树， 子节点个属不超过两个。\n4. 从一个节点走到另一个节点的这一组称为路径\n5. 以某种特定顺序访问树中的所有节点称为`树的遍历`\n6. 树分为几个层次， 根节点是第0层， 它的子节点是第一层， 一次类推。 我们定义`树`的层数就是树的`深度` 。\n7. 每个节点都有一个与之相关的值， 该值有时被称为键。\n8. 一个父节点的两个子节点分别称为左节点和右节点。 二叉查找树是一种特殊的二叉树， 相对较小的值保存在左节点， 较大的值保存在右节点， 这一特性使得查找效率很高。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【算法】二叉树学习笔记.md","raw":"---\ntitle: 【算法】二叉树学习笔记\ndate: 2019-04-24 22:24:23\ncategories: 算法\ntags: 算法\n---\n\n> 树由边和节点组成\n\n\n## 概念和用途\n* 树是一种非线性的数据结构， 分层存储。\n* 树被用来存储具有层级关系的数据， 还被用来存储有序列表。\n* 二叉树进行查找特别快， 为二叉树添加或删除元素也也别快\n* 集合中不允许相同成员存在。\n\n## 关键概念定义\n1. 树由一组以边连接的节点组成\n2. 一棵树最上面的节点称为根节点， 如果一个节点下面连接多个节点， 那么该节点称为父节点，  它下面的节点被称为子节点。 一个节点可以有0个、 1个或多个子节点。 没有任何子节点的节点称为叶子节点。\n3. 二叉树是一种特殊的树， 子节点个属不超过两个。\n4. 从一个节点走到另一个节点的这一组称为路径\n5. 以某种特定顺序访问树中的所有节点称为`树的遍历`\n6. 树分为几个层次， 根节点是第0层， 它的子节点是第一层， 一次类推。 我们定义`树`的层数就是树的`深度` 。\n7. 每个节点都有一个与之相关的值， 该值有时被称为键。\n8. 一个父节点的两个子节点分别称为左节点和右节点。 二叉查找树是一种特殊的二叉树， 相对较小的值保存在左节点， 较大的值保存在右节点， 这一特性使得查找效率很高。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【算法】二叉树学习笔记","published":1,"updated":"2019-09-09T16:57:46.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ue006daas6sw27cq9h"},{"title":"【算法】什么是算法","date":"2019-06-08T14:35:50.000Z","_content":"\n\n\n算法是完成某个特定任务的过程。  通常数据结构作为工具来辅助进行算法， 所以有了一个流传甚广的公式： 程序 = 数据结构 + 算法\n\n* 算法不是数学， 但是可以用数学来描述\n* 我们要做一件事情， 整个过程本身就是算法\n* 我们最常用的增删改查是算法的一部分\n* 算法可以用自然语言、 流程图、 伪代码和计算机语言等手段来表示\n* 在面向对象语言中， 算法通常通过类的方法实现\n\n\n## 算法的特征\n\n算法的五大特征：\n* 有穷性： 算法必须能在执行有限个步骤后终止\n* 确切性： 每一步骤必须由确切的定义\n* 输入项： 有0个或多个输入， 用来规定初始情况， 所谓0 个输入是指算法本身定出了初始条件\n* 输出项： 有一个或多个输出， 是对输入数据处理后的结果。 没有输出的算法毫无意义\n* 可行性： 算法执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，每个计算步骤都可以在有限时间内完成（也称之为有效性。）\n\n\n## 如何衡量算法的好坏\n* 算法的好坏主要通过算法复杂度来衡量\n * 时间复杂度\n * 空间复杂度\n* 正确性\n* 可读性\n* 健壮性\n\n## 常见的复杂度\n* 常数阶 O(1)\n* 对数阶 O(logN)\n* 线性阶 O(n)\n* 线性对数阶 O(nlogN)\n* 平方阶 O(n^2)\n* 立方阶 O(n^3)\n* k次方阶 O(n ^ k)\n* 指数阶O(2 ^ n)\n\n![复杂度](http://img.nixiaolei.com/fuzadu.png)\n\n\n\n## 计算复杂度\n> logN 就是类似循环操作的逆运算，每次计算都将计算量减少一半\n\n\n* 随着问题规模 n 的不断增加， 时间复杂度不断增大， 算法的执行效率越低\n* 一般做算法复杂度分析的时候， 遵循下面的技巧:\n * 有几重循环， 一般来说就是O(n), 两重就是O（n^2）, 依此类推\n * 如果有二分， 则为O（logN）\n * 保留最高项， 去除常数项\n\n\n计算例子\n![2019-06-08-23-13-24](http://img.nixiaolei.com/2019-06-08-23-13-24.png)\n\n\n\n\n\n\n","source":"_posts/【算法】什么是算法.md","raw":"---\ntitle: 【算法】什么是算法\ndate: 2019-06-08 22:35:50\ncategories: 算法\ntags: 算法\n---\n\n\n\n算法是完成某个特定任务的过程。  通常数据结构作为工具来辅助进行算法， 所以有了一个流传甚广的公式： 程序 = 数据结构 + 算法\n\n* 算法不是数学， 但是可以用数学来描述\n* 我们要做一件事情， 整个过程本身就是算法\n* 我们最常用的增删改查是算法的一部分\n* 算法可以用自然语言、 流程图、 伪代码和计算机语言等手段来表示\n* 在面向对象语言中， 算法通常通过类的方法实现\n\n\n## 算法的特征\n\n算法的五大特征：\n* 有穷性： 算法必须能在执行有限个步骤后终止\n* 确切性： 每一步骤必须由确切的定义\n* 输入项： 有0个或多个输入， 用来规定初始情况， 所谓0 个输入是指算法本身定出了初始条件\n* 输出项： 有一个或多个输出， 是对输入数据处理后的结果。 没有输出的算法毫无意义\n* 可行性： 算法执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，每个计算步骤都可以在有限时间内完成（也称之为有效性。）\n\n\n## 如何衡量算法的好坏\n* 算法的好坏主要通过算法复杂度来衡量\n * 时间复杂度\n * 空间复杂度\n* 正确性\n* 可读性\n* 健壮性\n\n## 常见的复杂度\n* 常数阶 O(1)\n* 对数阶 O(logN)\n* 线性阶 O(n)\n* 线性对数阶 O(nlogN)\n* 平方阶 O(n^2)\n* 立方阶 O(n^3)\n* k次方阶 O(n ^ k)\n* 指数阶O(2 ^ n)\n\n![复杂度](http://img.nixiaolei.com/fuzadu.png)\n\n\n\n## 计算复杂度\n> logN 就是类似循环操作的逆运算，每次计算都将计算量减少一半\n\n\n* 随着问题规模 n 的不断增加， 时间复杂度不断增大， 算法的执行效率越低\n* 一般做算法复杂度分析的时候， 遵循下面的技巧:\n * 有几重循环， 一般来说就是O(n), 两重就是O（n^2）, 依此类推\n * 如果有二分， 则为O（logN）\n * 保留最高项， 去除常数项\n\n\n计算例子\n![2019-06-08-23-13-24](http://img.nixiaolei.com/2019-06-08-23-13-24.png)\n\n\n\n\n\n\n","slug":"【算法】什么是算法","published":1,"updated":"2019-09-09T16:57:46.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uf006gaas603mmcarl"},{"title":"【算法】枚举算法基本概念","date":"2019-06-08T15:25:13.000Z","_content":"\n* 核心思想：枚举所有的可能。\n* 本质：就是从所有候选答案中去搜索正确的解,使用该算法需要满足两个条件\n  * (1)可预先确定候选答案的数量；\n  * (2)候选答案的范围在求解之前必须有一个确定的集合。\n* 特点：\n  * 枚举算法简单粗暴，暴力的枚举所有可能，尽可能地尝试所有的方法。\n  * 速度可能很慢，却是我们最应该优先考虑的。\n  * 实现最简单，并且得到的结果总是正确的。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【算法】枚举算法基本概念.md","raw":"---\ntitle: 【算法】枚举算法基本概念\ndate: 2019-06-08 23:25:13\ncategories: 算法\ntags: 算法\n---\n\n* 核心思想：枚举所有的可能。\n* 本质：就是从所有候选答案中去搜索正确的解,使用该算法需要满足两个条件\n  * (1)可预先确定候选答案的数量；\n  * (2)候选答案的范围在求解之前必须有一个确定的集合。\n* 特点：\n  * 枚举算法简单粗暴，暴力的枚举所有可能，尽可能地尝试所有的方法。\n  * 速度可能很慢，却是我们最应该优先考虑的。\n  * 实现最简单，并且得到的结果总是正确的。\n\n\n\n\n\n\n\n\n\n\n","slug":"【算法】枚举算法基本概念","published":1,"updated":"2019-09-09T16:57:46.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uf006iaas6rnpmsklo"},{"title":"【工程化】了解webpack原理","date":"2019-07-11T14:58:30.000Z","_content":"\n\n> webpack 的成功之处在于其loader , 但 webpack 的失败之处也出在这个loader\n\n对于webpack 来讲， 万物都是模块， webpack 为什么可以做到万物都可以 `require`就是使用了loader,  但同时也是loader 导致了webpack 的编译速度（你懂的）， 这是为什么呢， 这里先说一下基本原理\n***\n\nwebpack 在处理的时候， 会经过多个loader, 比如`babel-loader`,`less-loader`， 那如何把这些看似毫不相关的， 又是天南地北找来的， 出自不同开发者之手的loader 集合起来呢:\n\n首先是第一个接受任务的loader, loader1 \b会接受代码的字符串， 然后把代码变成 Ast 进行处理， 结束以后再转为 string字符串。\n\n也就是说，整个 loader1 经历了一下的流程:\n\n```\n字符串 -> Ast 静态语法树 -> 遍历Ast处理业务 -> 字符串\n```\n\b\n同样的loader2 也会经历这样一个过程！\n\n\n也就是说所有loader 穿起来就是:\n```\nloader1 开始 -> 获取字符串 ->  Ast -> 遍历Ast处理业务 \n-> 字符串 -> loader1结束 -> loader2 开始 -> 获得字符串 \n-> Ast -> 遍历Ast处理业务 -> 字符串 -> loader 2 结束 \n-> loader3开始 -> ………等等\n```\n\n乍一看， 你可能会觉得， 是不是太蠢了， 为什么不等到全部loader处理完成再转换回 字符串， 还要转来转去， 原来打包时间都在这消耗掉了。\n没错， 你当然不是第一个想到的， 这就是之前大火的parcel 的打包机制（虽然parcel的零配置很优秀， 但因为被webpack抄走了， 所以也渐渐势头不在）,  并且parcel还启用了多核打包:\n\n```\nstring字符串 -> Ast(loader1 & loader2 & loader3) -> string 字符串  外加多核打包📦\n```\n\n一气呵成， 这感觉，多爽， 确实比webpack快多了 ，省了那么多步骤， 能不快吗\n\n\n## webpack 与优化\n上面提到了 parcel 的多核打包， 可我们的主场是webpack ,怎么能不提一提webpack 的多核打包呢， \n\n相信大家都听过或者尝试过臭名昭著的 `happypack` 多核打包插件， 但这个插件实际上在高版本的webpack 上效果略低啊\n\nhappypack 可以用，但也需要考虑下应用场景： 在需要打包的文件太少不建议， 因为多核打包也是需要消耗系统性能的， 反而会使打包变慢了\n\n实际操作起来效果不明显\n\n\n## 如何实现一个loader\n\n 熟话说， 看源码是最好的学习方式， 现在我们先找一个比较简单的开源loader ,看看别人是怎么写的?\n \n 我们下载`markdon-loader`, 打开node_modules 中其的代码， 发现如下：\n ![2019-09-14-19-30-43](http://img.nixiaolei.com/2019-09-14-19-30-43.png)\n\n\n让我们加点注释理解一下\n\n![2019-09-14-19-34-46](http://img.nixiaolei.com/2019-09-14-19-34-46.png)\n\n\nloader 有一个前置钩子， 会在进入主体函数前被调用：\n\n```js\nmodule.exports = function (content, map, meta) {\n  //  this 是我们运行时数据调用方法和补充载体 也就是loader函数的执行上下文， 所以可以通过webpack 提供的函\n  // 数库来从 this 获取外部 rule 处对 loader 配置的option\n\n  console.log('🍎进入loader')\n  console.log('前置钩子内容🍌', this.data)\n  return content + \";console.log(1)\"\n}\n\n// 一个叫pitch的前置钩子 ( 在进入⬆️主体前触发)\nmodule.exports.pitch = function (r, prerequest, data) {\n  console.log(\"进入前置钩子\")\n  data.value = \"are you ok\"\n}\n```\n\n在外面webpack 配置的地方引用我们上方编写的loader\n```js\nconst path = require('path')\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: path.resolve(\"./loader/index.js\"),\n          options: {\n            presets: ['@babel/preset-env']\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n\n让我们看下此时的输出结果\n![2019-09-14-20-18-39](http://img.nixiaolei.com/2019-09-14-20-18-39.png)\n\n\n#### 获取相关的option 配置\nwebpack 提供的函数库可以帮助我们， 在执行阶段从 this 对象上获取到我们配置时所传入的 option 的相关 loader  配置\n```js\nconst loaderUtils = require('loader-utils')\n\nmodule.exports = function (content, map, meta) {\n  //  this 是我们运行时数据调用方法和补充载体 也就是loader函数的执行上下文， 所以可以通过webpack 提供的函\n  // 数库来从 this 获取外部 rule 处对 loader 配置的option\n\n  console.log('🍎进入loader')\n  console.log('前置钩子内容🍌', this.data)\n  const options = loaderUtils.getOptions(this)\n  console.log('🍊获取到的配置文件', options)\n  return content + \";console.log(1)\"\n}\n\n// 一个叫pitch的前置钩子 ( 在进入⬆️主体前触发)\nmodule.exports.pitch = function (r, prerequest, data) {\n  console.log(\"进入前置钩子\")\n  data.value = \"are you ok\"\n}\n```\n\n\n此时我们就成功获取到了配置时所传入的参数了\n\n![2019-09-14-20-24-56](http://img.nixiaolei.com/2019-09-14-20-24-56.png)\n\n#### 异步loader\n如果我们的编写过程中有异步的需求, 我们可以使用下面这两个方法\n\n* this.async 执行异步函数\n* this.callback 执行函数的回调， 返回处理结果\n\n\n\n## loader  与 Ast\n既然loader处理的核心是 Ast, 那么我们同样的夜来尝试一下Ast 的使用,\n\n首先我们下载一个`acorn` , 这是一个专门处理 ast 的库, 我们使用 acorn 提供的方法尝试去转换一段代码， 然后使用walk 所提供的方法将其转换回来\n```JS\nconst acorn = require(\"acorn\")\nconst walk = require('acorn-walk')\n\nconsole.log(acorn.parse(\"const a = 20\"))\nwalk.simple(acorn.parse('let x = 10'), {\n  Literal(node) {\n    console.log(`Found a literal: ${node.value}`)\n  }\n})\n```\n\n输出的结果\n\n![2019-09-14-21-07-23](http://img.nixiaolei.com/2019-09-14-21-07-23.png)\n\n","source":"_posts/【工程化】了解webpack原理.md","raw":"---\ntitle: 【工程化】了解webpack原理\ndate: 2019-07-11 22:58:30\ncategories: 工程化\ntags:  [webpack, 工程化, Ast]\n---\n\n\n> webpack 的成功之处在于其loader , 但 webpack 的失败之处也出在这个loader\n\n对于webpack 来讲， 万物都是模块， webpack 为什么可以做到万物都可以 `require`就是使用了loader,  但同时也是loader 导致了webpack 的编译速度（你懂的）， 这是为什么呢， 这里先说一下基本原理\n***\n\nwebpack 在处理的时候， 会经过多个loader, 比如`babel-loader`,`less-loader`， 那如何把这些看似毫不相关的， 又是天南地北找来的， 出自不同开发者之手的loader 集合起来呢:\n\n首先是第一个接受任务的loader, loader1 \b会接受代码的字符串， 然后把代码变成 Ast 进行处理， 结束以后再转为 string字符串。\n\n也就是说，整个 loader1 经历了一下的流程:\n\n```\n字符串 -> Ast 静态语法树 -> 遍历Ast处理业务 -> 字符串\n```\n\b\n同样的loader2 也会经历这样一个过程！\n\n\n也就是说所有loader 穿起来就是:\n```\nloader1 开始 -> 获取字符串 ->  Ast -> 遍历Ast处理业务 \n-> 字符串 -> loader1结束 -> loader2 开始 -> 获得字符串 \n-> Ast -> 遍历Ast处理业务 -> 字符串 -> loader 2 结束 \n-> loader3开始 -> ………等等\n```\n\n乍一看， 你可能会觉得， 是不是太蠢了， 为什么不等到全部loader处理完成再转换回 字符串， 还要转来转去， 原来打包时间都在这消耗掉了。\n没错， 你当然不是第一个想到的， 这就是之前大火的parcel 的打包机制（虽然parcel的零配置很优秀， 但因为被webpack抄走了， 所以也渐渐势头不在）,  并且parcel还启用了多核打包:\n\n```\nstring字符串 -> Ast(loader1 & loader2 & loader3) -> string 字符串  外加多核打包📦\n```\n\n一气呵成， 这感觉，多爽， 确实比webpack快多了 ，省了那么多步骤， 能不快吗\n\n\n## webpack 与优化\n上面提到了 parcel 的多核打包， 可我们的主场是webpack ,怎么能不提一提webpack 的多核打包呢， \n\n相信大家都听过或者尝试过臭名昭著的 `happypack` 多核打包插件， 但这个插件实际上在高版本的webpack 上效果略低啊\n\nhappypack 可以用，但也需要考虑下应用场景： 在需要打包的文件太少不建议， 因为多核打包也是需要消耗系统性能的， 反而会使打包变慢了\n\n实际操作起来效果不明显\n\n\n## 如何实现一个loader\n\n 熟话说， 看源码是最好的学习方式， 现在我们先找一个比较简单的开源loader ,看看别人是怎么写的?\n \n 我们下载`markdon-loader`, 打开node_modules 中其的代码， 发现如下：\n ![2019-09-14-19-30-43](http://img.nixiaolei.com/2019-09-14-19-30-43.png)\n\n\n让我们加点注释理解一下\n\n![2019-09-14-19-34-46](http://img.nixiaolei.com/2019-09-14-19-34-46.png)\n\n\nloader 有一个前置钩子， 会在进入主体函数前被调用：\n\n```js\nmodule.exports = function (content, map, meta) {\n  //  this 是我们运行时数据调用方法和补充载体 也就是loader函数的执行上下文， 所以可以通过webpack 提供的函\n  // 数库来从 this 获取外部 rule 处对 loader 配置的option\n\n  console.log('🍎进入loader')\n  console.log('前置钩子内容🍌', this.data)\n  return content + \";console.log(1)\"\n}\n\n// 一个叫pitch的前置钩子 ( 在进入⬆️主体前触发)\nmodule.exports.pitch = function (r, prerequest, data) {\n  console.log(\"进入前置钩子\")\n  data.value = \"are you ok\"\n}\n```\n\n在外面webpack 配置的地方引用我们上方编写的loader\n```js\nconst path = require('path')\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: path.resolve(\"./loader/index.js\"),\n          options: {\n            presets: ['@babel/preset-env']\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n\n让我们看下此时的输出结果\n![2019-09-14-20-18-39](http://img.nixiaolei.com/2019-09-14-20-18-39.png)\n\n\n#### 获取相关的option 配置\nwebpack 提供的函数库可以帮助我们， 在执行阶段从 this 对象上获取到我们配置时所传入的 option 的相关 loader  配置\n```js\nconst loaderUtils = require('loader-utils')\n\nmodule.exports = function (content, map, meta) {\n  //  this 是我们运行时数据调用方法和补充载体 也就是loader函数的执行上下文， 所以可以通过webpack 提供的函\n  // 数库来从 this 获取外部 rule 处对 loader 配置的option\n\n  console.log('🍎进入loader')\n  console.log('前置钩子内容🍌', this.data)\n  const options = loaderUtils.getOptions(this)\n  console.log('🍊获取到的配置文件', options)\n  return content + \";console.log(1)\"\n}\n\n// 一个叫pitch的前置钩子 ( 在进入⬆️主体前触发)\nmodule.exports.pitch = function (r, prerequest, data) {\n  console.log(\"进入前置钩子\")\n  data.value = \"are you ok\"\n}\n```\n\n\n此时我们就成功获取到了配置时所传入的参数了\n\n![2019-09-14-20-24-56](http://img.nixiaolei.com/2019-09-14-20-24-56.png)\n\n#### 异步loader\n如果我们的编写过程中有异步的需求, 我们可以使用下面这两个方法\n\n* this.async 执行异步函数\n* this.callback 执行函数的回调， 返回处理结果\n\n\n\n## loader  与 Ast\n既然loader处理的核心是 Ast, 那么我们同样的夜来尝试一下Ast 的使用,\n\n首先我们下载一个`acorn` , 这是一个专门处理 ast 的库, 我们使用 acorn 提供的方法尝试去转换一段代码， 然后使用walk 所提供的方法将其转换回来\n```JS\nconst acorn = require(\"acorn\")\nconst walk = require('acorn-walk')\n\nconsole.log(acorn.parse(\"const a = 20\"))\nwalk.simple(acorn.parse('let x = 10'), {\n  Literal(node) {\n    console.log(`Found a literal: ${node.value}`)\n  }\n})\n```\n\n输出的结果\n\n![2019-09-14-21-07-23](http://img.nixiaolei.com/2019-09-14-21-07-23.png)\n\n","slug":"【工程化】了解webpack原理","published":1,"updated":"2019-09-14T13:09:08.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ug006laas67te39zbr"},{"title":"【算法】理解Dom-diff","date":"2019-06-23T13:48:48.000Z","_content":"\n\n## 算法复杂度\n比较两棵DOM树的差异是 Virtual Dom 算法最核心的部分， 这也是所谓的Virtual Dom的 diff算法。 两个树的完全的diff算法是一个时间复杂度为 O（n^3） 的问题。 但是在前端当中， 你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比。 下面的div指挥和同一层级的div对比， 第二层级的智慧跟第二层级对比。 这样算法复杂度就可以达到O(n)。\n\n\n![2019-06-23-21-55-03](http://img.nixiaolei.com/2019-06-23-21-55-03.png)\n\n\n## 对比方式\n实际的代码中， 会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记， 在深度优先遍历的时候， 每遍历到一个节点就把该节点和新的树进行对比。 如果有差异的话就记录到一个对象里面。\n\n\n![2019-06-23-21-57-26](http://img.nixiaolei.com/2019-06-23-21-57-26.png)\n\n\n\n\n## 实践一下\n\n所谓的`dom-diff` 抛去具体的dom处理逻辑， 其核心思想还是比较简单的， 其实就是一个深度优先遍历。\n\n我们就来尝试实现一下一个简单的dom-diff\n\n首先\n### 模拟dom结构\n以面向对象的编程方式， 构建出一个dom节点所必要的属性\n\n```js\nclass Element {\n  constructor(type, props, children) {\n    this.type = type\n    this.props = props\n    this.children = children\n  }\n}\n```\n\n然后我们再实现一个创建虚拟dom节点的快捷方式\n\n```js\nfunction createElement (type, props, children) {\n  return new Element(type, props, children)\n}\n```\n\n既然有了创建方法， 那现在就可以试着创建几个dom了， \n```js\nlet virtualDom1 = createElement(\"ul\", {\n  class: \"list\"\n}, [\n  createElement(\"li\", { class: \"item\"}, [\"1\"]),\n  createElement(\"li\", { class: \"item\"}, [\"2\"]),\n  createElement(\"li\", { class: \"item\"}, [\"3\"])\n])\n\nlet virtualDom2 = createElement(\"ul\", {\n  class: \"list-new\"\n}, [\n  createElement(\"li\", { class: \"item\"}, [\"a\"]),\n  createElement(\"li\", { class: \"item\"}, [\"444\"]),\n  createElement(\"li\", { class: \"item\"}, [\"c\"])\n])\n```\n\n这是两串模拟`ul > li`的代码， 相信聪明的你可以看的出来\n\n\n### 对比差异\n既然构建好了简单的虚拟dom， 接下来要做的无非就是比对了\n\n在对比差异的过程中， 我们还要记录最终的差异结果， 把当前修复批次记录下来， 用于之后同一处理\n\n开始比对之前， 我们要先搞清楚整体的逻辑， 我们应该比对哪些差异？\n\n1. 标签类型的差异， 有可能是`p`， 有可能是`div`， 还有可能是纯文本\n2. dom的属性改变了 ， 有可能是class变了， 有可能是自定义属性变了\n3. dom的内容改变了， 这就是最基本的变化了， dom的内容发生了改变\n\n\n```js\n\nimport _ from './util.js'\n// 生成的补丁包\nlet patchs = {}\n// 记录\nlet globalIndex = 0\n\n// dom-diff的主要入口函数\nfunction diff(oldTree, newTree) {\n  dfswalk(oldTree, newTree, globalIndex)\n  return patchs\n}\n// 深度优先遍历 -- 递归\nfunction dfswalk(oldTree, newTree, globalIndex){\n  // 记录当前批次的修改队列\n  let currentPatchs = []\n  // 如果旧节点是文本\n  if( _.isString(oldTree) ) {\n    // 如果新树也是字符串 并且 但是不和新树相同\n    if(_.isString(newTree) && oldTree !== newTree) {\n      // 将当前的更改追加入当前需要修改的队列中\n      currentPatchs.push({\n        type: \"TEXT\",\n        text: newTree\n      })\n    }\n\n    // 如果类型相同的\n  } else if( oldTree.type === newTree.type ) {\n    // 调用对比属性的函数\n    diffProps(oldTree.props, newTree.props)\n    // 比节点 => 尾调用优化\n    diffChildren(oldTree.children, newTree.children)\n  }\n  // 如果本次检测到了修改 把每一次diff的结果放到patchs\n  if(currentPatchs.length > 0) {\n    // 记录到对应的节点上sdcxz\n    patchs[globalIndex] = currentPatchs\n  }\n}\n\n// 对比两个dom的 属性\nfunction diffProps() {\n  // 对比props\n\n}\n// 负责循环新旧domde的子节点， 以旧节点的索引去匹配去匹配相应位置的新节点\nfunction diffChildren(oldChildrens, newChildrens) {\n  // 遍历旧dom ,对比相同索引的新dom\n  oldChildrens.forEach((child, index) => {\n    // 被循环后又去调用新旧dom的比对\n    dfswalk(child, newChildrens[index], ++globalIndex)\n  })\n}\n\n\n\nexport {\n  diff\n}\n\n\n```\n\n\n\n\n## Vue 对dom-diff的优化\n\nvue 在对比 oldTree 和 newTree 时会分别给新旧树的对比中会分配两个指针，分别是`oldStart`、`oldEnd` 、 `newStart`、`newEnd` ， 然后 start 指针和 end 指针都会在每次对比后相互靠近， 直至相遇， 具体对比规则如下\n\n![2019-06-29-21-05-31](http://img.nixiaolei.com/2019-06-29-21-05-31.png)\n\n\n\n1. 先对比头头、 尾尾是否一致\n2. 对比头尾、 尾头， 如果相同，则头尾先互相拷贝插入， 然后删除旧的\n3. 如果 `newStart` 和 `oldStart` 相对比， `newStart`有但`oldStart`没有此节点， 则将 `newStart` 对应的节点插入至 `oldStart`节点的前面， 并且将 `newStart`指针前进一格， 而`oldStart`指针不动， 直至找到匹配\n![2019-06-29-20-58-31](http://img.nixiaolei.com/2019-06-29-20-58-31.png)\n4. 如果`oldEnd` 和 newEnd 不同时， 则将oldEnd 的元素先打上删除标记， 然后前进一格，  newEnd 元素则停留在原处，直至找到匹配\n![2019-06-29-21-22-26](http://img.nixiaolei.com/2019-06-29-21-22-26.png)\n5. 对比阶段， 对比类型， 如果类型不同就直接放弃没必要继续对比了\n\n\n最终start 与 end 交汇后， 遍历一遍 oldTree ,将标记为删除的节点删除掉\n\n\n### Vue 为什么需要key\n首先， 如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。\n\n并且， diff算法就可以快速切正确的找到此节点， 找到正确的位置插入新的节点，\n\n降低节点查找时间， 当有插入节点需要时， 有Key 的话就可以 类似于索引访问的形式直达目标节点，  而不是遍历一遍所有节点来查找目标节点\n\n\n**利用key的小技巧**\n它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:\n\n完整地触发组件的生命周期钩子\n触发过渡\n\n```Vue\n<transition>\n  <span :key=\"text\">{{ text }}</span>\n</transition>\n```\n\n\n**总结**\n\nkey是为了降低diff时的节点查找复杂度， 并且如果节点的key都不相同或者是说key都变了，那就直接判定为dom发生变化， 渲染新的","source":"_posts/【算法】理解Dom-diff.md","raw":"---\ntitle: 【算法】理解Dom-diff\ndate: 2019-06-23 21:48:48\ncategories: 算法\ntags: DomDiff\n---\n\n\n## 算法复杂度\n比较两棵DOM树的差异是 Virtual Dom 算法最核心的部分， 这也是所谓的Virtual Dom的 diff算法。 两个树的完全的diff算法是一个时间复杂度为 O（n^3） 的问题。 但是在前端当中， 你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比。 下面的div指挥和同一层级的div对比， 第二层级的智慧跟第二层级对比。 这样算法复杂度就可以达到O(n)。\n\n\n![2019-06-23-21-55-03](http://img.nixiaolei.com/2019-06-23-21-55-03.png)\n\n\n## 对比方式\n实际的代码中， 会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记， 在深度优先遍历的时候， 每遍历到一个节点就把该节点和新的树进行对比。 如果有差异的话就记录到一个对象里面。\n\n\n![2019-06-23-21-57-26](http://img.nixiaolei.com/2019-06-23-21-57-26.png)\n\n\n\n\n## 实践一下\n\n所谓的`dom-diff` 抛去具体的dom处理逻辑， 其核心思想还是比较简单的， 其实就是一个深度优先遍历。\n\n我们就来尝试实现一下一个简单的dom-diff\n\n首先\n### 模拟dom结构\n以面向对象的编程方式， 构建出一个dom节点所必要的属性\n\n```js\nclass Element {\n  constructor(type, props, children) {\n    this.type = type\n    this.props = props\n    this.children = children\n  }\n}\n```\n\n然后我们再实现一个创建虚拟dom节点的快捷方式\n\n```js\nfunction createElement (type, props, children) {\n  return new Element(type, props, children)\n}\n```\n\n既然有了创建方法， 那现在就可以试着创建几个dom了， \n```js\nlet virtualDom1 = createElement(\"ul\", {\n  class: \"list\"\n}, [\n  createElement(\"li\", { class: \"item\"}, [\"1\"]),\n  createElement(\"li\", { class: \"item\"}, [\"2\"]),\n  createElement(\"li\", { class: \"item\"}, [\"3\"])\n])\n\nlet virtualDom2 = createElement(\"ul\", {\n  class: \"list-new\"\n}, [\n  createElement(\"li\", { class: \"item\"}, [\"a\"]),\n  createElement(\"li\", { class: \"item\"}, [\"444\"]),\n  createElement(\"li\", { class: \"item\"}, [\"c\"])\n])\n```\n\n这是两串模拟`ul > li`的代码， 相信聪明的你可以看的出来\n\n\n### 对比差异\n既然构建好了简单的虚拟dom， 接下来要做的无非就是比对了\n\n在对比差异的过程中， 我们还要记录最终的差异结果， 把当前修复批次记录下来， 用于之后同一处理\n\n开始比对之前， 我们要先搞清楚整体的逻辑， 我们应该比对哪些差异？\n\n1. 标签类型的差异， 有可能是`p`， 有可能是`div`， 还有可能是纯文本\n2. dom的属性改变了 ， 有可能是class变了， 有可能是自定义属性变了\n3. dom的内容改变了， 这就是最基本的变化了， dom的内容发生了改变\n\n\n```js\n\nimport _ from './util.js'\n// 生成的补丁包\nlet patchs = {}\n// 记录\nlet globalIndex = 0\n\n// dom-diff的主要入口函数\nfunction diff(oldTree, newTree) {\n  dfswalk(oldTree, newTree, globalIndex)\n  return patchs\n}\n// 深度优先遍历 -- 递归\nfunction dfswalk(oldTree, newTree, globalIndex){\n  // 记录当前批次的修改队列\n  let currentPatchs = []\n  // 如果旧节点是文本\n  if( _.isString(oldTree) ) {\n    // 如果新树也是字符串 并且 但是不和新树相同\n    if(_.isString(newTree) && oldTree !== newTree) {\n      // 将当前的更改追加入当前需要修改的队列中\n      currentPatchs.push({\n        type: \"TEXT\",\n        text: newTree\n      })\n    }\n\n    // 如果类型相同的\n  } else if( oldTree.type === newTree.type ) {\n    // 调用对比属性的函数\n    diffProps(oldTree.props, newTree.props)\n    // 比节点 => 尾调用优化\n    diffChildren(oldTree.children, newTree.children)\n  }\n  // 如果本次检测到了修改 把每一次diff的结果放到patchs\n  if(currentPatchs.length > 0) {\n    // 记录到对应的节点上sdcxz\n    patchs[globalIndex] = currentPatchs\n  }\n}\n\n// 对比两个dom的 属性\nfunction diffProps() {\n  // 对比props\n\n}\n// 负责循环新旧domde的子节点， 以旧节点的索引去匹配去匹配相应位置的新节点\nfunction diffChildren(oldChildrens, newChildrens) {\n  // 遍历旧dom ,对比相同索引的新dom\n  oldChildrens.forEach((child, index) => {\n    // 被循环后又去调用新旧dom的比对\n    dfswalk(child, newChildrens[index], ++globalIndex)\n  })\n}\n\n\n\nexport {\n  diff\n}\n\n\n```\n\n\n\n\n## Vue 对dom-diff的优化\n\nvue 在对比 oldTree 和 newTree 时会分别给新旧树的对比中会分配两个指针，分别是`oldStart`、`oldEnd` 、 `newStart`、`newEnd` ， 然后 start 指针和 end 指针都会在每次对比后相互靠近， 直至相遇， 具体对比规则如下\n\n![2019-06-29-21-05-31](http://img.nixiaolei.com/2019-06-29-21-05-31.png)\n\n\n\n1. 先对比头头、 尾尾是否一致\n2. 对比头尾、 尾头， 如果相同，则头尾先互相拷贝插入， 然后删除旧的\n3. 如果 `newStart` 和 `oldStart` 相对比， `newStart`有但`oldStart`没有此节点， 则将 `newStart` 对应的节点插入至 `oldStart`节点的前面， 并且将 `newStart`指针前进一格， 而`oldStart`指针不动， 直至找到匹配\n![2019-06-29-20-58-31](http://img.nixiaolei.com/2019-06-29-20-58-31.png)\n4. 如果`oldEnd` 和 newEnd 不同时， 则将oldEnd 的元素先打上删除标记， 然后前进一格，  newEnd 元素则停留在原处，直至找到匹配\n![2019-06-29-21-22-26](http://img.nixiaolei.com/2019-06-29-21-22-26.png)\n5. 对比阶段， 对比类型， 如果类型不同就直接放弃没必要继续对比了\n\n\n最终start 与 end 交汇后， 遍历一遍 oldTree ,将标记为删除的节点删除掉\n\n\n### Vue 为什么需要key\n首先， 如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。\n\n并且， diff算法就可以快速切正确的找到此节点， 找到正确的位置插入新的节点，\n\n降低节点查找时间， 当有插入节点需要时， 有Key 的话就可以 类似于索引访问的形式直达目标节点，  而不是遍历一遍所有节点来查找目标节点\n\n\n**利用key的小技巧**\n它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:\n\n完整地触发组件的生命周期钩子\n触发过渡\n\n```Vue\n<transition>\n  <span :key=\"text\">{{ text }}</span>\n</transition>\n```\n\n\n**总结**\n\nkey是为了降低diff时的节点查找复杂度， 并且如果节点的key都不相同或者是说key都变了，那就直接判定为dom发生变化， 渲染新的","slug":"【算法】理解Dom-diff","published":1,"updated":"2019-09-09T16:57:46.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uh006oaas6gvb46viy"},{"title":"【算法】递归算法","date":"2019-06-08T15:42:35.000Z","_content":"\n\n* 核心思想：通过重复将问题分解为同类的子问题而解决问题的方法。\n* 特点：\n  * 函数可以通过调用自身来进行递归\n  * 递归可以完全取代循环\n* 递归由下面两部分组成：\n  * （1）递归主体，就是要循环解决问题的代码\n  * （2）递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【算法】递归算法.md","raw":"---\ntitle: 【算法】递归算法\ndate: 2019-06-08 23:42:35\ncategories: 算法\ntags: 算法\n---\n\n\n* 核心思想：通过重复将问题分解为同类的子问题而解决问题的方法。\n* 特点：\n  * 函数可以通过调用自身来进行递归\n  * 递归可以完全取代循环\n* 递归由下面两部分组成：\n  * （1）递归主体，就是要循环解决问题的代码\n  * （2）递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【算法】递归算法","published":1,"updated":"2019-09-09T16:57:46.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ui006raas6ufx9xe0t"},{"title":"【英语学习】基础语法","date":"2019-06-22T15:00:00.000Z","_content":"\n\n英语语法分为：\n1. 句法部分\n2. 语法部分\n\n## 句法部分\n十大词类、 两大句型、八大句子成分、主从句单复词\n\n### 词类\n> 名词、 动词、形容词、副词、数词、代词、语气词、感叹词、 介词、 连词\n\n1. 名词\n> 事物的名称叫名词\n\n万事万物--实体， 非实体都有其名\n\n2. 动词\n> 动作的名称就叫动词\n\n表示事物之间的变化或自身内在的变化的词就是动词。\n\n3. 形容词\n> 形容名词的词， 叫形容词\n\n名词太单调了， 需要形容词围绕名词进行各种修饰， 如形状、色彩、大小、美丑等。\n\n4. 副词\n> 形容动词的词， 就叫副词\n\n动词太单调了， 需要副词围绕动词进行各种修饰， 如描绘动作的程度、 频率、 方式、 时间等\n\n5. 数次\n> 给名词计数的词， 就叫数词\n\n分为基数词， 1、2、3、4、5 第1、第2、第3、第4、第5等\n\n6. 代词\n> 代替名词的词就叫代词\n\n如： 你、我、她、它、你们的、 我们的、他们的等等\n\n7. 介词\n> 表示两个名词之间时空关系的词， 就叫介词\n\n如 \"鸡蛋在(in)篮子里\" \"鸡蛋在(on)桌子上\" \"鸡蛋在(under)桌子下\"\n\n\n8. 冠词\n> 特指或泛指某一名词事物的就叫冠词\n\n如： a/an不定冠词， the 定冠词\n\n9. 连词\n> 连接两个性质相同的词、 短句、 句子的词叫连词\n\n10. 叹词\n语气助词叫叹词\n\n\n这十大词类又可以分为\n\n`名词类`， 即以名词为核心的词类。\n  如： 名词、 代词、 形容词、 数词、 冠词、介词\n\n和`动词类`: \n  如:  动词、 副词\n\n\n### 动词原形\n> 动词原形是不含有`时间信息`也不含有`状态信息`的动词的本源， 是脱离了时空概念的动作本身。\n\n下图中， 中间这个`eat` 就是动词原形\n![2019-06-23-00-19-37](http://img.nixiaolei.com/2019-06-23-00-19-37.png)\n\n这就像一粒种子可以变换为4种状态\n\n1. 非谓语动词\n有状态但是没有时间\n\n2. 谓语动词\n有时间有状态\n\n一句话解释:\n> 如果以人作为比喻， 那么动词原形是受精卵， 非谓语动词是胎儿\n\n动词原形只是个概念， 它不能出现于任何句子， 任何短语之中， 动词原形只能作为词典条目\n\n\n### 动词有什么“态”\n> 动词的“态”就是动作发展的“阶段”\n\n![2019-06-23-11-36-32](http://img.nixiaolei.com/2019-06-23-11-36-32.png)\n\n![2019-06-23-11-45-28](http://img.nixiaolei.com/2019-06-23-11-45-28.png)\n\n\n\n动词原形穿上“态”这件衣服就成了非谓语动词\n\n**给非谓语动词穿上时态这件衣服**\n\n![2019-06-23-11-48-52](http://img.nixiaolei.com/2019-06-23-11-48-52.png)\n\n\n### 谓语动词\n英语的谓语动词， 第一个词一定表达时间， 最后一个词一定表达状态，\n\n如:`is eating`， `is`就是时间， `eating` 就是状态\n\n## 语法部分\n谓语动词的变化、 非谓语动词的变化\n\n\n\n\n## 时态\n\n英语到底有多少种时态\n\n![2019-06-23-18-23-07](http://img.nixiaolei.com/2019-06-23-18-23-07.png)\n\n\n\n\n\n","source":"_posts/【英语学习】基础语法.md","raw":"---\ntitle: 【英语学习】基础语法\ndate: 2019-06-22 23:00:00\ncategories: 英语\ntags: 英语语法\n---\n\n\n英语语法分为：\n1. 句法部分\n2. 语法部分\n\n## 句法部分\n十大词类、 两大句型、八大句子成分、主从句单复词\n\n### 词类\n> 名词、 动词、形容词、副词、数词、代词、语气词、感叹词、 介词、 连词\n\n1. 名词\n> 事物的名称叫名词\n\n万事万物--实体， 非实体都有其名\n\n2. 动词\n> 动作的名称就叫动词\n\n表示事物之间的变化或自身内在的变化的词就是动词。\n\n3. 形容词\n> 形容名词的词， 叫形容词\n\n名词太单调了， 需要形容词围绕名词进行各种修饰， 如形状、色彩、大小、美丑等。\n\n4. 副词\n> 形容动词的词， 就叫副词\n\n动词太单调了， 需要副词围绕动词进行各种修饰， 如描绘动作的程度、 频率、 方式、 时间等\n\n5. 数次\n> 给名词计数的词， 就叫数词\n\n分为基数词， 1、2、3、4、5 第1、第2、第3、第4、第5等\n\n6. 代词\n> 代替名词的词就叫代词\n\n如： 你、我、她、它、你们的、 我们的、他们的等等\n\n7. 介词\n> 表示两个名词之间时空关系的词， 就叫介词\n\n如 \"鸡蛋在(in)篮子里\" \"鸡蛋在(on)桌子上\" \"鸡蛋在(under)桌子下\"\n\n\n8. 冠词\n> 特指或泛指某一名词事物的就叫冠词\n\n如： a/an不定冠词， the 定冠词\n\n9. 连词\n> 连接两个性质相同的词、 短句、 句子的词叫连词\n\n10. 叹词\n语气助词叫叹词\n\n\n这十大词类又可以分为\n\n`名词类`， 即以名词为核心的词类。\n  如： 名词、 代词、 形容词、 数词、 冠词、介词\n\n和`动词类`: \n  如:  动词、 副词\n\n\n### 动词原形\n> 动词原形是不含有`时间信息`也不含有`状态信息`的动词的本源， 是脱离了时空概念的动作本身。\n\n下图中， 中间这个`eat` 就是动词原形\n![2019-06-23-00-19-37](http://img.nixiaolei.com/2019-06-23-00-19-37.png)\n\n这就像一粒种子可以变换为4种状态\n\n1. 非谓语动词\n有状态但是没有时间\n\n2. 谓语动词\n有时间有状态\n\n一句话解释:\n> 如果以人作为比喻， 那么动词原形是受精卵， 非谓语动词是胎儿\n\n动词原形只是个概念， 它不能出现于任何句子， 任何短语之中， 动词原形只能作为词典条目\n\n\n### 动词有什么“态”\n> 动词的“态”就是动作发展的“阶段”\n\n![2019-06-23-11-36-32](http://img.nixiaolei.com/2019-06-23-11-36-32.png)\n\n![2019-06-23-11-45-28](http://img.nixiaolei.com/2019-06-23-11-45-28.png)\n\n\n\n动词原形穿上“态”这件衣服就成了非谓语动词\n\n**给非谓语动词穿上时态这件衣服**\n\n![2019-06-23-11-48-52](http://img.nixiaolei.com/2019-06-23-11-48-52.png)\n\n\n### 谓语动词\n英语的谓语动词， 第一个词一定表达时间， 最后一个词一定表达状态，\n\n如:`is eating`， `is`就是时间， `eating` 就是状态\n\n## 语法部分\n谓语动词的变化、 非谓语动词的变化\n\n\n\n\n## 时态\n\n英语到底有多少种时态\n\n![2019-06-23-18-23-07](http://img.nixiaolei.com/2019-06-23-18-23-07.png)\n\n\n\n\n\n","slug":"【英语学习】基础语法","published":1,"updated":"2019-09-09T16:57:46.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ui006vaas6m31pdq8p"},{"title":"【记录】a 标签下载视频却跳去播放的问题","date":"2019-09-10T12:04:23.000Z","_content":"\n明明写了  a 标签， 也加了 download属性， 但是还是跳去播放视频了， 原来，如果想下载视频， 你得在 a 标签的视频链接地址后面带个参数`?filename=xxx`\n\n比如:\n\n```\nwww.aaa.com/video?filename=xxx\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【记录】a-标签下载视频却跳去播放的问题.md","raw":"---\ntitle: 【记录】a 标签下载视频却跳去播放的问题\ndate: 2019-09-10 20:04:23\ncategories: 记录\ntags: 记录\n---\n\n明明写了  a 标签， 也加了 download属性， 但是还是跳去播放视频了， 原来，如果想下载视频， 你得在 a 标签的视频链接地址后面带个参数`?filename=xxx`\n\n比如:\n\n```\nwww.aaa.com/video?filename=xxx\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【记录】a-标签下载视频却跳去播放的问题","published":1,"updated":"2019-09-10T12:17:56.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uj006xaas6a56x5jen"},{"title":"【记录】ios无法播放部分mp4视频怎么办","date":"2019-09-10T12:06:10.000Z","_content":"\n今天遇到了， 安卓可以播放某个mp4视频，但是ios就是无法播放\n\n抓耳挠腮半天， 才得知， 原来是视频的压缩级别的问题，ios对 mp4的压缩级别支持有限， \n\n最后我转成`MPEG-4`编码格式， 完美运行（当然其他的编码格式也行， 我只是随便使用了下）\n\nmac可以使用`handBreak`转一下\n\n\n参考文档\n> https://www.jianshu.com/p/31f0593496ef\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【记录】ios无法播放部分mp4视频怎么办.md","raw":"---\ntitle: 【记录】ios无法播放部分mp4视频怎么办\ndate: 2019-09-10 20:06:10\ncategories: 记录\ntags: 记录\n---\n\n今天遇到了， 安卓可以播放某个mp4视频，但是ios就是无法播放\n\n抓耳挠腮半天， 才得知， 原来是视频的压缩级别的问题，ios对 mp4的压缩级别支持有限， \n\n最后我转成`MPEG-4`编码格式， 完美运行（当然其他的编码格式也行， 我只是随便使用了下）\n\nmac可以使用`handBreak`转一下\n\n\n参考文档\n> https://www.jianshu.com/p/31f0593496ef\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【记录】ios无法播放部分mp4视频怎么办","published":1,"updated":"2019-09-10T12:14:06.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ul0071aas61jljp47l"},{"title":"【记录】mac 下 ssh 连接gitHub死活不成功的问题","date":"2019-09-10T12:02:30.000Z","_content":"\n\n当我想要克隆一个项目时， 出了点小意外， 使用https 使用非常顺畅， 但是换成 ssh的方式就出问题了。死活行不通\n\ngit clone  一直提示这样的错误\n```\nCloning into 'xxx'...\nzsh:1: command not found: connect\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n```\n\n或是这样的错误:\n```\nCloning into 'xxx'\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n\n\n不止配置了一遍gitHub 的 `ssh key` 敢确信绝对没问题， 寻遍整个互联网依旧没有找到答案.\n\n\n\n\n后来我发现原因时因为： 我创建的 ssh公钥没有被系统所使用, 因为默认只有is_rsa, 如果你自定义了那就需要添加\n\n需要添加一下你创建的公钥， 告诉系统可以使用\n\n```\nssh-add -K ~/.ssh/你的ssh key名称(不带.pub)\n```\n\n比如：\n```\nssh-add -K ~/.ssh/github_rsa\n```\n\n\n于是， clone 顺利\n\n\n附上创建密钥的命令:\n> ssh-keygen -t rsa -C \"your_email@youremail.com\"\n\n\n\n\n参考文献:\n> http://shinancao.cn/2016/12/18/Programming-Git-1/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【记录】mac-下-ssh-连接gitHub死活不成功的问题.md","raw":"---\ntitle: 【记录】mac 下 ssh 连接gitHub死活不成功的问题\ndate: 2019-09-10 20:02:30\ncategories: 记录\ntags: 记录\n---\n\n\n当我想要克隆一个项目时， 出了点小意外， 使用https 使用非常顺畅， 但是换成 ssh的方式就出问题了。死活行不通\n\ngit clone  一直提示这样的错误\n```\nCloning into 'xxx'...\nzsh:1: command not found: connect\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n```\n\n或是这样的错误:\n```\nCloning into 'xxx'\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n\n\n不止配置了一遍gitHub 的 `ssh key` 敢确信绝对没问题， 寻遍整个互联网依旧没有找到答案.\n\n\n\n\n后来我发现原因时因为： 我创建的 ssh公钥没有被系统所使用, 因为默认只有is_rsa, 如果你自定义了那就需要添加\n\n需要添加一下你创建的公钥， 告诉系统可以使用\n\n```\nssh-add -K ~/.ssh/你的ssh key名称(不带.pub)\n```\n\n比如：\n```\nssh-add -K ~/.ssh/github_rsa\n```\n\n\n于是， clone 顺利\n\n\n附上创建密钥的命令:\n> ssh-keygen -t rsa -C \"your_email@youremail.com\"\n\n\n\n\n参考文献:\n> http://shinancao.cn/2016/12/18/Programming-Git-1/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【记录】mac-下-ssh-连接gitHub死活不成功的问题","published":1,"updated":"2019-09-10T12:18:01.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4un0073aas6w8qqfvfv"},{"title":"【记录】jest进行单元测试时提示router-view 未注册报错了","date":"2019-09-10T11:56:36.000Z","_content":"\n\n\n当我想要克隆一个项目时， 出了点小意外， 使用https 使用非常顺畅， 但是换成 ssh的方式就出问题了。死活行不通\n\ngit clone  一直提示这样的错误\n```\nCloning into 'xxx'...\nzsh:1: command not found: connect\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n```\n\n或是这样的错误:\n```\nCloning into 'xxx'\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n\n\n不止配置了一遍gitHub 的 `ssh key` 敢确信绝对没问题， 寻遍整个互联网依旧没有找到答案.\n\n\n\n\n后来我发现原因时因为： 我创建的 ssh公钥没有被系统所使用, 因为默认只有is_rsa, 如果你自定义了那就需要添加\n\n需要添加一下你创建的公钥， 告诉系统可以使用\n\n```\nssh-add -K ~/.ssh/你的ssh key名称(不带.pub)\n```\n\n比如：\n```\nssh-add -K ~/.ssh/github_rsa\n```\n\n\n于是， clone 顺利\n\n\n附上创建密钥的命令:\n> ssh-keygen -t rsa -C \"your_email@youremail.com\"\n\n\n\n\n参考文献:\n> http://shinancao.cn/2016/12/18/Programming-Git-1/\n\n\n\n\n\n\n\n\n\n","source":"_posts/【记录】jest进行单元测试时提示router-view-未注册报错了.md","raw":"---\ntitle: 【记录】jest进行单元测试时提示router-view 未注册报错了\ndate: 2019-09-10 19:56:36\ncategories: 记录\ntags: 记录\n---\n\n\n\n当我想要克隆一个项目时， 出了点小意外， 使用https 使用非常顺畅， 但是换成 ssh的方式就出问题了。死活行不通\n\ngit clone  一直提示这样的错误\n```\nCloning into 'xxx'...\nzsh:1: command not found: connect\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n```\n\n或是这样的错误:\n```\nCloning into 'xxx'\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n\n\n不止配置了一遍gitHub 的 `ssh key` 敢确信绝对没问题， 寻遍整个互联网依旧没有找到答案.\n\n\n\n\n后来我发现原因时因为： 我创建的 ssh公钥没有被系统所使用, 因为默认只有is_rsa, 如果你自定义了那就需要添加\n\n需要添加一下你创建的公钥， 告诉系统可以使用\n\n```\nssh-add -K ~/.ssh/你的ssh key名称(不带.pub)\n```\n\n比如：\n```\nssh-add -K ~/.ssh/github_rsa\n```\n\n\n于是， clone 顺利\n\n\n附上创建密钥的命令:\n> ssh-keygen -t rsa -C \"your_email@youremail.com\"\n\n\n\n\n参考文献:\n> http://shinancao.cn/2016/12/18/Programming-Git-1/\n\n\n\n\n\n\n\n\n\n","slug":"【记录】jest进行单元测试时提示router-view-未注册报错了","published":1,"updated":"2019-09-10T12:17:49.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4un0076aas6r5tbgrgk"},{"title":"【记录】webpack + ts + antd 按需加载无效处理","date":"2019-05-09T16:15:41.000Z","_content":"\n\nwebpack加 babel 本来搭配 babel-plugin-import 可以实现插件的按需引入， 但是时代在变化啊， 现在流行ts 了， 你一定会想在你的项目中加入它， 你也一定会搜索到 ‘ts-loader’ 的种种，  但效果不尽如人意， 使用了'ts-loader' 之后， 你会发现， 按需引入怎么配置都失败了，\n\n于是你一定会尝试这样\n```\n{\n    test: /\\.tsx?$/,\n    exclude: /node_modules/,\n    use: [\n        loader: 'babel-loader',\n        loader: 'ts-loader',\n    ]\n}\n```\n\n先把ts 转成 es6, 然后用`babel`把ES6 转为 es5\n\n但现在不是那种上古洪荒时代了， babel 统一添加， 让我们可以不需要在编译两轮了\n\n\n在 babel 7 中，我们使用新的 @babel/preset-typescript (其集成了 @babel/plugin-transform-typescript)\n\n我们的 .babelrc 配置将变成这样：\n\n```\n{\n  \"presets\": [\n    \"@babel/env\",\n    \"@babel/react\",\n    \"@babel/typescript\"\n  ]\n}\n```\n\n\n参考地址:\n> https://github.com/frontend9/fe9-library/issues/23\n\n> https://www.jishuwen.com/d/2MbR/zh-tw\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【记录】webpack-ts-antd-按需加载无效处理.md","raw":"---\ntitle: 【记录】webpack + ts + antd 按需加载无效处理\ndate: 2019-05-10 00:15:41\ncategories: 记录\ntags: 记录\n---\n\n\nwebpack加 babel 本来搭配 babel-plugin-import 可以实现插件的按需引入， 但是时代在变化啊， 现在流行ts 了， 你一定会想在你的项目中加入它， 你也一定会搜索到 ‘ts-loader’ 的种种，  但效果不尽如人意， 使用了'ts-loader' 之后， 你会发现， 按需引入怎么配置都失败了，\n\n于是你一定会尝试这样\n```\n{\n    test: /\\.tsx?$/,\n    exclude: /node_modules/,\n    use: [\n        loader: 'babel-loader',\n        loader: 'ts-loader',\n    ]\n}\n```\n\n先把ts 转成 es6, 然后用`babel`把ES6 转为 es5\n\n但现在不是那种上古洪荒时代了， babel 统一添加， 让我们可以不需要在编译两轮了\n\n\n在 babel 7 中，我们使用新的 @babel/preset-typescript (其集成了 @babel/plugin-transform-typescript)\n\n我们的 .babelrc 配置将变成这样：\n\n```\n{\n  \"presets\": [\n    \"@babel/env\",\n    \"@babel/react\",\n    \"@babel/typescript\"\n  ]\n}\n```\n\n\n参考地址:\n> https://github.com/frontend9/fe9-library/issues/23\n\n> https://www.jishuwen.com/d/2MbR/zh-tw\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【记录】webpack-ts-antd-按需加载无效处理","published":1,"updated":"2019-09-10T12:18:06.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uo0078aas6es2mbd6c"},{"title":"【记录】vue-cli3  jest单元测试报错（不支持ES6)","date":"2019-09-10T12:06:50.000Z","_content":"\n\n在使用公司项目想尝试单元测试的时候， 公司使用的是`jest`, 发现提示了ES6相关的语法错误提示， 网上百度好多， 各种尝试依旧未能解决\n\n\n最后的解决办法: \n\n用vue-cli3 重新创建了一个带单元测试的项目， 然后发现运行成功， 于是把该项目的单元测试相关依赖版本拷贝到公司项目里， 于是公司项目成功运行 ， ✌️\n\n\n\n最后发现只需要把 `babel-jest`版本降一下就可以了，\n![2019-09-11-11-08-34](http://img.nixiaolei.com/2019-09-11-11-08-34.png)\n\n\n```\n\"babel-jest\": \"^23.6.0\",\n```\n\n如果不生效记得把 package.lock文件删了\n\n\n\n\n\n\n","source":"_posts/【记录】vue-cli3-jest单元测试报错（不支持ES6.md","raw":"---\ntitle: 【记录】vue-cli3  jest单元测试报错（不支持ES6)\ndate: 2019-09-10 20:06:50\ncategories: 记录\ntags: 记录\n---\n\n\n在使用公司项目想尝试单元测试的时候， 公司使用的是`jest`, 发现提示了ES6相关的语法错误提示， 网上百度好多， 各种尝试依旧未能解决\n\n\n最后的解决办法: \n\n用vue-cli3 重新创建了一个带单元测试的项目， 然后发现运行成功， 于是把该项目的单元测试相关依赖版本拷贝到公司项目里， 于是公司项目成功运行 ， ✌️\n\n\n\n最后发现只需要把 `babel-jest`版本降一下就可以了，\n![2019-09-11-11-08-34](http://img.nixiaolei.com/2019-09-11-11-08-34.png)\n\n\n```\n\"babel-jest\": \"^23.6.0\",\n```\n\n如果不生效记得把 package.lock文件删了\n\n\n\n\n\n\n","slug":"【记录】vue-cli3-jest单元测试报错（不支持ES6","published":1,"updated":"2019-09-11T03:09:32.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4up007caas65dgd6ppq"},{"title":"了解汇编语言","date":"2019-03-24T05:02:22.000Z","_content":"\n* 汇编语言是最贴近底层的计算机语言\n* 汇编语言是直接操作硬件的，没有任何抽象\n* 汇编语言由指令与数据组成，没有任何语句\n* 汇编指令受到硬件平台限制，可移植性很低\n* 了解一些底层语言知识，对理解计算机的运作机制和内存管理大有好处\n\n\n\n\n## 体验一下汇编语言\n\n来看一下一个简单的汇编语言代码， 这段代码只是为了输出一个\"hello world\"\n\n![Helloworld](http://img.nixiaolei.com/2019-04-06-13-07-06.png)\n\n\n\n\n上面部分也就是程序的数据段:\n![代码段](http://img.nixiaolei.com/2019-04-06-13-10-58.png)\n\n下面这部分是程序的代码段:\n![数据段](http://img.nixiaolei.com/2019-04-06-13-11-29.png)\n\n代码段和数据段是严格分开的， \n\n汇编语言最原始的方式是：当这段代码转换为机器指令后， 数据和代码是相邻在一起的.\n\n![存储结构](http://img.nixiaolei.com/2019-04-06-13-13-58.png)\n\n\n但其实放在一起是不太安全的！\n\n\n\n现代计算机的做法是， 将代码段和数据段严格区分开来， 如果越界，在数据段的地方取代码， 操作系统就会给你抛出错误， 也就是经典的`蓝屏`\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/了解汇编语言.md","raw":"---\ntitle: 了解汇编语言\ndate: 2019-03-24 13:02:22\ncategories: 计算机基础\ntags: [计算机基础, 汇编]\n---\n\n* 汇编语言是最贴近底层的计算机语言\n* 汇编语言是直接操作硬件的，没有任何抽象\n* 汇编语言由指令与数据组成，没有任何语句\n* 汇编指令受到硬件平台限制，可移植性很低\n* 了解一些底层语言知识，对理解计算机的运作机制和内存管理大有好处\n\n\n\n\n## 体验一下汇编语言\n\n来看一下一个简单的汇编语言代码， 这段代码只是为了输出一个\"hello world\"\n\n![Helloworld](http://img.nixiaolei.com/2019-04-06-13-07-06.png)\n\n\n\n\n上面部分也就是程序的数据段:\n![代码段](http://img.nixiaolei.com/2019-04-06-13-10-58.png)\n\n下面这部分是程序的代码段:\n![数据段](http://img.nixiaolei.com/2019-04-06-13-11-29.png)\n\n代码段和数据段是严格分开的， \n\n汇编语言最原始的方式是：当这段代码转换为机器指令后， 数据和代码是相邻在一起的.\n\n![存储结构](http://img.nixiaolei.com/2019-04-06-13-13-58.png)\n\n\n但其实放在一起是不太安全的！\n\n\n\n现代计算机的做法是， 将代码段和数据段严格区分开来， 如果越界，在数据段的地方取代码， 操作系统就会给你抛出错误， 也就是经典的`蓝屏`\n\n\n\n\n\n\n\n\n\n\n\n","slug":"了解汇编语言","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uq007faas608ezxey3"},{"title":"了解CPU工作原理","date":"2019-04-01T14:40:26.000Z","_content":"\n计算机在被发明出来之后， 结构基本上没有怎么改变， 目前使用最广泛的结构是“冯诺依曼结构”\n\n## 冯诺依曼结构\n> [维基百科传送门](https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84)\n\n简单而言的冯诺依曼结构处理器具有以下几个特点:\n\n1. 必须有一个存储器；\n2. 必须有一个控制器；\n3. 必须有一个运算器，用于完成算术运算和逻辑运算；\n4. 必须有输入和输出设备，用于进行人机通信。\n\n![冯诺依曼结构处理器](http://img.nixiaolei.com/2019-04-04-22-51-57.png)\n\n并且还有和冯诺依曼不一样的另一种结构: [哈佛结构](https://zh.wikipedia.org/wiki/%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84)\n\n\n\n## CPU的指令集\n指令集是存储在CPU内部，对CPU运算进行指导和优化的硬程序\n\n说人话:\n指令集就是你驱动`CPU`运算发送的指令\n\n\n\n### x86/x64指令集\n\n这两种是我们目前最普遍的台式机和笔记本的`CPU`种类，\n\n### ARM指令集\n在我们的移动设备上、 智能手表上、只能音响上\n\n### MIPS指令集\n一般用在服务器上， 并且是大型的服务器\n\n### RISC指令集\n这属于一种精简指令， 也可以认为是一种开源的指令集\n\n中国曾经自己研发的芯片 `龙芯`， 还有中国的超级计算机也是使用的这个指令集\n\n\n#### 🌗如何兼容各指令集\n指令集是CPU原生支持的语言，不同的指令集之间是不能互换的，\n\n所以C语言在编译的时候有一种方式叫`交叉编译`：\n\n你在`X64`系列的CPU上去给`ARM`的CPU去编译程序，这就是交叉编译。\n\n这也是做嵌入式的就比较常用这些东西。\n\n## CPU的组成\n\n* 控制器\n* 运算器\n* 存储器\n\n![CPU结构](http://img.nixiaolei.com/2019-04-04-23-02-40.png)\n\n\n### 存储器\n存储器的主要功能是存储程序和各种数据，并能在计算机运行过程中高速、自动地完成程序或数据的存取。\n\n他是CPU上的缓存， 它相当于是我们考试时的`草稿纸`, 在上面写的只是运算过程， 而最终答案是写到答题纸上的(内存)\n\n\n\n### 运算器\n\n算术逻辑运算单元（ALU）的基本功能为加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、求补等操作。\n\n### 控制器\n控制单元又分为： 指令计数器、 指令寄存器\n\n控制负责协调运算器和存储器之间的工作\n\n\n*** \n总之，控制器相当于指挥官, 运算单元相当于士兵， 存储器相当于仓库， \n\n指挥官指挥士兵在存库中搬弹药，做工作\n\n\n## CPU如何与内存沟通\n\n\n\n\n\n\n计算机中的数据分为两种\n1. 代码段 ---- 指令数据（我们写的代码）\n2. 数据段 ---- 纯粹的数据（比如电影文件）\n\n\n代码段和数据段一般是分开存放的， 一定要放一起也不是不可以， 但是很有可能回引起很严重的安全问题-- 缓冲区溢出，看下面的安全问题区域 👇\n\n\n***\n指令计数器从代码段中找出一段指令， 放到指令寄存器中(指令寄存器可以理解为CPU中一块特殊的内存, 但是它只能放指令， 如果存数据就会宕机)， 放到指令寄存器中后， 控制器就开始根据这个指令具体的内容，把数据送入运算器， 数据从哪里来， 控制器通过数据总线从内存中拿到数据然后送入存储单元，供运算器使用\n\n\n\n\n\n\n### 🔥安全问题\n\n#### 🌊 缓冲区溢出\n在代码段插入一些数据， 或是插入一些异常的跳转指令， 本来程序中的跳转是体现在`if``else`或者是`for`循环， 这些跳转语句在计算机底层会被转换成`jmp`指令，从这个地方跳转到另一个地方去执行， 当你跳到另一段代码那， 这段代码就开始执行了，  也就是如果代码是经过精心设计的， 跳转到的目标代码段不是你原本想要的代码段， 而目标代码段要做危险操作， 那就危险大了， 这就是缓冲区溢出。\n\n比如前两年的漏洞： 心脏滴血\n\n\n![如何与内存沟通](http://img.nixiaolei.com/2019-04-06-11-53-40.png)\n\n\n## 经典的8086CPU结构体系\n8086是一种比较早的商业化处理器芯片\n![8086CPU结构](http://img.nixiaolei.com/2019-04-06-12-32-53.png)","source":"_posts/了解CPU工作原理.md","raw":"---\ntitle: 了解CPU工作原理\ndate: 2019-04-01 22:40:26\ncategories: 计算机基础\ntags: [计算机基础, CPU]\n---\n\n计算机在被发明出来之后， 结构基本上没有怎么改变， 目前使用最广泛的结构是“冯诺依曼结构”\n\n## 冯诺依曼结构\n> [维基百科传送门](https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84)\n\n简单而言的冯诺依曼结构处理器具有以下几个特点:\n\n1. 必须有一个存储器；\n2. 必须有一个控制器；\n3. 必须有一个运算器，用于完成算术运算和逻辑运算；\n4. 必须有输入和输出设备，用于进行人机通信。\n\n![冯诺依曼结构处理器](http://img.nixiaolei.com/2019-04-04-22-51-57.png)\n\n并且还有和冯诺依曼不一样的另一种结构: [哈佛结构](https://zh.wikipedia.org/wiki/%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84)\n\n\n\n## CPU的指令集\n指令集是存储在CPU内部，对CPU运算进行指导和优化的硬程序\n\n说人话:\n指令集就是你驱动`CPU`运算发送的指令\n\n\n\n### x86/x64指令集\n\n这两种是我们目前最普遍的台式机和笔记本的`CPU`种类，\n\n### ARM指令集\n在我们的移动设备上、 智能手表上、只能音响上\n\n### MIPS指令集\n一般用在服务器上， 并且是大型的服务器\n\n### RISC指令集\n这属于一种精简指令， 也可以认为是一种开源的指令集\n\n中国曾经自己研发的芯片 `龙芯`， 还有中国的超级计算机也是使用的这个指令集\n\n\n#### 🌗如何兼容各指令集\n指令集是CPU原生支持的语言，不同的指令集之间是不能互换的，\n\n所以C语言在编译的时候有一种方式叫`交叉编译`：\n\n你在`X64`系列的CPU上去给`ARM`的CPU去编译程序，这就是交叉编译。\n\n这也是做嵌入式的就比较常用这些东西。\n\n## CPU的组成\n\n* 控制器\n* 运算器\n* 存储器\n\n![CPU结构](http://img.nixiaolei.com/2019-04-04-23-02-40.png)\n\n\n### 存储器\n存储器的主要功能是存储程序和各种数据，并能在计算机运行过程中高速、自动地完成程序或数据的存取。\n\n他是CPU上的缓存， 它相当于是我们考试时的`草稿纸`, 在上面写的只是运算过程， 而最终答案是写到答题纸上的(内存)\n\n\n\n### 运算器\n\n算术逻辑运算单元（ALU）的基本功能为加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、求补等操作。\n\n### 控制器\n控制单元又分为： 指令计数器、 指令寄存器\n\n控制负责协调运算器和存储器之间的工作\n\n\n*** \n总之，控制器相当于指挥官, 运算单元相当于士兵， 存储器相当于仓库， \n\n指挥官指挥士兵在存库中搬弹药，做工作\n\n\n## CPU如何与内存沟通\n\n\n\n\n\n\n计算机中的数据分为两种\n1. 代码段 ---- 指令数据（我们写的代码）\n2. 数据段 ---- 纯粹的数据（比如电影文件）\n\n\n代码段和数据段一般是分开存放的， 一定要放一起也不是不可以， 但是很有可能回引起很严重的安全问题-- 缓冲区溢出，看下面的安全问题区域 👇\n\n\n***\n指令计数器从代码段中找出一段指令， 放到指令寄存器中(指令寄存器可以理解为CPU中一块特殊的内存, 但是它只能放指令， 如果存数据就会宕机)， 放到指令寄存器中后， 控制器就开始根据这个指令具体的内容，把数据送入运算器， 数据从哪里来， 控制器通过数据总线从内存中拿到数据然后送入存储单元，供运算器使用\n\n\n\n\n\n\n### 🔥安全问题\n\n#### 🌊 缓冲区溢出\n在代码段插入一些数据， 或是插入一些异常的跳转指令， 本来程序中的跳转是体现在`if``else`或者是`for`循环， 这些跳转语句在计算机底层会被转换成`jmp`指令，从这个地方跳转到另一个地方去执行， 当你跳到另一段代码那， 这段代码就开始执行了，  也就是如果代码是经过精心设计的， 跳转到的目标代码段不是你原本想要的代码段， 而目标代码段要做危险操作， 那就危险大了， 这就是缓冲区溢出。\n\n比如前两年的漏洞： 心脏滴血\n\n\n![如何与内存沟通](http://img.nixiaolei.com/2019-04-06-11-53-40.png)\n\n\n## 经典的8086CPU结构体系\n8086是一种比较早的商业化处理器芯片\n![8086CPU结构](http://img.nixiaolei.com/2019-04-06-12-32-53.png)","slug":"了解CPU工作原理","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4us007iaas6dolddlkx"},{"title":"【记录】记一次优化时间线卡顿处理思路","date":"2019-04-10T12:28:07.000Z","_content":"\n\n公司有这样的应用场景， 需要按时间段来分类图片， 然后各个分类之间还有联系， 因为有可能上一个分段的后面一部分图片和下一个分段的钱一部分图片在同一个分页。 \n\n\n![2019-09-10-20-36-59](http://img.nixiaolei.com/2019-09-10-20-36-59.png)\n\n打开某一分类：\n![2019-09-10-20-52-42](http://img.nixiaolei.com/2019-09-10-20-52-42.png)\n\n在这种场景下， 我们需要考虑:\n1. 如何把归类的图片同时保持相应的顺序成一组\n2. 当我打开并不是连续的分段时， 中间的分段如何空出来， 以便于后续插入， 同时插入后还要保证 `1` \n3. 打开一个分类时会加载大量图片， 此时加载资源会阻塞网络， 图片归类计算会阻塞进程， 图片量大的时候性能会出问题\n4. 当用户滚动时， 需要加载分页\n5. 滚动时分页加载的数据， 不能和用户主动打开时的数据冲突重复\n\n\n\n\n***\n解决思路\n1. 首先可以创建一个数组或是字典， 存储已加载的页码， 用来过滤重复加载的情况\n2. 以用户展开指定操作为优先， 滚动加载数据为次要，  当用户滚动时 ， 我们不要立即加载， 先存在一个队列里， 设置一个延迟时间， 在这段时间内， 用户有任何和加载相关的操作就将 分页的请求无限期延后， 直到在一段时间内都无任何操作后， 才开始从队列中取出需要加载的分页， 挨个加载（注意不要一起加载， 加载图片会阻塞网络）。\n3. 大图索引问题， 维护一个二为数组 和一个一维数组， 一维数组用来给大图使用，因为大图需要连续的滑动下一页操作， 二位数组用来渲染页面\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【记录】记一次优化时间线卡顿处理思路.md","raw":"---\ntitle: 【记录】记一次优化时间线卡顿处理思路\ndate: 2019-04-10 20:28:07\ncategories: 记录\ntags: 记录\n---\n\n\n公司有这样的应用场景， 需要按时间段来分类图片， 然后各个分类之间还有联系， 因为有可能上一个分段的后面一部分图片和下一个分段的钱一部分图片在同一个分页。 \n\n\n![2019-09-10-20-36-59](http://img.nixiaolei.com/2019-09-10-20-36-59.png)\n\n打开某一分类：\n![2019-09-10-20-52-42](http://img.nixiaolei.com/2019-09-10-20-52-42.png)\n\n在这种场景下， 我们需要考虑:\n1. 如何把归类的图片同时保持相应的顺序成一组\n2. 当我打开并不是连续的分段时， 中间的分段如何空出来， 以便于后续插入， 同时插入后还要保证 `1` \n3. 打开一个分类时会加载大量图片， 此时加载资源会阻塞网络， 图片归类计算会阻塞进程， 图片量大的时候性能会出问题\n4. 当用户滚动时， 需要加载分页\n5. 滚动时分页加载的数据， 不能和用户主动打开时的数据冲突重复\n\n\n\n\n***\n解决思路\n1. 首先可以创建一个数组或是字典， 存储已加载的页码， 用来过滤重复加载的情况\n2. 以用户展开指定操作为优先， 滚动加载数据为次要，  当用户滚动时 ， 我们不要立即加载， 先存在一个队列里， 设置一个延迟时间， 在这段时间内， 用户有任何和加载相关的操作就将 分页的请求无限期延后， 直到在一段时间内都无任何操作后， 才开始从队列中取出需要加载的分页， 挨个加载（注意不要一起加载， 加载图片会阻塞网络）。\n3. 大图索引问题， 维护一个二为数组 和一个一维数组， 一维数组用来给大图使用，因为大图需要连续的滑动下一页操作， 二位数组用来渲染页面\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【记录】记一次优化时间线卡顿处理思路","published":1,"updated":"2019-09-10T14:03:58.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4us007kaas6rkbfhtu6"},{"title":"【记录】工具目录","date":"2019-03-17T06:59:02.000Z","_content":"\n这里存放各种可能用到的用不到的东西， 真用到时方便查找😄\n\n当然平日里经常用到的， 耳熟能详的， 我就不放进来了， 主要是起个备忘录的作用\n\n\n***\n## CSS\n### 兼容查询\n* https://caniuse.com/ \n* https://cssdb.org/\n\n### 动画\n* 贝塞尔: http://cubic-bezier.com/#.17,.67,.83,.67\n\n\n## 可生成matrix的网站\n名称 | 网址\n---|---\nmatrix3d | http://ds-overdesign.com/transform/matrix3d.html\nCSS-Matrix3d | https://github.com/Zhangdroid/CSS-Matrix3d\nmatrix | http://meyerweb.com/eric/tools/matrix/\ntools  | http://www.f2e.name/case/css3/tools.html\n\n\n### 高逼格\n* web component CSS: https://css-doodle.com/\n\n### PostCss 值得收藏的插件\n功能 | 插件名 \n---|---\n运行时变量 | POSTCSS-CUSTOM-PROPERTIES \n与SCSS一致的变量实现 | POSTCSS-SIMPLE-VARS  \n实现类似SASS的@MIXIN的功能 | POSTCSS-MIXINS \n实现类似SASS的继承功能 | POSTCSS-EXTEND   \n实现类似SASS的IMPORT | POSTCSS-IMPORT \n面向未来 | CSSNext  \n修复过去（兼容IE，zomm、一像素留白等） | CSS Grace \n\n\n\n***\n\n## Node\n### 框架\n功能 | 插件名 | 周边生态\n---|---\n帮助实现DI的库 | Awilix |  awilix-koa\n实现控制反转&构造注入的框架 | InversifyJS |  inversify-koa-utils\n\n### 性能测试\n| 功能| 名称 |\n--- | ---\n 性能测试 | Benchmark.js\n\n\n\n***\n\n\n\n## webpack4\n\n### 学习帮助\n* webpack-internal-plugin-relation  可视化的webpack 钩子\n\n\n### 功能性能类\n\n功能 | 插件名\n---|---\n自动插入html及静态文件 | HtmlWebpackPlugin【配置自动注入loading（监测资源）】\n抽离css文件  | MiniCssExtractPlugin\n清空指定目录 | CleanWebpackPlugin\njs 深度 tree sharking 基于ES6模块 | webpack-deep-scope-plugin \ncss tree sharking   | PurifyCSSPlugin\n多核打包件 [需要babel]  |  uglifyjs-webpack-plugin[官方], happypack\n前端缓存负载【自动生成缓存文件】 |  Webpack Manifest Plugin\njs 压缩 以及 es压缩 多核压缩 | webpack-parallel-uglify-plugin, happypack\nhint css 多核压缩css | css-nano, optimize-css-assets-webpack-plugin \njs 转 ast静态语法分析树 | acorn , acorn-walk\n能对html进行hint 以及 fix 的插件 | html-minifier, html-minifier-lint\n搬运静态文件 | copy-webpack-plugin |\n\n\n\n### 优化体验类\n功能 | 插件名\n---|---\n监测 webpack 打包速度  | speed-measure-webpack-plugin\n打包成功通知  | webpack-build-notifier\n显示打包进度 | progress-bar-webpack-plugin\n信息面板优化 | webpack-dashboard[需要配置Pagejson]， webpack-jarvis[网页中浏览]\n修改cmd 标题 | node-bash-title[ github ][cmder 无效]\n\n### loader\n功能 | 插件名\n---|---\n缓存Loader结果 | cache-loader\n\n\n\n### AST\n * acorn 生成 Ast\n * acorn-walk 将AST转回代码\n * estraverse 用于遍历Ast 树\n\n\n\n\n\n\n\n***\n## JavaScript\n\n### 颜色提取\n* RGBaster\n\n\n\n***\n\n\n\n\n## TypeScript\n\n### 运行工具\n功能 | 插件名 | 周边生态\n---|---\n在node中不用编译就运行 | ts-node |  ts-node-dev 热重启\n\n\n\n***\n\n\n## Linux\n### vim\n* 快速学习vim的网站: https://vim-adventures.com/\n\n***\n\n## 算法\n### 学习帮助\n* 算法过程可视化: https://algorithm-visualizer.org/branch-and-bound/binary-search\n\n## k8s\n* 中文手册: https://www.kubernetes.org.cn/docs\n* Chart 应用仓库: https://hub.kubeapps.com/\n\n\n## 图形学\n\n* 算法生成图像: https://blog.csdn.net/zhangpiu/article/details/49511107s\n\n### canvas 库\n* 提供基础的`canvas`效果库： http://spritejs.org/#/\n\n### 物理引擎\n* cocos2D： https://cocos2d-x.org/products\n* phaser： http://phaser.io/\n\n\n## Three\n* stats.min.js 显示动画帧率 \n\n\n\n## 性能优化\n\n### 更新算法（文件增量更新）\n* mt.js (https://github.com/mtjs/mt)\n","source":"_posts/【记录】工具目录.md","raw":"---\ntitle: 【记录】工具目录\ndate: 2019-03-17 14:59:02\ncategories: 记录\ntags: 记录\n---\n\n这里存放各种可能用到的用不到的东西， 真用到时方便查找😄\n\n当然平日里经常用到的， 耳熟能详的， 我就不放进来了， 主要是起个备忘录的作用\n\n\n***\n## CSS\n### 兼容查询\n* https://caniuse.com/ \n* https://cssdb.org/\n\n### 动画\n* 贝塞尔: http://cubic-bezier.com/#.17,.67,.83,.67\n\n\n## 可生成matrix的网站\n名称 | 网址\n---|---\nmatrix3d | http://ds-overdesign.com/transform/matrix3d.html\nCSS-Matrix3d | https://github.com/Zhangdroid/CSS-Matrix3d\nmatrix | http://meyerweb.com/eric/tools/matrix/\ntools  | http://www.f2e.name/case/css3/tools.html\n\n\n### 高逼格\n* web component CSS: https://css-doodle.com/\n\n### PostCss 值得收藏的插件\n功能 | 插件名 \n---|---\n运行时变量 | POSTCSS-CUSTOM-PROPERTIES \n与SCSS一致的变量实现 | POSTCSS-SIMPLE-VARS  \n实现类似SASS的@MIXIN的功能 | POSTCSS-MIXINS \n实现类似SASS的继承功能 | POSTCSS-EXTEND   \n实现类似SASS的IMPORT | POSTCSS-IMPORT \n面向未来 | CSSNext  \n修复过去（兼容IE，zomm、一像素留白等） | CSS Grace \n\n\n\n***\n\n## Node\n### 框架\n功能 | 插件名 | 周边生态\n---|---\n帮助实现DI的库 | Awilix |  awilix-koa\n实现控制反转&构造注入的框架 | InversifyJS |  inversify-koa-utils\n\n### 性能测试\n| 功能| 名称 |\n--- | ---\n 性能测试 | Benchmark.js\n\n\n\n***\n\n\n\n## webpack4\n\n### 学习帮助\n* webpack-internal-plugin-relation  可视化的webpack 钩子\n\n\n### 功能性能类\n\n功能 | 插件名\n---|---\n自动插入html及静态文件 | HtmlWebpackPlugin【配置自动注入loading（监测资源）】\n抽离css文件  | MiniCssExtractPlugin\n清空指定目录 | CleanWebpackPlugin\njs 深度 tree sharking 基于ES6模块 | webpack-deep-scope-plugin \ncss tree sharking   | PurifyCSSPlugin\n多核打包件 [需要babel]  |  uglifyjs-webpack-plugin[官方], happypack\n前端缓存负载【自动生成缓存文件】 |  Webpack Manifest Plugin\njs 压缩 以及 es压缩 多核压缩 | webpack-parallel-uglify-plugin, happypack\nhint css 多核压缩css | css-nano, optimize-css-assets-webpack-plugin \njs 转 ast静态语法分析树 | acorn , acorn-walk\n能对html进行hint 以及 fix 的插件 | html-minifier, html-minifier-lint\n搬运静态文件 | copy-webpack-plugin |\n\n\n\n### 优化体验类\n功能 | 插件名\n---|---\n监测 webpack 打包速度  | speed-measure-webpack-plugin\n打包成功通知  | webpack-build-notifier\n显示打包进度 | progress-bar-webpack-plugin\n信息面板优化 | webpack-dashboard[需要配置Pagejson]， webpack-jarvis[网页中浏览]\n修改cmd 标题 | node-bash-title[ github ][cmder 无效]\n\n### loader\n功能 | 插件名\n---|---\n缓存Loader结果 | cache-loader\n\n\n\n### AST\n * acorn 生成 Ast\n * acorn-walk 将AST转回代码\n * estraverse 用于遍历Ast 树\n\n\n\n\n\n\n\n***\n## JavaScript\n\n### 颜色提取\n* RGBaster\n\n\n\n***\n\n\n\n\n## TypeScript\n\n### 运行工具\n功能 | 插件名 | 周边生态\n---|---\n在node中不用编译就运行 | ts-node |  ts-node-dev 热重启\n\n\n\n***\n\n\n## Linux\n### vim\n* 快速学习vim的网站: https://vim-adventures.com/\n\n***\n\n## 算法\n### 学习帮助\n* 算法过程可视化: https://algorithm-visualizer.org/branch-and-bound/binary-search\n\n## k8s\n* 中文手册: https://www.kubernetes.org.cn/docs\n* Chart 应用仓库: https://hub.kubeapps.com/\n\n\n## 图形学\n\n* 算法生成图像: https://blog.csdn.net/zhangpiu/article/details/49511107s\n\n### canvas 库\n* 提供基础的`canvas`效果库： http://spritejs.org/#/\n\n### 物理引擎\n* cocos2D： https://cocos2d-x.org/products\n* phaser： http://phaser.io/\n\n\n## Three\n* stats.min.js 显示动画帧率 \n\n\n\n## 性能优化\n\n### 更新算法（文件增量更新）\n* mt.js (https://github.com/mtjs/mt)\n","slug":"【记录】工具目录","published":1,"updated":"2019-09-14T16:51:25.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uu007oaas60jebvur8"},{"title":"倪晓磊的个人简历","date":"2019-03-16T15:06:29.000Z","_content":"\n\n# 应聘岗位\n\nWeb前端开发\n\n# 联系方式\n\n- 手机：17367070484 \n- Email：nxl3477@gmail.com \n- QQ: 634926049\n- 微信号：17367070484\n\n---\n\n# 个人信息\n\n - 倪晓磊 / 男 / 1998 \n - 杭州科技职业技术学院 / 计算机\n - 工作年限：0.8年\n - Github：https://github.com/nixiaolei \n - 期望职位：Web前端开发\n - 期望城市：杭州\n\n---\n\n\n# 掌握技能\n\n### HTML 5 / CSS3\n\n* 熟练使用 `HTML 5`、`CSS3`。\n* 能够编写语义化的 `HTML`， 能够完成比较复杂的布局。\n* 能够使用 `CSS3` 实现基本动效。\n* 熟悉 `Sass` 、`Less` 等 CSS 预处理工具。\n* 熟悉移动端适配解决方案。\n* 能够解决基本的手机端网页兼容问题。\n\n\n\n\n### JavaScript\n\n* 熟练使用原生 `JavaScript`、`ES6/7`等， 能够运用模块化的方式编程。\n* 熟悉使用 `React`、`Redux`、`Vue`、`Vuex` ，了解`MVVM` 框架思想。\n* 熟练使用`jQuery`， 并尝试看过`jQuery`源码。\n\n\n### Node.js\n\n* 熟练使用 `Koa2`、`Express` 框架进行web应用开发，对 `Hapi`、`egg` 等其他框架也有所学习。\n* 熟练使用 `Node.js`编写爬虫， 了解 robots协议。\n* 能够使用 `pm2` 进行 `Node.js` 项目部署。\n* 了解`Node.js`的“异步机制”以及 `GC` 原理。\n* 了解`SPA`预渲染、`SSR`方案 及`BFF`架构。\n\n\n### webpack\n\n* 熟练`webpack`的配置。\n* 能够搭建简单的工程化项目， 如: `Vue-cli`脚手架。\n* 能够对 `webpack` 作基本的性能优化， 并尝试在项目中使用过。\n* 了解`webpack`插件开发。\n\n\n\n### 其他\n\n* 能使用 `Nginx` 进行 `ip_hash 指令`配置、 反向代理、负载均衡以及权重分配。\n* 熟悉 `Git` 版本管理工具。\n* 熟练使用 `Photoshop` 进行图片处理。\n\n---\n\n# 工作经历\n* 都市快报 - 快房网（ 2018年7月 ~ 2018年12月 ）\n* 杭州喔图云摄影（ 2018年12月 ~ 至今 ）\n\n# 项目经历\n\n### 杭州购房摇号登记系统\n> Vue全家桶\n\n面向房地产商的购房审核系统，是小程序“杭州最新摇号楼盘一览”的后台系统， 小程序可在微信小程序中搜索到。\n\n作为该项目唯一的前端，在没有产品指导的情况下， 我不但完成了网站界面的开发工作， 更是为解决用户参与摇号与楼盘人员审核之间效率低下的痛点提出了自己的多种方案建议。 从开始的审核资料图文混乱改版至图文联动审核，  从开始的审核进度紊乱容易出现重复审核的问题到最后每个审核项都可标记。 期间还负责为使用方现场演示和培训， 并收集改进意见。据使用方反馈，改版前后审核效率提升二倍之多。正因此该系统获得了相当不错的口碑。\n\n\n\n\n### 浙江省银行协防系统 \n> Vue全家桶、 vw、 weui\n\n该项目服务于\"浙江省银行协会\"，可在 \"浙江省银行协会\" 微信公众号的\"协防信息\"板块进入。\n\n我负责开发移动端网页，在这过程中我学会了使用vw适配方案来解决移动端的尺寸适配问题， 期间也遇到了很多的兼容方面问题， 在此过程中丰富了对各个手机兼容问题的经验。 \n\n\n\n### 仿今日头条小程序\n> React全家桶、WePY、Node.js、Koa2、pm2、Nginx、 MySQL、 Ant Design\n\n毕设项目，项目包括小程序及配套的后台系统。\n\n在此过程中我尽可能使用了自己未掌握的技术，尝试用`koa-jwt`验证token， 用`Node.js`开子进程爬取今日头条与西瓜视频数据存入`MySQL`、`react-loadable`异步加载页面优化后台系统体验、尝试在本地使用`pm2`部署项目、用`Nginx`做反向代理与负载均衡。\n\n\n\n---\n\n# 致谢\n感谢您花时间阅读我的简历，期待能有机会和您共事。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/倪晓磊的个人简历.md","raw":"---\ntitle: 倪晓磊的个人简历\ndate: 2019-03-016 23:06:29\ncategories: \ntags: \n---\n\n\n# 应聘岗位\n\nWeb前端开发\n\n# 联系方式\n\n- 手机：17367070484 \n- Email：nxl3477@gmail.com \n- QQ: 634926049\n- 微信号：17367070484\n\n---\n\n# 个人信息\n\n - 倪晓磊 / 男 / 1998 \n - 杭州科技职业技术学院 / 计算机\n - 工作年限：0.8年\n - Github：https://github.com/nixiaolei \n - 期望职位：Web前端开发\n - 期望城市：杭州\n\n---\n\n\n# 掌握技能\n\n### HTML 5 / CSS3\n\n* 熟练使用 `HTML 5`、`CSS3`。\n* 能够编写语义化的 `HTML`， 能够完成比较复杂的布局。\n* 能够使用 `CSS3` 实现基本动效。\n* 熟悉 `Sass` 、`Less` 等 CSS 预处理工具。\n* 熟悉移动端适配解决方案。\n* 能够解决基本的手机端网页兼容问题。\n\n\n\n\n### JavaScript\n\n* 熟练使用原生 `JavaScript`、`ES6/7`等， 能够运用模块化的方式编程。\n* 熟悉使用 `React`、`Redux`、`Vue`、`Vuex` ，了解`MVVM` 框架思想。\n* 熟练使用`jQuery`， 并尝试看过`jQuery`源码。\n\n\n### Node.js\n\n* 熟练使用 `Koa2`、`Express` 框架进行web应用开发，对 `Hapi`、`egg` 等其他框架也有所学习。\n* 熟练使用 `Node.js`编写爬虫， 了解 robots协议。\n* 能够使用 `pm2` 进行 `Node.js` 项目部署。\n* 了解`Node.js`的“异步机制”以及 `GC` 原理。\n* 了解`SPA`预渲染、`SSR`方案 及`BFF`架构。\n\n\n### webpack\n\n* 熟练`webpack`的配置。\n* 能够搭建简单的工程化项目， 如: `Vue-cli`脚手架。\n* 能够对 `webpack` 作基本的性能优化， 并尝试在项目中使用过。\n* 了解`webpack`插件开发。\n\n\n\n### 其他\n\n* 能使用 `Nginx` 进行 `ip_hash 指令`配置、 反向代理、负载均衡以及权重分配。\n* 熟悉 `Git` 版本管理工具。\n* 熟练使用 `Photoshop` 进行图片处理。\n\n---\n\n# 工作经历\n* 都市快报 - 快房网（ 2018年7月 ~ 2018年12月 ）\n* 杭州喔图云摄影（ 2018年12月 ~ 至今 ）\n\n# 项目经历\n\n### 杭州购房摇号登记系统\n> Vue全家桶\n\n面向房地产商的购房审核系统，是小程序“杭州最新摇号楼盘一览”的后台系统， 小程序可在微信小程序中搜索到。\n\n作为该项目唯一的前端，在没有产品指导的情况下， 我不但完成了网站界面的开发工作， 更是为解决用户参与摇号与楼盘人员审核之间效率低下的痛点提出了自己的多种方案建议。 从开始的审核资料图文混乱改版至图文联动审核，  从开始的审核进度紊乱容易出现重复审核的问题到最后每个审核项都可标记。 期间还负责为使用方现场演示和培训， 并收集改进意见。据使用方反馈，改版前后审核效率提升二倍之多。正因此该系统获得了相当不错的口碑。\n\n\n\n\n### 浙江省银行协防系统 \n> Vue全家桶、 vw、 weui\n\n该项目服务于\"浙江省银行协会\"，可在 \"浙江省银行协会\" 微信公众号的\"协防信息\"板块进入。\n\n我负责开发移动端网页，在这过程中我学会了使用vw适配方案来解决移动端的尺寸适配问题， 期间也遇到了很多的兼容方面问题， 在此过程中丰富了对各个手机兼容问题的经验。 \n\n\n\n### 仿今日头条小程序\n> React全家桶、WePY、Node.js、Koa2、pm2、Nginx、 MySQL、 Ant Design\n\n毕设项目，项目包括小程序及配套的后台系统。\n\n在此过程中我尽可能使用了自己未掌握的技术，尝试用`koa-jwt`验证token， 用`Node.js`开子进程爬取今日头条与西瓜视频数据存入`MySQL`、`react-loadable`异步加载页面优化后台系统体验、尝试在本地使用`pm2`部署项目、用`Nginx`做反向代理与负载均衡。\n\n\n\n---\n\n# 致谢\n感谢您花时间阅读我的简历，期待能有机会和您共事。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"倪晓磊的个人简历","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uv007raas6k9ts1pb8"},{"title":"利用CSS混合模式更改图片颜色","date":"2019-03-16T10:34:26.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\nCSS3 新增了一个很有意思的属性 `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。\n\n混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。\n\n\n\n开始动手吧 ~\n\n## 尝试修改图片物体颜色\n\n首先我们创建一个Input框和一个 Img标签（其实这里我选择的图片不是很好）\n```HTML\n<body>\n  <input type=\"color\" />\n  <img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553336864&di=2f41edc8eedbf09fb1d106545acaed5f&imgtype=jpg&er=1&src=http%3A%2F%2Fpic44.nipic.com%2F20140723%2F19276212_171901262000_2.jpg\" alt=\"\">\n</body>\n```\n\n然后我们将图片撑满屏幕， 将Input也撑满屏幕， 将input覆盖至图片之上， 然后为input 添加上混合模式`mix-blend-mode: hue;` \n> 因为input框自带颜色， 所以当用户切换颜色时也就能不依靠JS 即时生效\n\n\n```CSS\n<style>\nhtml,body, input, img {\n  width: 100%;\n  height: 100%;\n}\ninput{ \n  position: absolute;\n  top: 0;\n  left: 0;\n  mix-blend-mode: hue;\n}\n</style>\n```\n\n\n### 过程记录\n原图:\n![原图](http://img.nixiaolei.com/2019-03-16-18-43-09.png)\n\n添加上了混合模式(变灰是因为color选择器默认是黑色):\n![添加上了混合模式](http://img.nixiaolei.com/2019-03-16-18-44-01.png)\n\n切换颜色中:\n![切换颜色中](http://img.nixiaolei.com/2019-03-16-18-45-53.png)\n\n切换后: \n\n![切换后](http://img.nixiaolei.com/2019-03-16-18-46-30.png)\n\n虽然有点丑但我们成功了~\n\n\n## 更多可能性\n\n利用整个混合模式的特性， 我们还能做出更多的东西， 比如利用三原色实现彩色loading、 万花筒等等炫酷动画， 可以看看参考文献中的例子， 非常的不错\n\n\n## 参考文献\n> https://www.cnblogs.com/coco1s/p/6829372.html","source":"_posts/利用CSS混合模式更改图片颜色.md","raw":"---\ntitle: 利用CSS混合模式更改图片颜色\ndate: 2019-03-16 18:34:26\ncategories: CSS\ntags: [css]\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\nCSS3 新增了一个很有意思的属性 `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。\n\n混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。\n\n\n\n开始动手吧 ~\n\n## 尝试修改图片物体颜色\n\n首先我们创建一个Input框和一个 Img标签（其实这里我选择的图片不是很好）\n```HTML\n<body>\n  <input type=\"color\" />\n  <img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553336864&di=2f41edc8eedbf09fb1d106545acaed5f&imgtype=jpg&er=1&src=http%3A%2F%2Fpic44.nipic.com%2F20140723%2F19276212_171901262000_2.jpg\" alt=\"\">\n</body>\n```\n\n然后我们将图片撑满屏幕， 将Input也撑满屏幕， 将input覆盖至图片之上， 然后为input 添加上混合模式`mix-blend-mode: hue;` \n> 因为input框自带颜色， 所以当用户切换颜色时也就能不依靠JS 即时生效\n\n\n```CSS\n<style>\nhtml,body, input, img {\n  width: 100%;\n  height: 100%;\n}\ninput{ \n  position: absolute;\n  top: 0;\n  left: 0;\n  mix-blend-mode: hue;\n}\n</style>\n```\n\n\n### 过程记录\n原图:\n![原图](http://img.nixiaolei.com/2019-03-16-18-43-09.png)\n\n添加上了混合模式(变灰是因为color选择器默认是黑色):\n![添加上了混合模式](http://img.nixiaolei.com/2019-03-16-18-44-01.png)\n\n切换颜色中:\n![切换颜色中](http://img.nixiaolei.com/2019-03-16-18-45-53.png)\n\n切换后: \n\n![切换后](http://img.nixiaolei.com/2019-03-16-18-46-30.png)\n\n虽然有点丑但我们成功了~\n\n\n## 更多可能性\n\n利用整个混合模式的特性， 我们还能做出更多的东西， 比如利用三原色实现彩色loading、 万花筒等等炫酷动画， 可以看看参考文献中的例子， 非常的不错\n\n\n## 参考文献\n> https://www.cnblogs.com/coco1s/p/6829372.html","slug":"利用CSS混合模式更改图片颜色","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uw007uaas69142vovg"},{"title":"原生实现一个ajax","date":"2019-04-10T14:42:08.000Z","_content":"\n# 原生 AJAX\n\n## 什么是AJAX\n\n* Asynchronous  JavaScript & XML    请求XML的异步技术\n* web开发的一种技术\n* 异步发送 & 请求数据\n* 不需要重新刷新当前页面\n* 目前 JSON 数据格式以及占据市场\n\n## 请求码 和 状态码\n### readyState 请求码\n* 0 : 请求未初始化  ( 没有 XHR 对象 )\n* 1 : 服务器连接已建立\n* 2 : 请求已接受\n* 3 : 请求处理中\n* 4 : 请求已完成, 且相应已就绪\n\n### HTTP 状态码\n* 200 - 服务器成功返回网页\n* 300 - 请求地址错误,重定向\n* 400 - 请求错误\n  * 404 - 请求的网页不存在\n* 500 - 服务端错误\n  * 503 - 服务器暂时不可用    \n\n## 创建  XMLHttpRequest 对象\n```js\nvar xhr = new XMLHttpRequest()\n```\n\n\n##  open() 请求部署阶段\n* xhr.open( type 请求类型 , url/filename 路径或文件名 ,  async是否要使用异步)\n* GET 请求 参数写在 URL 中\n```js\n xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true)\n```\n## 两种方式请求 onload 和 onreadystatechange\n* 请求成功后会返回服务器 返还的相应内容 `responseText`\n\n### onload\n* 只有请求码为 4 时才会进入 onload\n```js\nxhr.onload = function(){\n  console.log(this.responseText)\n}\n```\n\n###  onprogress 捕获 为3 的请求码\n```js\nxhr.onprogress =function(){\n  console.log(this.readyState)\n}\n```\n\n### onreadystatechange\n* 需要判断返回的请求码 , 直接输出会返回两次数据 \n```js\nxhr.onreadystatechange = function(){\n  console.log(this.responseText)\n}\n```\n####  readyState\n\n* 返回请求码的位置与顺序\n```js\n var xhr = new XMLHttpRequest()\n console.log(xhr.readyState) // 0\n xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true)\n console.log(xhr.readyState)  // 1\n xhr.onreadystatechange = function(){\n  console.log('readyState:',xhr.readyState)  // 2 , 3 , 4\n }\n xhr.send()\n```\n####  status 状态码\n* 每次都和请求码一同被返回\n\n#### 根据 请求码 和 状态码 来操作数据\n\n#### 一个完整的 GET 请求\n```js\n var xhr = new XMLHttpRequest()\n  xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true)\n  xhr.onreadystatechange = function(){\n      if(this.status == 200 && this.readyState == 4){\n          console.log(this.responseText)\n      }\n  }\n  xhr.send()\n```\n## 发送请求\n* GET 直接发送\n* POST 需要带上要发送的 请求体 数据\n```js\nxhr.send()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/原生实现一个ajax.md","raw":"---\ntitle: 原生实现一个ajax\ndate: 2019-04-10 22:42:08\ncategories: JavaScript\ntags: JavaScript\n---\n\n# 原生 AJAX\n\n## 什么是AJAX\n\n* Asynchronous  JavaScript & XML    请求XML的异步技术\n* web开发的一种技术\n* 异步发送 & 请求数据\n* 不需要重新刷新当前页面\n* 目前 JSON 数据格式以及占据市场\n\n## 请求码 和 状态码\n### readyState 请求码\n* 0 : 请求未初始化  ( 没有 XHR 对象 )\n* 1 : 服务器连接已建立\n* 2 : 请求已接受\n* 3 : 请求处理中\n* 4 : 请求已完成, 且相应已就绪\n\n### HTTP 状态码\n* 200 - 服务器成功返回网页\n* 300 - 请求地址错误,重定向\n* 400 - 请求错误\n  * 404 - 请求的网页不存在\n* 500 - 服务端错误\n  * 503 - 服务器暂时不可用    \n\n## 创建  XMLHttpRequest 对象\n```js\nvar xhr = new XMLHttpRequest()\n```\n\n\n##  open() 请求部署阶段\n* xhr.open( type 请求类型 , url/filename 路径或文件名 ,  async是否要使用异步)\n* GET 请求 参数写在 URL 中\n```js\n xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true)\n```\n## 两种方式请求 onload 和 onreadystatechange\n* 请求成功后会返回服务器 返还的相应内容 `responseText`\n\n### onload\n* 只有请求码为 4 时才会进入 onload\n```js\nxhr.onload = function(){\n  console.log(this.responseText)\n}\n```\n\n###  onprogress 捕获 为3 的请求码\n```js\nxhr.onprogress =function(){\n  console.log(this.readyState)\n}\n```\n\n### onreadystatechange\n* 需要判断返回的请求码 , 直接输出会返回两次数据 \n```js\nxhr.onreadystatechange = function(){\n  console.log(this.responseText)\n}\n```\n####  readyState\n\n* 返回请求码的位置与顺序\n```js\n var xhr = new XMLHttpRequest()\n console.log(xhr.readyState) // 0\n xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true)\n console.log(xhr.readyState)  // 1\n xhr.onreadystatechange = function(){\n  console.log('readyState:',xhr.readyState)  // 2 , 3 , 4\n }\n xhr.send()\n```\n####  status 状态码\n* 每次都和请求码一同被返回\n\n#### 根据 请求码 和 状态码 来操作数据\n\n#### 一个完整的 GET 请求\n```js\n var xhr = new XMLHttpRequest()\n  xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true)\n  xhr.onreadystatechange = function(){\n      if(this.status == 200 && this.readyState == 4){\n          console.log(this.responseText)\n      }\n  }\n  xhr.send()\n```\n## 发送请求\n* GET 直接发送\n* POST 需要带上要发送的 请求体 数据\n```js\nxhr.send()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"原生实现一个ajax","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uw007waas6k5wif71m"},{"title":"如何在伪元素中使用Iconfont","date":"2019-03-24T06:45:47.000Z","_content":"\n\n## 把iconfont 中的样式拷到 伪元素上\n```CSS\n.iconfont{\n  font-family:\"iconfont\" !important;\n  font-size:16px;font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n```\n\n## 砍掉unicode 前面的字符\n\n## 如下 即可\n```CSS\n&::after{\n  content: '\\e60e';\n\n  font-family:\"iconfont\" !important;\n  font-size:16px;font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n```\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/如何在伪元素中使用Iconfont.md","raw":"---\ntitle: 如何在伪元素中使用Iconfont\ndate: 2019-03-24 14:45:47\ncategories: CSS\ntags: [css]\n---\n\n\n## 把iconfont 中的样式拷到 伪元素上\n```CSS\n.iconfont{\n  font-family:\"iconfont\" !important;\n  font-size:16px;font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n```\n\n## 砍掉unicode 前面的字符\n\n## 如下 即可\n```CSS\n&::after{\n  content: '\\e60e';\n\n  font-family:\"iconfont\" !important;\n  font-size:16px;font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n```\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"如何在伪元素中使用Iconfont","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4ux0080aas65ca5yof2"},{"title":"待学书籍","date":"2019-04-01T05:33:25.000Z","_content":"\n\n\n## 图形学\n* 《高中数学必修123》\n* 线性代数\n* 离散数学\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/待学书籍.md","raw":"---\ntitle: 待学书籍\ndate: 2019-04-01 13:33:25\ncategories: 目录\ntags: 目录\n---\n\n\n\n## 图形学\n* 《高中数学必修123》\n* 线性代数\n* 离散数学\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"待学书籍","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4uy0083aas6hqjryxqu"},{"title":"【记录】小程序中如何引入iconfont 字体图标","date":"2019-09-10T12:12:16.000Z","_content":"\n\n\nicon引入小程序需要将字体文件转换成base64格式，所以\n\n1. 先解压压缩包 找到ttf格式文件\n2. 上传到平台转化为base64格式 \n3. 下载压缩包 \n4. 将css文件名改为wxss \n5. 放入项目样式文件夹\n\n\n***\n\n\n\n字体文件转换成base64格式的链接  https://transfonter.org/\n\n\n参考文档\n> https://www.cnblogs.com/minimo/p/8795774.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【记录】小程序中如何引入iconfont-字体图标.md","raw":"---\ntitle: 【记录】小程序中如何引入iconfont 字体图标\ndate: 2019-09-10 20:12:16\ncategories: 记录\ntags: 记录\n---\n\n\n\nicon引入小程序需要将字体文件转换成base64格式，所以\n\n1. 先解压压缩包 找到ttf格式文件\n2. 上传到平台转化为base64格式 \n3. 下载压缩包 \n4. 将css文件名改为wxss \n5. 放入项目样式文件夹\n\n\n***\n\n\n\n字体文件转换成base64格式的链接  https://transfonter.org/\n\n\n参考文档\n> https://www.cnblogs.com/minimo/p/8795774.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【记录】小程序中如何引入iconfont-字体图标","published":1,"updated":"2019-09-10T12:13:41.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v00087aas67spm0ve5"},{"title":"手摸手AngularJs入门教程","date":"2019-03-16T04:00:36.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\nAngularJs 是一款来自Google 的前端JavaScript框架， 也是SPA框架。 AngularJs框架的体积非常小， 但是设计理念和功能却非常强大， 极大地简化前端开发的负担， 它快速成为了JavaScript的主流框架， 帮助开发者从事web开发。\n\n这里我们用AngularJs7的练手吧\n\n## 起步\n> 请确保电脑已安装了`Node.js`\n\n首先是全局安装脚手架\n```shell\nnpm install -g @angular/cli\n```\n安装好后查看一下版本\n> ng --version\n\n![查看版本](http://img.nixiaolei.com/2019-03-17-15-54-41.png)\n\n\n确认`ng`命令存在后就可以开始创建我们的第一个 Angular 项目了\n```shell\n# 创建项目  project 替换为你的项目名称\nng new project\n```\n\n当你输入命令后他会问你需要的配置，  \n\n这里附上我的选择， 大家可以参照\n\n1. 你是否需要添加路由？ ---- yes\n2. 选择你喜欢的css 风格 ---- SCSS\n\n![选择配置](http://img.nixiaolei.com/2019-03-17-15-36-01.png)\n\n\n选择好后， 就会进入漫长的安装了\n![安装中](http://img.nixiaolei.com/2019-03-17-15-39-53.png)\n\n安装好后， cd 进入到项目所在的目录， 运行 `ng serve` 命令， 并打开`http://localhost:4200/` 查看我们第一个 `Angular`项目\n```shell\n# 进入你的项目目录\ncd project\n\n# 启动项目\nng serve\n\n# 如果你需要 可以生产环境运行\nng serve --prod --aot \n```\n\n## 基本的路由配置\n> 如果你不知道路由是什么， 你只需要先理解路由帮助我们实现切换页面的功能\n因为之前我们在构建项目时就选择了加入`路由`， 因此也省去了很多配置过程， \n\n现在，我们来看看怎么用吧， \n\n首先想使用路由， 得需要再创建一个\"页面\"（这里指组件）， 这样才能通过切换看出是否实现了路由， \n\n**那如何创建一个组件呢？**\n\nAngular 给我们提供了非常多的创建命令， 组件也可以一键的生成\n\n我们来创建一个 `Demo` 组件\n> ng g c Demo\n\n等待片刻， 安装好后\n\n我们发现项目文件中的 `app` 目录下多了一个文件夹\n![Demo组件创建](http://img.nixiaolei.com/2019-03-17-17-01-55.png)\n\n里面有配套的\n* 模板文件\n* 样式文件\n* 测试文件\n* ts 脚本文件\n\n\n既然有了组件， 那我们现在需要为这个路由分配相应的访问路径\n\n进入 `app/app-routing.module.ts` 这个文件\n\n我们首先导入刚刚创建的`Demo`组件， 再 `routes`数组中，分配一个用于访问的`path`, 并和导入的`DemoComponent`关联上\n\n如下:\n\n```JavaScript\n// ------------新增区域------------\nimport { DemoComponent } from './demo/demo.component';\n// ------------新增区域------------\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\n\n\nconst routes: Routes = [\n  // -----------新增区域-------------\n  {\n    path: \"demo\",\n    component: DemoComponent\n  }\n  // ------------新增区域------------\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n\n然后进入 `app/app.component.html` 文件中找到 `<router-outlet></router-outlet>`\n\n刚才配置的路由就会显示在这个标签所在的位置，\n为了减少一点干扰，我们把没有用的信息删除\n\n!component19html\n切换后](http://img.nixiaolei.com/2019-03--17-17-27-25.png app.我只留了一张图片,\n\n然后我们进入 `app/demo/demo.component.html` 文件中\n\n原本是\n```HTML\n<p>\n  demo works!\n</p>\n```\n\n我们改成明显一点的内容\n> 千万注意dom结构别错了， dom结构错误会造成白屏，坑的是没有错误信息\n\n```HTML\n<div>\n  <h1>我是Demo 页面</h1>\n</div>\n```\n\n我们看看是否配置成功了\n\n\n首先，刚进入， 只有一张图片\n\n![根路由](http://img.nixiaolei.com/2019-03-17-17-34-37.png)\n\n\n让我们切换至`/demo`\n\n我们可以看到， 刚刚为demo组件编写的文字成功显示出来了， 并且是位于图片下方， 这跟我们之前 `app/app.component.html` 中所做的配置一样\n\n![切换至demo](http://img.nixiaolei.com/2019-03-17-17-35-14.png)\n\n\n\n--------------------待完善-------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 常用的命令\n> 把 XXX 替换成你要的名字\n\n* ng g cl xxx // 创建一个新类\n* ng g c xxx // 创建一个新组件\n* ng g d xxx // 创建一个新指令\n* ng g e xxx // 创建一个新枚举\n* ng g m xxx // 创建一个新模块\n* ng g p xxx // 创建一个新管道\n* ng g s xxx // 创建一个新的指服务\n\n\n \n## 参考文献\n> https://github.com/angular/angular-cli/wiki\n\n","source":"_posts/手摸手AngularJs入门教程.md","raw":"---\ntitle: 手摸手AngularJs入门教程\ndate: 2019-03-16 12:00:36\ncategories: JavaScript\ntags: [Angular]\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\nAngularJs 是一款来自Google 的前端JavaScript框架， 也是SPA框架。 AngularJs框架的体积非常小， 但是设计理念和功能却非常强大， 极大地简化前端开发的负担， 它快速成为了JavaScript的主流框架， 帮助开发者从事web开发。\n\n这里我们用AngularJs7的练手吧\n\n## 起步\n> 请确保电脑已安装了`Node.js`\n\n首先是全局安装脚手架\n```shell\nnpm install -g @angular/cli\n```\n安装好后查看一下版本\n> ng --version\n\n![查看版本](http://img.nixiaolei.com/2019-03-17-15-54-41.png)\n\n\n确认`ng`命令存在后就可以开始创建我们的第一个 Angular 项目了\n```shell\n# 创建项目  project 替换为你的项目名称\nng new project\n```\n\n当你输入命令后他会问你需要的配置，  \n\n这里附上我的选择， 大家可以参照\n\n1. 你是否需要添加路由？ ---- yes\n2. 选择你喜欢的css 风格 ---- SCSS\n\n![选择配置](http://img.nixiaolei.com/2019-03-17-15-36-01.png)\n\n\n选择好后， 就会进入漫长的安装了\n![安装中](http://img.nixiaolei.com/2019-03-17-15-39-53.png)\n\n安装好后， cd 进入到项目所在的目录， 运行 `ng serve` 命令， 并打开`http://localhost:4200/` 查看我们第一个 `Angular`项目\n```shell\n# 进入你的项目目录\ncd project\n\n# 启动项目\nng serve\n\n# 如果你需要 可以生产环境运行\nng serve --prod --aot \n```\n\n## 基本的路由配置\n> 如果你不知道路由是什么， 你只需要先理解路由帮助我们实现切换页面的功能\n因为之前我们在构建项目时就选择了加入`路由`， 因此也省去了很多配置过程， \n\n现在，我们来看看怎么用吧， \n\n首先想使用路由， 得需要再创建一个\"页面\"（这里指组件）， 这样才能通过切换看出是否实现了路由， \n\n**那如何创建一个组件呢？**\n\nAngular 给我们提供了非常多的创建命令， 组件也可以一键的生成\n\n我们来创建一个 `Demo` 组件\n> ng g c Demo\n\n等待片刻， 安装好后\n\n我们发现项目文件中的 `app` 目录下多了一个文件夹\n![Demo组件创建](http://img.nixiaolei.com/2019-03-17-17-01-55.png)\n\n里面有配套的\n* 模板文件\n* 样式文件\n* 测试文件\n* ts 脚本文件\n\n\n既然有了组件， 那我们现在需要为这个路由分配相应的访问路径\n\n进入 `app/app-routing.module.ts` 这个文件\n\n我们首先导入刚刚创建的`Demo`组件， 再 `routes`数组中，分配一个用于访问的`path`, 并和导入的`DemoComponent`关联上\n\n如下:\n\n```JavaScript\n// ------------新增区域------------\nimport { DemoComponent } from './demo/demo.component';\n// ------------新增区域------------\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\n\n\nconst routes: Routes = [\n  // -----------新增区域-------------\n  {\n    path: \"demo\",\n    component: DemoComponent\n  }\n  // ------------新增区域------------\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n\n然后进入 `app/app.component.html` 文件中找到 `<router-outlet></router-outlet>`\n\n刚才配置的路由就会显示在这个标签所在的位置，\n为了减少一点干扰，我们把没有用的信息删除\n\n!component19html\n切换后](http://img.nixiaolei.com/2019-03--17-17-27-25.png app.我只留了一张图片,\n\n然后我们进入 `app/demo/demo.component.html` 文件中\n\n原本是\n```HTML\n<p>\n  demo works!\n</p>\n```\n\n我们改成明显一点的内容\n> 千万注意dom结构别错了， dom结构错误会造成白屏，坑的是没有错误信息\n\n```HTML\n<div>\n  <h1>我是Demo 页面</h1>\n</div>\n```\n\n我们看看是否配置成功了\n\n\n首先，刚进入， 只有一张图片\n\n![根路由](http://img.nixiaolei.com/2019-03-17-17-34-37.png)\n\n\n让我们切换至`/demo`\n\n我们可以看到， 刚刚为demo组件编写的文字成功显示出来了， 并且是位于图片下方， 这跟我们之前 `app/app.component.html` 中所做的配置一样\n\n![切换至demo](http://img.nixiaolei.com/2019-03-17-17-35-14.png)\n\n\n\n--------------------待完善-------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 常用的命令\n> 把 XXX 替换成你要的名字\n\n* ng g cl xxx // 创建一个新类\n* ng g c xxx // 创建一个新组件\n* ng g d xxx // 创建一个新指令\n* ng g e xxx // 创建一个新枚举\n* ng g m xxx // 创建一个新模块\n* ng g p xxx // 创建一个新管道\n* ng g s xxx // 创建一个新的指服务\n\n\n \n## 参考文献\n> https://github.com/angular/angular-cli/wiki\n\n","slug":"手摸手AngularJs入门教程","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v1008baas6kh8opj74"},{"title":"数据结构与算法基础学习笔记","date":"2019-05-01T14:18:53.000Z","_content":"\n## 基本概念\n![数据结构基本概念](http://img.nixiaolei.com/2019-05-01-22-26-25.png)\n\n\n### 数据\n只要能被数字化就可以称为数据\n\n### 数据对象\n可以完整的描述一件东西，通常是产生在内存中的文件， 链表、队列等都算数据对象\n\n### 数据元素\n存在于数据对象中的一份一份的数据，就是数据元素\n\n### 数据项\n用来描述某一特征的，  可以参考对象的属性， 但不完全相同\n\n\n\n## 浅析数据结构\n数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的\n\n* 逻辑结构：反映数据元素之间的逻辑关系。\n* 存储结构：数据结构在计算机中的表示。\n* 算法：对数据的操作\n\n\n![浅析数据结构](http://img.nixiaolei.com/2019-05-01-22-37-55.png)\n\n![浅析数据结构02](http://img.nixiaolei.com/2019-05-01-22-38-59.png)\n\n### 基本逻辑结构\n\n![逻辑结构分类](http://img.nixiaolei.com/2019-05-01-22-54-54.png)\n\n\n\n### 内存与存储结构\n按照在内存中存储的方式来区分， 简单了解计一些算机中内存相关的知识：\n1. 内存的原理与构造。\n2. 地址、指针与引用。\n3. 存储结构与内存管理\n\n\n\n\n","source":"_posts/数据结构与算法基础学习笔记.md","raw":"---\ntitle: 数据结构与算法基础学习笔记\ndate: 2019-05-01 22:18:53\ncategories: 算法\ntags: 算法\n---\n\n## 基本概念\n![数据结构基本概念](http://img.nixiaolei.com/2019-05-01-22-26-25.png)\n\n\n### 数据\n只要能被数字化就可以称为数据\n\n### 数据对象\n可以完整的描述一件东西，通常是产生在内存中的文件， 链表、队列等都算数据对象\n\n### 数据元素\n存在于数据对象中的一份一份的数据，就是数据元素\n\n### 数据项\n用来描述某一特征的，  可以参考对象的属性， 但不完全相同\n\n\n\n## 浅析数据结构\n数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的\n\n* 逻辑结构：反映数据元素之间的逻辑关系。\n* 存储结构：数据结构在计算机中的表示。\n* 算法：对数据的操作\n\n\n![浅析数据结构](http://img.nixiaolei.com/2019-05-01-22-37-55.png)\n\n![浅析数据结构02](http://img.nixiaolei.com/2019-05-01-22-38-59.png)\n\n### 基本逻辑结构\n\n![逻辑结构分类](http://img.nixiaolei.com/2019-05-01-22-54-54.png)\n\n\n\n### 内存与存储结构\n按照在内存中存储的方式来区分， 简单了解计一些算机中内存相关的知识：\n1. 内存的原理与构造。\n2. 地址、指针与引用。\n3. 存储结构与内存管理\n\n\n\n\n","slug":"数据结构与算法基础学习笔记","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v2008faas6542d3u7g"},{"title":"数学基础入门","date":"2019-05-01T04:03:16.000Z","_content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/数学基础入门.md","raw":"---\ntitle: 数学基础入门\ndate: 2019-05-01 12:03:16\ncategories: 图形学\ntags: 图形学\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"数学基础入门","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v3008jaas6vfjadeqv"},{"title":"模拟实现一个bind","date":"2019-03-31T08:52:35.000Z","_content":"\n`bind`方法用来保留`JavaScript`的`this`指向， 和`apply`、`call`这两个方法不同的是，`bind`不会立即执行\n\n如何模拟实现一个`bind`方法\n\n初始函数，我们将对整个函数修改`this`指向\n```JavaScript\nfunction fn( name ) {\n  this.name = name\n}\n\nvar obj = { age: 18 }\n```\n## 最普通的实现\n创建一个函数\n```JavaScript\nfunction mybind(func ,context, ...args) {\n  return () => {\n    return func.apply(context, args  )\n  }\n}\n\nvar bindFn = mybind(fn, obj, '小明')\n```\n\n## 原型实现\n创建一个函数\n```JavaScript\nFunction.prototype.mybind = function(context, ...args) {\n  const _this = this\n  return  (...args2) => {\n    return _this.apply( context, [ ...args, ...args2] )\n  } \n}\n\nvar bindFn = fn.mybind(obj, '小明' )\n```\n\n\n\n实现很简单， 但是还差一步，就是`bind`后的函数， 拿来作为构造函数`new`时， `this`指向会出问题\n\n\n## 处理new 的指向\n\n```JavaScript\nFunction.prototype.mybind = function(context, ...args) {\n  const _this = this\n  function cbFn (...tempArgs) {\n    return this instanceof cbFn ? _this.apply(this, [ ...args, ...tempArgs]) : _this.apply( context, [ ...args, ...tempArgs] )\n  } \n  return cbFn\n}\nvar BindFn = fn.mybind(obj, '小明' )\nvar bfn = new BindFn()\n```\n\n\n参考文献\n* https://github.com/mqyqingfeng/Blog/issues/13\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/模拟实现一个bind.md","raw":"---\ntitle: 模拟实现一个bind\ndate: 2019-03-31 16:52:35\ncategories: JavaScript\ntags: JavaScript\n---\n\n`bind`方法用来保留`JavaScript`的`this`指向， 和`apply`、`call`这两个方法不同的是，`bind`不会立即执行\n\n如何模拟实现一个`bind`方法\n\n初始函数，我们将对整个函数修改`this`指向\n```JavaScript\nfunction fn( name ) {\n  this.name = name\n}\n\nvar obj = { age: 18 }\n```\n## 最普通的实现\n创建一个函数\n```JavaScript\nfunction mybind(func ,context, ...args) {\n  return () => {\n    return func.apply(context, args  )\n  }\n}\n\nvar bindFn = mybind(fn, obj, '小明')\n```\n\n## 原型实现\n创建一个函数\n```JavaScript\nFunction.prototype.mybind = function(context, ...args) {\n  const _this = this\n  return  (...args2) => {\n    return _this.apply( context, [ ...args, ...args2] )\n  } \n}\n\nvar bindFn = fn.mybind(obj, '小明' )\n```\n\n\n\n实现很简单， 但是还差一步，就是`bind`后的函数， 拿来作为构造函数`new`时， `this`指向会出问题\n\n\n## 处理new 的指向\n\n```JavaScript\nFunction.prototype.mybind = function(context, ...args) {\n  const _this = this\n  function cbFn (...tempArgs) {\n    return this instanceof cbFn ? _this.apply(this, [ ...args, ...tempArgs]) : _this.apply( context, [ ...args, ...tempArgs] )\n  } \n  return cbFn\n}\nvar BindFn = fn.mybind(obj, '小明' )\nvar bfn = new BindFn()\n```\n\n\n参考文献\n* https://github.com/mqyqingfeng/Blog/issues/13\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"模拟实现一个bind","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v4008naas6ig9h8log"},{"title":"简单理解微服务架构","date":"2019-03-26T08:18:57.000Z","_content":"\n![微服务](http://img.nixiaolei.com/2019-04-06-16-21-09.png)\n\n## 1.1 单体应用与微服务\n> 微服务对应的是传统架构， 传统的软件架构是把所有都打在一个包里面， 也就是单体应用。\n\n\n单体应用在部署上和后期管理维护上会愈来愈越庞大和难以管理， 而且约束开发成员使用的技术栈， `JAVA`的程序必须使用`JAVA`, 但是可能团队里有的擅长`PHP`，有的擅长`Go`。 针对这些问题就有人提出了微服务的概念， 可以让适合的语言干适合的事情。\n\n\n单体应用想要增加服务器只能把整个项目都丢到一台新的服务器上，但每个模块对并发的要求不一样， 比如产品服务模块是需求较多的，压力比较大， 但是订单模块需求就比较少，你也无法拆开，   而微服务不一样， 可以单独对`产品服务` 这个需求比较大的微服务进行增加服务器， 并且在功能升级时可以实现部分升级， 让用户感觉不到什么异样。\n\n\n![单体应用与微服务](http://img.nixiaolei.com/2019-04-06-17-25-10.png)\n\n## 2.1 微服务到底是什么\n> 微服务只是业务层面上的架构， 技术层面的架构属于你选用某框架\n\n* ✅微服务属于架构层面的设计模式【结构层面的设计模式】\n* ✅微服务的设计概念以**业务功能为主**\n* ✅微服务独立提供对应的业务功能\n* ✅微服务不拘泥于具体的实现语言\n* ✅微服务架构 ≈ 模块化开发 + 分布式计算\n\n\n### 2.1 易于扩展的分布式\n微服务的架构不管是横向扩展还是纵向扩展都比较的友好\n\n#### 2.1.1 横向扩展\n针对业务进行扩展， 当需要新增业务时只需要增加一个微服务即可\n\n#### 2.1.2 纵向扩展\n纵向扩展是对计算压力上的扩展， 针对某一块增加服务器，增强其计算能力， 然后使用`Nginx`进行反向代理\n\n\n\n## 3.1 微服务的特点\n* 小, 且专注于做⼀件事情\n* 处于独立的进程中\n* 轻量级的通信机制\n* 松耦合、独立部署\n\n\n## 4.1 合理使用微服务\n微服务不是灵丹妙药，并不能适应所有的情况。 微服务需要在范围内被合理的使用。\n\n* 业务复杂度高\n* 团队规模大\n* 业务需要长期演进\n* 最后——没有银弹【人月神话】\n\n\n## 5.1 微服务——集成与部署\n* 持续集成——jekins\n* 虚拟化——虚拟机\n* 容器——Docker\n","source":"_posts/简单理解微服务架构.md","raw":"---\ntitle: 简单理解微服务架构\ndate: 2019-03-26 16:18:57\ncategories: 架构\ntags: [架构, 微服务]\n---\n\n![微服务](http://img.nixiaolei.com/2019-04-06-16-21-09.png)\n\n## 1.1 单体应用与微服务\n> 微服务对应的是传统架构， 传统的软件架构是把所有都打在一个包里面， 也就是单体应用。\n\n\n单体应用在部署上和后期管理维护上会愈来愈越庞大和难以管理， 而且约束开发成员使用的技术栈， `JAVA`的程序必须使用`JAVA`, 但是可能团队里有的擅长`PHP`，有的擅长`Go`。 针对这些问题就有人提出了微服务的概念， 可以让适合的语言干适合的事情。\n\n\n单体应用想要增加服务器只能把整个项目都丢到一台新的服务器上，但每个模块对并发的要求不一样， 比如产品服务模块是需求较多的，压力比较大， 但是订单模块需求就比较少，你也无法拆开，   而微服务不一样， 可以单独对`产品服务` 这个需求比较大的微服务进行增加服务器， 并且在功能升级时可以实现部分升级， 让用户感觉不到什么异样。\n\n\n![单体应用与微服务](http://img.nixiaolei.com/2019-04-06-17-25-10.png)\n\n## 2.1 微服务到底是什么\n> 微服务只是业务层面上的架构， 技术层面的架构属于你选用某框架\n\n* ✅微服务属于架构层面的设计模式【结构层面的设计模式】\n* ✅微服务的设计概念以**业务功能为主**\n* ✅微服务独立提供对应的业务功能\n* ✅微服务不拘泥于具体的实现语言\n* ✅微服务架构 ≈ 模块化开发 + 分布式计算\n\n\n### 2.1 易于扩展的分布式\n微服务的架构不管是横向扩展还是纵向扩展都比较的友好\n\n#### 2.1.1 横向扩展\n针对业务进行扩展， 当需要新增业务时只需要增加一个微服务即可\n\n#### 2.1.2 纵向扩展\n纵向扩展是对计算压力上的扩展， 针对某一块增加服务器，增强其计算能力， 然后使用`Nginx`进行反向代理\n\n\n\n## 3.1 微服务的特点\n* 小, 且专注于做⼀件事情\n* 处于独立的进程中\n* 轻量级的通信机制\n* 松耦合、独立部署\n\n\n## 4.1 合理使用微服务\n微服务不是灵丹妙药，并不能适应所有的情况。 微服务需要在范围内被合理的使用。\n\n* 业务复杂度高\n* 团队规模大\n* 业务需要长期演进\n* 最后——没有银弹【人月神话】\n\n\n## 5.1 微服务——集成与部署\n* 持续集成——jekins\n* 虚拟化——虚拟机\n* 容器——Docker\n","slug":"简单理解微服务架构","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v6008raas6shjzvyr8"},{"title":"简单理解破解与脱壳","date":"2019-03-28T07:41:01.000Z","_content":"\n## 什么是壳\n想要破解别人的程序， 必然要对别人代码进行分析， 分析手段无非两种:\n1. 静态分析\n2. 动态分析\n\n利用动态分析就可以绕过类似注册码的步骤\n\n如何避免别人通过分析绕过注册码等步骤呢， 就需要对程序加一层壳， \n\n当你程序在载入到内存的时候， 要先去检查一下环境，看看自身是否跑在调试器的环境里， 如果在调试器的环境，就要把调试器的环境破坏掉，不让你进行动态分析，\n\n这就是加壳的一种手段\n\n\n或者还有其他的手段， 例如，把真正的程序压缩到其他地方， 当启动`exe`程序时再将真正的程序解压缩， 用来防止动态分析\n\n\n\n> 脱壳就是扒掉这层防护\n\n\n\n### 静态分析\n静态分析就是直接去看别人的源代码， 当然别人写的C的源代码你是看不到的， 必须进行反编译， 但是反编译也不是那么的完美， 无法恢复回原来的样子， 会非常难以理解。\n\n### 动态分析\n类似于`debugger`, 借助调试器，  可以看到代码的当前执行状况， 跳转地址、内存当中的状态\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/简单理解破解与脱壳.md","raw":"---\ntitle: 简单理解破解与脱壳\ndate: 2019-03-28 15:41:01\ncategories: 计算机基础\ntags: [计算机基础, 破解]\n---\n\n## 什么是壳\n想要破解别人的程序， 必然要对别人代码进行分析， 分析手段无非两种:\n1. 静态分析\n2. 动态分析\n\n利用动态分析就可以绕过类似注册码的步骤\n\n如何避免别人通过分析绕过注册码等步骤呢， 就需要对程序加一层壳， \n\n当你程序在载入到内存的时候， 要先去检查一下环境，看看自身是否跑在调试器的环境里， 如果在调试器的环境，就要把调试器的环境破坏掉，不让你进行动态分析，\n\n这就是加壳的一种手段\n\n\n或者还有其他的手段， 例如，把真正的程序压缩到其他地方， 当启动`exe`程序时再将真正的程序解压缩， 用来防止动态分析\n\n\n\n> 脱壳就是扒掉这层防护\n\n\n\n### 静态分析\n静态分析就是直接去看别人的源代码， 当然别人写的C的源代码你是看不到的， 必须进行反编译， 但是反编译也不是那么的完美， 无法恢复回原来的样子， 会非常难以理解。\n\n### 动态分析\n类似于`debugger`, 借助调试器，  可以看到代码的当前执行状况， 跳转地址、内存当中的状态\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"简单理解破解与脱壳","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v7008uaas67s21usea"},{"title":"计算机语言的本源与发展","date":"2019-03-18T04:42:07.000Z","_content":"\n* 本源：二进制数据\n* 第一代语言：机器指令 （痛苦指数 ✮✮✮✮✮）\n* 第二代语言：汇编指令（痛苦指数 ✮✮✮✮✩）\n* 第三代语言：高级语言（主要特征：面向过程）\n* 第四代语言：面向对象语言（面向互联网、天然支持数据库）\n\n\n\n![语言发展史](http://img.nixiaolei.com/2019-04-06-13-46-58.png)\n\n\n","source":"_posts/计算机语言的本源与发展.md","raw":"---\ntitle: 计算机语言的本源与发展\ndate: 2019-03-18 12:42:07\ncategories: 计算机基础\ntags: 计算机基础\n---\n\n* 本源：二进制数据\n* 第一代语言：机器指令 （痛苦指数 ✮✮✮✮✮）\n* 第二代语言：汇编指令（痛苦指数 ✮✮✮✮✩）\n* 第三代语言：高级语言（主要特征：面向过程）\n* 第四代语言：面向对象语言（面向互联网、天然支持数据库）\n\n\n\n![语言发展史](http://img.nixiaolei.com/2019-04-06-13-46-58.png)\n\n\n","slug":"计算机语言的本源与发展","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v7008xaas6sjxpmqwf"},{"title":"面试题集合","date":"2019-03-20T09:40:34.000Z","_content":"\n## 事件机制\n\n### Promise\n\n#### 题目一: \n```JavaScript\nsetTimeout(() => {\n  console.log(4)\n}, 0)\nnew Promise(resolve => {\n  console.log(1)\n  setTimeout(() => {\n    resolve(\"done\")\n    console.log(6)\n  }, 0)\n  resolve(5)\n}).then((res) => {\n  // 微任务\n  console.log(res)\n})\nconsole.log(2)\n```\n\n**答案:**\n> 1 , 2 , 5 , 4, 6\n\n注意， 没有`done`！\n\n\n**分析:**\n`Promise` 的`resolve`只会触发一次， 因为`Promise`的状态已经被修改为`resolve`\n\n所以第二次的`resolve` 不会触发\n\n\n#### 题目二:\n```JavaScript\nsetTimeout(() => {\n  console.log(4)\n}, 0)\nnew Promise(resolve => {\n  console.log(1)\n  new Promise(resolve => {\n    console.log(7)\n    setTimeout(() => {\n      resolve(\"done\")\n      console.log(\"aa\")\n    }, 0)\n    resolve(8)\n  }).then((res) => {\n    console.log(res)\n  })\n  resolve(5)\n}).then((res) => {\n  console.log(res)\n})\nconsole.log(2)\n```\n\n**答案:**\n> 1, 7, 2, 8 , 5 , 4 , aa\n\n\n**分析:**\n`Promise`的完成先后还得看谁先挂载了 `then`， 并不是谁先`new`就是谁\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## ES6系列\n\n### async await:\n#### 题目一: async 什么原理 ?\n\n**例子:**\n```JavaScript\nasync function  test () {\n  let result = await 10 \n}\ntest()\n```\n\n经过 Babel 转换\n```JavaScript\nwhile (1) {\n  switch (_context.prev = _context.next) {\n    case 0:\n      _context.next = 2;\n      return 10;\n\n    case 2:\n      result = _context.sent;\n\n    case 3:\n    case \"end\":\n      return _context.stop();\n  }\n```\n\n**分析**\n我们可以看到，经过`babel` 转换过的 `async await` 代码中关键的这句， `while`循环， 并且是一个死循环， `babel` 就是这样来模拟 `async await`的， 当`await`返回结果时， `_context.stop`抛出异常退出死循环 , `babel`这样做也是为了更好的捕获异常\n\n\n\n#### 题目二: 请问result输出几 ?\n```JavaScript\nvar a = 0\nasync function  test () {\n  let result = a + await 10\n  console.log(result)\n}\ntest()\na = a + 1\ntest()\n```\n**答案:**\n> 10  , 11\n\n**分析:**\n1. `await` 后如果是一个常量, 将作为 `Promise.resolve`的结果返回\n2. 因为 `async await` 是 `generator`的语法糖， 当执行 `test` 方法时， 变量`a`的值会被锁住\n\n所以第一个结果是`10`， 第二个结果是 `11`\n\n\n\n### Promise\n#### 题目一: 请用 ES5实现ES6 Promise A+规范的代码， 用时你能解释下如何使用Promise完成事务的操作吗\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/面试题集合.md","raw":"---\ntitle: 面试题集合\ndate: 2019-03-20 17:40:34\ncategories: 面试\ntags: [面试]\n---\n\n## 事件机制\n\n### Promise\n\n#### 题目一: \n```JavaScript\nsetTimeout(() => {\n  console.log(4)\n}, 0)\nnew Promise(resolve => {\n  console.log(1)\n  setTimeout(() => {\n    resolve(\"done\")\n    console.log(6)\n  }, 0)\n  resolve(5)\n}).then((res) => {\n  // 微任务\n  console.log(res)\n})\nconsole.log(2)\n```\n\n**答案:**\n> 1 , 2 , 5 , 4, 6\n\n注意， 没有`done`！\n\n\n**分析:**\n`Promise` 的`resolve`只会触发一次， 因为`Promise`的状态已经被修改为`resolve`\n\n所以第二次的`resolve` 不会触发\n\n\n#### 题目二:\n```JavaScript\nsetTimeout(() => {\n  console.log(4)\n}, 0)\nnew Promise(resolve => {\n  console.log(1)\n  new Promise(resolve => {\n    console.log(7)\n    setTimeout(() => {\n      resolve(\"done\")\n      console.log(\"aa\")\n    }, 0)\n    resolve(8)\n  }).then((res) => {\n    console.log(res)\n  })\n  resolve(5)\n}).then((res) => {\n  console.log(res)\n})\nconsole.log(2)\n```\n\n**答案:**\n> 1, 7, 2, 8 , 5 , 4 , aa\n\n\n**分析:**\n`Promise`的完成先后还得看谁先挂载了 `then`， 并不是谁先`new`就是谁\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## ES6系列\n\n### async await:\n#### 题目一: async 什么原理 ?\n\n**例子:**\n```JavaScript\nasync function  test () {\n  let result = await 10 \n}\ntest()\n```\n\n经过 Babel 转换\n```JavaScript\nwhile (1) {\n  switch (_context.prev = _context.next) {\n    case 0:\n      _context.next = 2;\n      return 10;\n\n    case 2:\n      result = _context.sent;\n\n    case 3:\n    case \"end\":\n      return _context.stop();\n  }\n```\n\n**分析**\n我们可以看到，经过`babel` 转换过的 `async await` 代码中关键的这句， `while`循环， 并且是一个死循环， `babel` 就是这样来模拟 `async await`的， 当`await`返回结果时， `_context.stop`抛出异常退出死循环 , `babel`这样做也是为了更好的捕获异常\n\n\n\n#### 题目二: 请问result输出几 ?\n```JavaScript\nvar a = 0\nasync function  test () {\n  let result = a + await 10\n  console.log(result)\n}\ntest()\na = a + 1\ntest()\n```\n**答案:**\n> 10  , 11\n\n**分析:**\n1. `await` 后如果是一个常量, 将作为 `Promise.resolve`的结果返回\n2. 因为 `async await` 是 `generator`的语法糖， 当执行 `test` 方法时， 变量`a`的值会被锁住\n\n所以第一个结果是`10`， 第二个结果是 `11`\n\n\n\n### Promise\n#### 题目一: 请用 ES5实现ES6 Promise A+规范的代码， 用时你能解释下如何使用Promise完成事务的操作吗\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"面试题集合","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v90091aas6mg4jkx4r"},{"title":"面向对象设计原则之IOC控制反转","date":"2019-03-24T05:39:45.000Z","_content":"\n\n# IOC （控制反转）\n> Inversion of Control\n\nIoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚。\n\n\n## 什么是控制反转\n\n控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注⼊到对象中。\n\n\n> DI是IOC的一种表现形式\n\n\n\n## 两种方式\n\n### 依赖查找\n容器提供回调接口和上下文条件给组件。\n\n### 依赖注入\n组件不做定位查询， 需提供普通的方法让容器去决定依赖关系。\n\n\n\n\n## IOC概念图\n\n在未使用IOC的时候 各个 `Object` 之间的耦合度很高， 谁也离不开谁\n\n在使用 IOC 后， 各个 `Object` 之间通过 `IOC容器` 整个第三方角色来调度， 变成了可任意组装的模式， 谁需要的时候注入谁，  降低了耦合度\n\n![IOC概念图](http://img.nixiaolei.com/2019-03-24-13-49-37.png)\n\n\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/面向对象设计原则之IOC控制反转.md","raw":"---\ntitle: 面向对象设计原则之IOC控制反转\ndate: 2019-03-24 13:39:45\ncategories: [编程思想]\ntags: [oop, IOC, 编程原则]\n---\n\n\n# IOC （控制反转）\n> Inversion of Control\n\nIoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚。\n\n\n## 什么是控制反转\n\n控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注⼊到对象中。\n\n\n> DI是IOC的一种表现形式\n\n\n\n## 两种方式\n\n### 依赖查找\n容器提供回调接口和上下文条件给组件。\n\n### 依赖注入\n组件不做定位查询， 需提供普通的方法让容器去决定依赖关系。\n\n\n\n\n## IOC概念图\n\n在未使用IOC的时候 各个 `Object` 之间的耦合度很高， 谁也离不开谁\n\n在使用 IOC 后， 各个 `Object` 之间通过 `IOC容器` 整个第三方角色来调度， 变成了可任意组装的模式， 谁需要的时候注入谁，  降低了耦合度\n\n![IOC概念图](http://img.nixiaolei.com/2019-03-24-13-49-37.png)\n\n\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"面向对象设计原则之IOC控制反转","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4v90095aas6s81hq6g7"},{"title":"理解Iaas、PaaS、SaaS的区别","date":"2019-03-29T11:29:13.000Z","_content":"\n如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：\n买服务器，安装服务器软件，编写网站程序。\n\n## 😦Iaas\n> 比如: 普通的云服务器\n\n现在你追随潮流，采用流行的云计算，如果你采用IaaS服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件。\n\n## 😧PaaS\n> 比如: 阿里云的虚拟机\n\n而如果你采用PaaS的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序\n\n## 😨SaaS\n> 如淘宝对于商家\n\n如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为SaaS。\n\n\n\n参考文献\n* https://www.zhihu.com/question/20387284\n\n\n\n\n\n\n","source":"_posts/理解Iaas、PaaS、SaaS的区别.md","raw":"---\ntitle: 理解Iaas、PaaS、SaaS的区别\ndate: 2019-03-29 19:29:13\ncategories: 专业术语\ntags: 专业术语\n---\n\n如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：\n买服务器，安装服务器软件，编写网站程序。\n\n## 😦Iaas\n> 比如: 普通的云服务器\n\n现在你追随潮流，采用流行的云计算，如果你采用IaaS服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件。\n\n## 😧PaaS\n> 比如: 阿里云的虚拟机\n\n而如果你采用PaaS的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序\n\n## 😨SaaS\n> 如淘宝对于商家\n\n如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为SaaS。\n\n\n\n参考文献\n* https://www.zhihu.com/question/20387284\n\n\n\n\n\n\n","slug":"理解Iaas、PaaS、SaaS的区别","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4va0098aas658fdspzf"},{"title":"JavaScript事件机制","date":"2019-03-26T15:20:40.000Z","_content":"\n\n首先我们都知道JavaScript是单线程的， 当然现在浏览器中 HTML5 为我们提供了`Web-Worker`, 但JavaScript本质上还是一门单线程的语言，\n\n这也是为了保持JavaScript 的简单易学，并且这也和DOM有关，因为如果 JavaScript 是多线程的， 一个县城增加了 DOM，一个删除了DOM， 那该听哪个线程的\n\n所以JavaScript 放弃了多线程\n\n\n\n\n\n\n## 事件机制\n\n单线程当遇到比较费事的操作带来的后果就是浏览器卡死， 那怎么办？\n为了应对这些问题， JavaScript将事件分为了\n\n* 同步任务\n* 异步任务\n\n\n\n所有的事件任务都被加入到栈内,  栈的特点是先入后出， 如下图\n\n![js事件执行栈](http://img.nixiaolei.com/js-stack.gif)\n\n看图中， 最开始调用的函数被压在了最下面， 直到最后才出栈\n\n当我们递归书写不规范时， 就会撑爆函数的执行栈， 也就是`爆栈`\n\n\n\n\n\n## 微任务与宏任务的区别\n\n我们可以把事件处理机制想象成银行柜台的柜员， 柜员每次只能处理接待一个客户， 就和JS一样是单线程的， 每一次的事件循环就是一个来办理业务的客户， 这个客户就是宏任务， \n\n当前的客户结束之后， 柜员叫号，继续接待下一个客户， 也就是开始下一个宏任务\n\n能进入任务队列的都是已完成的异步操作， 当你注册了异步事件，但还未完成， 就好比你取了排队的票子， 但是人离开了，有可能先去吃饭，有可能先去逛街， 于是当轮到你的号码时， 银行柜员会先跳过你， 当你回来时， 你依旧需要重新排队\n\n在宏任务期间， 可以追加微任务的， 或者说微任务是可以插队的，  就像在柜台办理业务中， 一位大爷在办完自己的本来的业务后，  柜员通常都会问还有什么需要办理的业务， 这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。 \n\n所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。 \n也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？ \n无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。\n\n所以\n**在当前的微任务没有执行完成时，是不会执行下一个宏任务的**\n\n\n\n### 优先级\n\n不管是微任务还是宏任务， 都是异步任务， 当他们的事件处理完成后， 最终都是要归回到同步事件队列处理的， 也就是主进程， \n\n\n既然是主进程，主进程又要负责浏览器的渲染， 那这三者之间的优先级是什么呢\n\n\n因为微任务实际上是宏任务的其中一个步骤， 也就是下一次的宏任务到来之前必然得先执行完当前的宏任务的微任务, 所以可以这么看:\n> 浏览器渲染 > 微任务 > 宏任务\n\n微任务会插队， 插入每一次的执行栈末尾， 宏任务比较可怜， 只要存在微任务，就会被插队，顺序就会往后\n\n\n***\n\n看下图， 我们可以理解微任务和微任务分别维护着一个队列， 微任务的箭头指向靠前， 表示微任务会优先于宏任务加入事件队列，  宏任务会延迟加入\n\n理论上UI渲染的优先级是比较高的， 但实际上如果你的微任务或宏任务之内， 出现了死循环或大量计算的情况， UI渲染就会被阻塞住， 无法进行，也就是页面卡死状态， 毕竟js单线程\n\n\n![事件关系](http://img.nixiaolei.com/2019-03-29-22-31-43.png)\n\n\n\n\n## EventLoop\n\n每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。_（检查还有没有微任务需要处理）_ \n而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。_（结束本次宏任务、检查还有没有宏任务需要处理）_ \n这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。_(这是个非常简易的描述了，实际上会复杂很多)_\n\n而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 宏任务例子\n| API        | 浏览器    |  Node  |\n| --------   | :-----:   | :----: |\n| I/O      | ✅     |  ✅  |\n| setTimeout        | ✅     |   ✅    |\n| setInterval        | ✅      |  ✅  |\n| setImmediate        |❌     |  ✅    |\n| requestAnimationFrame        | ✅     |  ❌  |\n\n\nI/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。\n\n\n有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了[HTML规范文档](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)以后，发现这很显然是和微任务平行的一个操作步骤 \n\n\n\nrequestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行\n\n\n\n\n### 微任务例子\n| API        | 浏览器    |  Node  |\n| --------   | :-----:   | :----: |\n| process.nextTick      | ❌     |  ✅  |\n| MutationObserver        | ✅     |  ❌   |\n| Promise.then catch finally       | ✅      |  ✅  |\n| MessageChannel 消息队列    |      |    |\n\n\n\n## 浏览器中的情况\n\n在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？ \n首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）\n\nI/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。\n\n假设有这样的一些DOM结构：\n```HTML\n<style>\n  #outer {\n    padding: 20px;\n    background: #616161;\n  }\n\n  #inner {\n    width: 100px;\n    height: 100px;\n    background: #757575;\n  }\n</style>\n<div id=\"outer\">\n  <div id=\"inner\"></div>\n</div>\n```\n\n```JavaScript\nconst $inner = document.querySelector('#inner')\nconst $outer = document.querySelector('#outer')\n\nfunction handler () {\n  console.log('click') // 直接输出\n\n  Promise.resolve().then(_ => console.log('promise')) // 注册微任务\n\n  setTimeout(_ => console.log('timeout')) // 注册宏任务\n\n  requestAnimationFrame(_ => console.log('animationFrame')) // 注册宏任务\n\n  $outer.setAttribute('data-random', Math.random()) // DOM属性修改，触发微任务\n}\n\nnew MutationObserver(_ => {\n  console.log('observer')\n}).observe($outer, {\n  attributes: true\n})\n\n$inner.addEventListener('click', handler)\n$outer.addEventListener('click', handler)\n\n```\n\n如果点击#inner，其执行顺序一定是：click -> promise -> observer -> click -> promise -> observer -> animationFrame -> animationFrame -> timeout -> timeout。\n\n因为一次I/O创建了一个宏任务，也就是说在这次任务中会去触发handler。 \n按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了Promise和MutationObserver两个微任务，遂执行之。 \n因为click事件会冒泡，所以对应的这次I/O会触发两次handler函数(_一次在inner、一次在outer_)，所以会优先执行冒泡的事件(_早于其他的宏任务_)，也就是说会重复上述的逻辑。 \n在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。 \n需要注意的一点是，因为我们触发了setAttribute，实际上修改了DOM的属性，这会导致页面的重绘，而这个set的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。\n\n\n## Node Js中的情况\nNode也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，这里是[Node官方文档](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained)的地址。\n\n\n就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。\n\n\n### 几个特殊的API\n1. SetTimeout和SetInterval 线程池不参与\n2. process.nextTick() 实现类似SetTimeout(function(){},0);每次调用放入队列中，在下一轮循环中取出。\n3. setImmediate();比process.nextTick()优先级低\n\n\n来看看这段代码\n\n```JavaScript\nsetTimeout(() => {\n  console.log(1)\n}, 0)\n\nsetImmediate(() => {\n  console.log(2)\n})\n\nprocess.nextTick(() => {\n  console.log(3)\n})\n\nnew Promise((resolve, reject) => {\n  console.log(4)\n  resolve(4)\n}).then(() => {\n  console.log(5)\n})\n\nconsole.log(6)\n```\n\n这道题目的答案是 463512\n\n这里有几个注意点， 第一就是 nextTick ，它的优先级比 promise.then 要高， 如下图， 它加入队列的方式属于插队行为, 它直接加入到了当前执行栈（同步队列）与 下一次的等待执行栈之间\n\n![nextTick](http://img.nixiaolei.com/2019-03-29-22-45-02.png)\n\n\n我们都知道 then 比 setTimeout 优先级高\n\n然后就是 setTimeout 和 setImmediate 的问题了，\n\nsetImmediate与setTimeout的区别，在官方文档中的定义，setImmediate为一次Event Loop执行完毕后调用。 setTimeout则是通过计算一个延迟时间后进行执行。\n\n但是在实际使用中， 当setTimeout 设置为0时， 他们都是放在队列最后,  所以执行顺序就是谁先写就先执行谁了， 但当setTimeout 设置的时间大于0 时（最低延迟会被忽略）， 情况就不一样了， setTmmediate 会先被执行\n\n![setImmediate](http://img.nixiaolei.com/2019-03-29-22-45-25.png)\n\n\n\n\n参考文献(原文写的不错， 所以我大部分是复制，方便之后自己回顾理解)\n* https://segmentfault.com/a/1190000016022069\n\n\n\n\n\n\n\n\n","source":"_posts/JavaScript事件机制.md","raw":"---\ntitle: JavaScript事件机制\ndate: 2019-03-26 23:20:40\ncategories: JavaScript\ntags: JavaScript\n---\n\n\n首先我们都知道JavaScript是单线程的， 当然现在浏览器中 HTML5 为我们提供了`Web-Worker`, 但JavaScript本质上还是一门单线程的语言，\n\n这也是为了保持JavaScript 的简单易学，并且这也和DOM有关，因为如果 JavaScript 是多线程的， 一个县城增加了 DOM，一个删除了DOM， 那该听哪个线程的\n\n所以JavaScript 放弃了多线程\n\n\n\n\n\n\n## 事件机制\n\n单线程当遇到比较费事的操作带来的后果就是浏览器卡死， 那怎么办？\n为了应对这些问题， JavaScript将事件分为了\n\n* 同步任务\n* 异步任务\n\n\n\n所有的事件任务都被加入到栈内,  栈的特点是先入后出， 如下图\n\n![js事件执行栈](http://img.nixiaolei.com/js-stack.gif)\n\n看图中， 最开始调用的函数被压在了最下面， 直到最后才出栈\n\n当我们递归书写不规范时， 就会撑爆函数的执行栈， 也就是`爆栈`\n\n\n\n\n\n## 微任务与宏任务的区别\n\n我们可以把事件处理机制想象成银行柜台的柜员， 柜员每次只能处理接待一个客户， 就和JS一样是单线程的， 每一次的事件循环就是一个来办理业务的客户， 这个客户就是宏任务， \n\n当前的客户结束之后， 柜员叫号，继续接待下一个客户， 也就是开始下一个宏任务\n\n能进入任务队列的都是已完成的异步操作， 当你注册了异步事件，但还未完成， 就好比你取了排队的票子， 但是人离开了，有可能先去吃饭，有可能先去逛街， 于是当轮到你的号码时， 银行柜员会先跳过你， 当你回来时， 你依旧需要重新排队\n\n在宏任务期间， 可以追加微任务的， 或者说微任务是可以插队的，  就像在柜台办理业务中， 一位大爷在办完自己的本来的业务后，  柜员通常都会问还有什么需要办理的业务， 这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。 \n\n所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。 \n也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？ \n无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。\n\n所以\n**在当前的微任务没有执行完成时，是不会执行下一个宏任务的**\n\n\n\n### 优先级\n\n不管是微任务还是宏任务， 都是异步任务， 当他们的事件处理完成后， 最终都是要归回到同步事件队列处理的， 也就是主进程， \n\n\n既然是主进程，主进程又要负责浏览器的渲染， 那这三者之间的优先级是什么呢\n\n\n因为微任务实际上是宏任务的其中一个步骤， 也就是下一次的宏任务到来之前必然得先执行完当前的宏任务的微任务, 所以可以这么看:\n> 浏览器渲染 > 微任务 > 宏任务\n\n微任务会插队， 插入每一次的执行栈末尾， 宏任务比较可怜， 只要存在微任务，就会被插队，顺序就会往后\n\n\n***\n\n看下图， 我们可以理解微任务和微任务分别维护着一个队列， 微任务的箭头指向靠前， 表示微任务会优先于宏任务加入事件队列，  宏任务会延迟加入\n\n理论上UI渲染的优先级是比较高的， 但实际上如果你的微任务或宏任务之内， 出现了死循环或大量计算的情况， UI渲染就会被阻塞住， 无法进行，也就是页面卡死状态， 毕竟js单线程\n\n\n![事件关系](http://img.nixiaolei.com/2019-03-29-22-31-43.png)\n\n\n\n\n## EventLoop\n\n每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。_（检查还有没有微任务需要处理）_ \n而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。_（结束本次宏任务、检查还有没有宏任务需要处理）_ \n这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。_(这是个非常简易的描述了，实际上会复杂很多)_\n\n而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 宏任务例子\n| API        | 浏览器    |  Node  |\n| --------   | :-----:   | :----: |\n| I/O      | ✅     |  ✅  |\n| setTimeout        | ✅     |   ✅    |\n| setInterval        | ✅      |  ✅  |\n| setImmediate        |❌     |  ✅    |\n| requestAnimationFrame        | ✅     |  ❌  |\n\n\nI/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。\n\n\n有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了[HTML规范文档](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)以后，发现这很显然是和微任务平行的一个操作步骤 \n\n\n\nrequestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行\n\n\n\n\n### 微任务例子\n| API        | 浏览器    |  Node  |\n| --------   | :-----:   | :----: |\n| process.nextTick      | ❌     |  ✅  |\n| MutationObserver        | ✅     |  ❌   |\n| Promise.then catch finally       | ✅      |  ✅  |\n| MessageChannel 消息队列    |      |    |\n\n\n\n## 浏览器中的情况\n\n在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？ \n首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）\n\nI/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。\n\n假设有这样的一些DOM结构：\n```HTML\n<style>\n  #outer {\n    padding: 20px;\n    background: #616161;\n  }\n\n  #inner {\n    width: 100px;\n    height: 100px;\n    background: #757575;\n  }\n</style>\n<div id=\"outer\">\n  <div id=\"inner\"></div>\n</div>\n```\n\n```JavaScript\nconst $inner = document.querySelector('#inner')\nconst $outer = document.querySelector('#outer')\n\nfunction handler () {\n  console.log('click') // 直接输出\n\n  Promise.resolve().then(_ => console.log('promise')) // 注册微任务\n\n  setTimeout(_ => console.log('timeout')) // 注册宏任务\n\n  requestAnimationFrame(_ => console.log('animationFrame')) // 注册宏任务\n\n  $outer.setAttribute('data-random', Math.random()) // DOM属性修改，触发微任务\n}\n\nnew MutationObserver(_ => {\n  console.log('observer')\n}).observe($outer, {\n  attributes: true\n})\n\n$inner.addEventListener('click', handler)\n$outer.addEventListener('click', handler)\n\n```\n\n如果点击#inner，其执行顺序一定是：click -> promise -> observer -> click -> promise -> observer -> animationFrame -> animationFrame -> timeout -> timeout。\n\n因为一次I/O创建了一个宏任务，也就是说在这次任务中会去触发handler。 \n按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了Promise和MutationObserver两个微任务，遂执行之。 \n因为click事件会冒泡，所以对应的这次I/O会触发两次handler函数(_一次在inner、一次在outer_)，所以会优先执行冒泡的事件(_早于其他的宏任务_)，也就是说会重复上述的逻辑。 \n在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。 \n需要注意的一点是，因为我们触发了setAttribute，实际上修改了DOM的属性，这会导致页面的重绘，而这个set的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。\n\n\n## Node Js中的情况\nNode也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，这里是[Node官方文档](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained)的地址。\n\n\n就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。\n\n\n### 几个特殊的API\n1. SetTimeout和SetInterval 线程池不参与\n2. process.nextTick() 实现类似SetTimeout(function(){},0);每次调用放入队列中，在下一轮循环中取出。\n3. setImmediate();比process.nextTick()优先级低\n\n\n来看看这段代码\n\n```JavaScript\nsetTimeout(() => {\n  console.log(1)\n}, 0)\n\nsetImmediate(() => {\n  console.log(2)\n})\n\nprocess.nextTick(() => {\n  console.log(3)\n})\n\nnew Promise((resolve, reject) => {\n  console.log(4)\n  resolve(4)\n}).then(() => {\n  console.log(5)\n})\n\nconsole.log(6)\n```\n\n这道题目的答案是 463512\n\n这里有几个注意点， 第一就是 nextTick ，它的优先级比 promise.then 要高， 如下图， 它加入队列的方式属于插队行为, 它直接加入到了当前执行栈（同步队列）与 下一次的等待执行栈之间\n\n![nextTick](http://img.nixiaolei.com/2019-03-29-22-45-02.png)\n\n\n我们都知道 then 比 setTimeout 优先级高\n\n然后就是 setTimeout 和 setImmediate 的问题了，\n\nsetImmediate与setTimeout的区别，在官方文档中的定义，setImmediate为一次Event Loop执行完毕后调用。 setTimeout则是通过计算一个延迟时间后进行执行。\n\n但是在实际使用中， 当setTimeout 设置为0时， 他们都是放在队列最后,  所以执行顺序就是谁先写就先执行谁了， 但当setTimeout 设置的时间大于0 时（最低延迟会被忽略）， 情况就不一样了， setTmmediate 会先被执行\n\n![setImmediate](http://img.nixiaolei.com/2019-03-29-22-45-25.png)\n\n\n\n\n参考文献(原文写的不错， 所以我大部分是复制，方便之后自己回顾理解)\n* https://segmentfault.com/a/1190000016022069\n\n\n\n\n\n\n\n\n","slug":"JavaScript事件机制","published":1,"updated":"2019-09-09T16:57:46.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4wy00g5aas62jobfnfk"},{"title":"TypeScript手册","date":"2019-03-18T14:41:51.000Z","_content":"\n\n\nTypeScript是JavaScript的超集\n\n## 开发环境搭建\n> 我的环境: window10 + vscode\n\n全局安装Ts\n> npm i -g typescript\n\n生成并配置`tsconfig.json`\n> tsc --init\n\n\n配置文件， 下面的配置中`ts`应存放在`src` 目录下， 并且会自动编译到dist文件夹下\n```JavaScript\n{\n  \"compilerOptions\": {\n    \"target\": \"es2017\",                         // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'\n    \"module\": \"commonjs\",                       // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"moduleResolution\": \"node\",                 // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)\n    \"emitDecoratorMetadata\": true,              // 为装饰器提供元数据的支持\n    \"experimentalDecorators\": true,             // 启用装饰器\n    \"allowSyntheticDefaultImports\": true,       // 允许从没有设置默认导出的模块中默认导入。\n    \"strict\": true,                             // 启用所有严格类型检查选项\n    \"noImplicitAny\": true,                      // 在表达式和声明上有隐含的 any类型时报错\n    \"alwaysStrict\": true,                       // 以严格模式检查没个模块，并在没个文件里加入 'use strict'\n    \"sourceMap\": true,\n    \"noEmit\": false,                            // 不生成输出文件\n    \"removeComments\": true,                     // 删除编译后的所有的注释\n    \"importHelpers\": true,                      // 从 tslib 导入辅助工具函数\n    \"strictNullChecks\": true,                   // 启用严格的 null 检查\n    \"lib\": [\"es2017\"],                          // 指定要包含在编译中的库文件\n    \"typeRoots\": [\"node_modules/@types\"],\n    \"types\": [\n      \"node\",\n    ],\n    \"outDir\": \"./dist\",                        // 编译后文件产出目录\n    \"rootDir\": \"./src\"                          // 你的ts文件目录\n  },\n  \"include\": [                                 // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题\n    \"./src/*.ts\",\n    \"./src/**/*.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\",\n    \"public\"\n  ]\n}\n```\n\n快速生成`package.json`\n> npm init -y\n\n\n运行命令， 开始监听\n> tsc -w\n\n\n是否有效呢？ 让我们来试一下\n\n\n进入src目录新建一个 `hello.ts`，记得是`.ts`， 不要写习惯了打成`.js`😅\n\n随便写点东西， 比如定义一个字符串类型:\n```TypeScript\nvar a:string = \"hello world\"\n```\n\n如果你配置没有问题的话， 我们就会看到他监听文件修改并编译\n\n这是ts文件与 编译后的js文件\n\n![编译前后](http://img.nixiaolei.com/2019-03-18-22-50-51.png)\n\n\n并且在他运行过程中， 我们可以按`F5`进行调试\n\n\n\n\n\n\n## 基本数据类型\n* Boolean\n* Number\n* String\n* Array\n* Enum\n* Any\n* Void\n\n\n简单的几种数据的定义\n```TypeScript\n// 定义一个Boolean\nvar a:boolean = true\n// 定义一个Number\nvar a:number = 13\n// 定义一个 String \nvar a:string = \"13\"\n```\n\n基本的数据结构定义\n```TypeScript\nvar list:number[] = [1,2,3]\n\n\n```\n\n\n## 接口\n> interfaces\n\n### 基础接口\n\n没有接口时我们如何规范参数类型\n```JavaScript\nfunction fn(dog:{name:string}) {\n  console.log(dog.name)\n}\nvar myObj = { name: \"Hello\" }\nfn(myObj)\n```\n\n有了接口， 我们就可以把参数规定与函数分离\n\n如何创建接口\n\n通过 `interface` 关键字来声明\n\n```JavaScript\ninterface dogValue {\n  name:string;\n}\n\n// 指定参数`dog`是接口类型\nfunction fn(dog: dogValue) {\n  console.log(dog.name)\n}\n\nvar myObj = { name: \"Hello\" }\nfn(myObj)  // 编译通过\n```\n\n### 接口的可选属性\n接口定义的参数不一定每一个都会被用到\n\n\n\n## 泛型\n\n什么是泛型?\n\n泛型: 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型\n\n一句话理解就是：  参数化类型（把类型当作是参数一样传递）\n\n使用泛型的好处:\n* 代码更加简洁【不用强制转换】\n* 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】\n* 可读性和稳定性【在编写集合的时候，就限定了类型】\n\n\n指定一个最简单的泛型\n```TypeScript\nfunction Hello<T>(arg:T):T {\n  return arg;\n}\n```\n\n\n\n\n## Module 模块\n\nModule 模式是常见的JavaScript模式之一， 在ES6的模块话实现之前， 人们通常通过 IFEE 来实现Module\n\nModule 的好处\n1. 模块化\n2. 可重用\n3. 封装变量和函数\n\n\n\n来看看在ES6之前是如何书写的\n```JavaScript\n(function() {\n  // do somtiong\n}());\n```\n\n\n让我们来看一个例子， 使用 TS 的 Module 来防止调用多种 interface 时的麻烦\n\n使用Module之前\n```TypeScript\ninterface StringValidator {\n  // 接口定义的方法\n  isAcceptable(s:string):boolean;\n}\nvar lettersRegexp = /^[A-Za-z]+$]/;\nvar numberRegexp = /^[0-9]+$/;\n// 实现接口的方法\nclass LettersOnlyValidator implements StringValidator {\n  isAcceptable(s:string):boolean {\n    return lettersRegexp.test(s)\n  }\n} \nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s:string):boolean {\n    return s.length === 5 && numberRegexp.test(s)\n  }\n}\n```\n\n使用了Module 的书写方式后\n\n```TypeScript\nmodule Validation {\n  // 需要使用 export 来表示对外暴露\n  export interface StringValidator {\n    isAcceptable(s:string): boolean;\n  }\n\n  var lettersRegexp = /^[A-Za-z]+$]/;\n  var numberRegexp = /^[0-9]+$/;\n\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s:string) {\n      return lettersRegexp.test(s)\n    }\n  }\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s:string):boolean {\n      return s.length === 5 && numberRegexp.test(s)\n    }\n  }\n}\n```\n\n\nModule 与 类相结合使用\n```TypeScript\nmodule Person {\n  export class Student {\n    name: string;\n    constructor(name:string) {\n      this.name = name;\n    }\n    study() {\n      console.log(this.name + '在学习')\n    }\n    speak() {\n      console.log(this.name + '在说话')\n    }\n  }\n}\n\n// ----------- 使用时 -------------\n\nconst xiaoming = new Person.Student('小明')\nxiaoming.study()\n\n```\n\n\n\n## Namespaces\n\nNamespaces 的和Module 的用法相同，  在Ts 的1.5 版本后， 用 Namespaces 取代了 Module \n\n查看一下官方的示例\n\n```TypeScript\nnamespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'\n```\n\n\n## 装饰器 < Decorators >\n\n如何定义一个装饰器\n\n其实装饰器就是一个普通的函数， 他接收一个参数`target` ，这个参数就是被装饰对象， 看下面的例子， `sealed` 装饰了`Dog`类， 并且在`sealed` 中打印了 `target` ， 让我们看看 `target`到底是什么？\n```TypeScript\nfunction sealed(target:any) {\n  // do something with 'target' ...\n  console.log(target)\n  return target\n}\n\n\n// 被装饰的对象 foo\n@sealed\nclass Dog {\n\n}\n```\n\n打印结果\n![使用装饰器](http://img.nixiaolei.com/2019-03-22-22-06-26.png)\n\n我们可以看到， 得到的正是 `Dog`这个类\n\n\n\n### 装饰器工厂< Decorator Factories >\n\n> 如果希望自定义如何将装饰器应用于声明，可以编写装饰器工厂。装饰器工厂只是一个函数，它返回将在运行时由装饰器调用的表达式。\n\n\n装饰器工厂和普通装饰器相比的好处就是更加的自定义了， 可以根据不同情况自定义效果\n\n\n如何定义一个`装饰器工厂`\n\n```TypeScript\nfunction dec(value:string) {\n  return function (target:any)  {\n    console.log(value)\n    console.log(target)    \n  }\n}\n\n// 在这里使用并传入自定义的参数\n@dec('test')\nclass Cat {\n  \n}\n```\n\n让我们来看看运行的结果\n\n![定义装饰器工厂](http://img.nixiaolei.com/2019-03-22-22-22-55.png)\n\n可以看到，我们传入的`test`字符串和 `Cat`类都被打印出来了，\n\n### 多装饰器的执行顺序\n使用多个装饰器时如何书写呢?\n\n当我们使用多个装饰器时有两种写法\n\n1. 写成一行\n```TypeScript\n@f @g x\n```\n2. 垂直书写\n```TypeScript\n@f\n@g\nx\n```\n**多个装饰器的执行顺序是如何的呢？**\n\n套用官网的说明\n1. 对每个装饰器的表达式进行自上而下的计算。\n2. 然后将结果作为自下而上的函数调用。\n\n\n其实真实的运行原理是\n```TypeScript\nf(g(x))\n```\n\n### 访问器修饰器\n\n访问器修饰器的接收的参数和方法修饰器接收的参数一样\n\n\n```TypeScript\nfunction dec(value:string) {\n  return function (target:any, propertyKey: string, descriptor: PropertyDescriptor)  {\n  }\n}\n\n// 在这里使用并传入自定义的参数\n@dec('test')\nclass Cat {\n  private _x: number;\n  private _y: number;\n\n  constructor(x: number, y: number) {\n    this._x = x\n    this._y = y\n  }\n  // 访问器修饰器\n  @dec(true)\n  get  x() { return this._x }\n  @dec(false)\n  get  y() { return this._y }\n}\n```\n\n\n### 属性修饰器\n\n属性修饰器只有前两个参数\n```TypeScript\nfunction dec(value:string) {\n  return function (target:any, propertyKey: string)  {\n  }\n}\n\n// 在这里使用并传入自定义的参数\n@dec('test')\nclass Cat {\n  private _x: number;\n  private _y: number;\n\n  constructor(x: number, y: number) {\n    // 属性修饰器\n    @dec(false)\n    this._x = x\n    this._y = y\n  }\n}\n```\n\n### 参数修饰器\n参数修饰器也是三个参数， 但不同的是第三个参数接收\n\n**参数装饰器只能确认一个方法的参数是否被传入**\n\n\n前两个和其他的修饰器都相同， \n\n1. target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象\n2. propertyKey 成员的名称\n3. 参数在所处函数的参数列表中的索引， 说人话就是告诉你他是第几个参数\n\n\n\n```TypeScript\nfunction require(value:boolean) {\n  return function (target:any, propertyKey: string, index: number)  {\n  }\n}\n\n// 在这里使用并传入自定义的参数\n@dec('test')\nclass Cat {\n  run(@require(true) name:string) {\n  }\n}\n```\n\n\n### 装饰器参数\n\n1. 类装饰器\n\n类装饰器的参数只接收一个， 那就是`target` 也就是这个类本身\n\n就和上面演示的那些例子一样\n\n\n2. 方法装饰器\n\n一般会传入三个参数\n\n1. target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象\n2. propertyKey 成员的名称\n3. descriptor 成员属性的描述符\n\n\n我们来验证下方法装饰器的参数\n\n让我们看看这段例子会输出什么\n```TypeScript\nfunction f(value:string) {\n  return function (target:any, propertyKey: string, descriptor: PropertyDescriptor)  {\n    console.log(arguments)\n    console.log(target)    \n  }\n}\n\nclass Tiger {\n  @f('tiger run')\n  run() {\n  }\n}\n```\n输入结果: \n\n![方法装饰器参数](http://img.nixiaolei.com/2019-03-23-11-35-28.png)\n\n\n在控制台输出， 我们看到了， \n第一个参数是 `tiger` 的实例对象（因为`run`是实例成员）\n\n第二个参数是成员名称， 也就是被装饰的`run`\n\n第三个参数是 `run` 的属性描述符\n\n\n## Mixins 混入\n除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。\n\n\nMixins 其实可以拆分为两个单词\n\nMix : 混合\n\nins : 是进入\n\n所以合在一起就是叫 `混入` 的意思的单词\n\n它想要表达的是一个对象中混入另一个对象的方法\n\n\n**让我们来实现一下Mixins**\n\n代码里首先定义两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。\n\n```TypeScript\n// Disposable Mixin\nclass Disposable {\n    isDisposed: boolean;\n    dispose() {\n        this.isDisposed = true;\n    }\n\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive: boolean;\n    activate() {\n        this.isActive = true;\n    }\n    deactivate() {\n        this.isActive = false;\n    }\n}\n```\n创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：\n```TypeScript\n\nclass SmartObject implements Disposable, Activatable { }\n```\n这里我们没有使用extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的。\n\n我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。\n\n也就是这样\n\n```TypeScript\nclass SmartObject implements Disposable, Activatable {\n  constructor() {\n      setInterval(() => console.log(this.isActive + \" : \" + this.isDisposed), 500);\n  }\n\n  interact() {\n      this.activate();\n  }\n\n  // Disposable\n  isDisposed: boolean = false;\n  dispose: () => void;\n  // Activatable\n  isActive: boolean = false;\n  activate: () => void;\n  deactivate: () => void;\n}\n```\n\n最后，把mixins混入定义的类，完成全部实现部分。\n```TypeScript\napplyMixins(SmartObject, [Disposable, Activatable]);\n```\n\n我们同时也需要创建这个帮助函数， 帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\n```TypeScript\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n      Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n          derivedCtor.prototype[name] = baseCtor.prototype[name];\n      })\n  });\n}\n```\n\n\n\n\n\n\n\n## 参考文献\n* https://segmentfault.com/a/1190000016305647\n\n\n-------------------------待完善——----------------------\n\n\n\n\n\n\n\n","source":"_posts/TypeScript手册.md","raw":"---\ntitle: TypeScript手册\ndate: 2019-03-18 22:41:51\ncategories: TypeScript\ntags: [ JavaScript, TypeScript ]\n---\n\n\n\nTypeScript是JavaScript的超集\n\n## 开发环境搭建\n> 我的环境: window10 + vscode\n\n全局安装Ts\n> npm i -g typescript\n\n生成并配置`tsconfig.json`\n> tsc --init\n\n\n配置文件， 下面的配置中`ts`应存放在`src` 目录下， 并且会自动编译到dist文件夹下\n```JavaScript\n{\n  \"compilerOptions\": {\n    \"target\": \"es2017\",                         // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'\n    \"module\": \"commonjs\",                       // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"moduleResolution\": \"node\",                 // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)\n    \"emitDecoratorMetadata\": true,              // 为装饰器提供元数据的支持\n    \"experimentalDecorators\": true,             // 启用装饰器\n    \"allowSyntheticDefaultImports\": true,       // 允许从没有设置默认导出的模块中默认导入。\n    \"strict\": true,                             // 启用所有严格类型检查选项\n    \"noImplicitAny\": true,                      // 在表达式和声明上有隐含的 any类型时报错\n    \"alwaysStrict\": true,                       // 以严格模式检查没个模块，并在没个文件里加入 'use strict'\n    \"sourceMap\": true,\n    \"noEmit\": false,                            // 不生成输出文件\n    \"removeComments\": true,                     // 删除编译后的所有的注释\n    \"importHelpers\": true,                      // 从 tslib 导入辅助工具函数\n    \"strictNullChecks\": true,                   // 启用严格的 null 检查\n    \"lib\": [\"es2017\"],                          // 指定要包含在编译中的库文件\n    \"typeRoots\": [\"node_modules/@types\"],\n    \"types\": [\n      \"node\",\n    ],\n    \"outDir\": \"./dist\",                        // 编译后文件产出目录\n    \"rootDir\": \"./src\"                          // 你的ts文件目录\n  },\n  \"include\": [                                 // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题\n    \"./src/*.ts\",\n    \"./src/**/*.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\",\n    \"public\"\n  ]\n}\n```\n\n快速生成`package.json`\n> npm init -y\n\n\n运行命令， 开始监听\n> tsc -w\n\n\n是否有效呢？ 让我们来试一下\n\n\n进入src目录新建一个 `hello.ts`，记得是`.ts`， 不要写习惯了打成`.js`😅\n\n随便写点东西， 比如定义一个字符串类型:\n```TypeScript\nvar a:string = \"hello world\"\n```\n\n如果你配置没有问题的话， 我们就会看到他监听文件修改并编译\n\n这是ts文件与 编译后的js文件\n\n![编译前后](http://img.nixiaolei.com/2019-03-18-22-50-51.png)\n\n\n并且在他运行过程中， 我们可以按`F5`进行调试\n\n\n\n\n\n\n## 基本数据类型\n* Boolean\n* Number\n* String\n* Array\n* Enum\n* Any\n* Void\n\n\n简单的几种数据的定义\n```TypeScript\n// 定义一个Boolean\nvar a:boolean = true\n// 定义一个Number\nvar a:number = 13\n// 定义一个 String \nvar a:string = \"13\"\n```\n\n基本的数据结构定义\n```TypeScript\nvar list:number[] = [1,2,3]\n\n\n```\n\n\n## 接口\n> interfaces\n\n### 基础接口\n\n没有接口时我们如何规范参数类型\n```JavaScript\nfunction fn(dog:{name:string}) {\n  console.log(dog.name)\n}\nvar myObj = { name: \"Hello\" }\nfn(myObj)\n```\n\n有了接口， 我们就可以把参数规定与函数分离\n\n如何创建接口\n\n通过 `interface` 关键字来声明\n\n```JavaScript\ninterface dogValue {\n  name:string;\n}\n\n// 指定参数`dog`是接口类型\nfunction fn(dog: dogValue) {\n  console.log(dog.name)\n}\n\nvar myObj = { name: \"Hello\" }\nfn(myObj)  // 编译通过\n```\n\n### 接口的可选属性\n接口定义的参数不一定每一个都会被用到\n\n\n\n## 泛型\n\n什么是泛型?\n\n泛型: 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型\n\n一句话理解就是：  参数化类型（把类型当作是参数一样传递）\n\n使用泛型的好处:\n* 代码更加简洁【不用强制转换】\n* 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】\n* 可读性和稳定性【在编写集合的时候，就限定了类型】\n\n\n指定一个最简单的泛型\n```TypeScript\nfunction Hello<T>(arg:T):T {\n  return arg;\n}\n```\n\n\n\n\n## Module 模块\n\nModule 模式是常见的JavaScript模式之一， 在ES6的模块话实现之前， 人们通常通过 IFEE 来实现Module\n\nModule 的好处\n1. 模块化\n2. 可重用\n3. 封装变量和函数\n\n\n\n来看看在ES6之前是如何书写的\n```JavaScript\n(function() {\n  // do somtiong\n}());\n```\n\n\n让我们来看一个例子， 使用 TS 的 Module 来防止调用多种 interface 时的麻烦\n\n使用Module之前\n```TypeScript\ninterface StringValidator {\n  // 接口定义的方法\n  isAcceptable(s:string):boolean;\n}\nvar lettersRegexp = /^[A-Za-z]+$]/;\nvar numberRegexp = /^[0-9]+$/;\n// 实现接口的方法\nclass LettersOnlyValidator implements StringValidator {\n  isAcceptable(s:string):boolean {\n    return lettersRegexp.test(s)\n  }\n} \nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s:string):boolean {\n    return s.length === 5 && numberRegexp.test(s)\n  }\n}\n```\n\n使用了Module 的书写方式后\n\n```TypeScript\nmodule Validation {\n  // 需要使用 export 来表示对外暴露\n  export interface StringValidator {\n    isAcceptable(s:string): boolean;\n  }\n\n  var lettersRegexp = /^[A-Za-z]+$]/;\n  var numberRegexp = /^[0-9]+$/;\n\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s:string) {\n      return lettersRegexp.test(s)\n    }\n  }\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s:string):boolean {\n      return s.length === 5 && numberRegexp.test(s)\n    }\n  }\n}\n```\n\n\nModule 与 类相结合使用\n```TypeScript\nmodule Person {\n  export class Student {\n    name: string;\n    constructor(name:string) {\n      this.name = name;\n    }\n    study() {\n      console.log(this.name + '在学习')\n    }\n    speak() {\n      console.log(this.name + '在说话')\n    }\n  }\n}\n\n// ----------- 使用时 -------------\n\nconst xiaoming = new Person.Student('小明')\nxiaoming.study()\n\n```\n\n\n\n## Namespaces\n\nNamespaces 的和Module 的用法相同，  在Ts 的1.5 版本后， 用 Namespaces 取代了 Module \n\n查看一下官方的示例\n\n```TypeScript\nnamespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'\n```\n\n\n## 装饰器 < Decorators >\n\n如何定义一个装饰器\n\n其实装饰器就是一个普通的函数， 他接收一个参数`target` ，这个参数就是被装饰对象， 看下面的例子， `sealed` 装饰了`Dog`类， 并且在`sealed` 中打印了 `target` ， 让我们看看 `target`到底是什么？\n```TypeScript\nfunction sealed(target:any) {\n  // do something with 'target' ...\n  console.log(target)\n  return target\n}\n\n\n// 被装饰的对象 foo\n@sealed\nclass Dog {\n\n}\n```\n\n打印结果\n![使用装饰器](http://img.nixiaolei.com/2019-03-22-22-06-26.png)\n\n我们可以看到， 得到的正是 `Dog`这个类\n\n\n\n### 装饰器工厂< Decorator Factories >\n\n> 如果希望自定义如何将装饰器应用于声明，可以编写装饰器工厂。装饰器工厂只是一个函数，它返回将在运行时由装饰器调用的表达式。\n\n\n装饰器工厂和普通装饰器相比的好处就是更加的自定义了， 可以根据不同情况自定义效果\n\n\n如何定义一个`装饰器工厂`\n\n```TypeScript\nfunction dec(value:string) {\n  return function (target:any)  {\n    console.log(value)\n    console.log(target)    \n  }\n}\n\n// 在这里使用并传入自定义的参数\n@dec('test')\nclass Cat {\n  \n}\n```\n\n让我们来看看运行的结果\n\n![定义装饰器工厂](http://img.nixiaolei.com/2019-03-22-22-22-55.png)\n\n可以看到，我们传入的`test`字符串和 `Cat`类都被打印出来了，\n\n### 多装饰器的执行顺序\n使用多个装饰器时如何书写呢?\n\n当我们使用多个装饰器时有两种写法\n\n1. 写成一行\n```TypeScript\n@f @g x\n```\n2. 垂直书写\n```TypeScript\n@f\n@g\nx\n```\n**多个装饰器的执行顺序是如何的呢？**\n\n套用官网的说明\n1. 对每个装饰器的表达式进行自上而下的计算。\n2. 然后将结果作为自下而上的函数调用。\n\n\n其实真实的运行原理是\n```TypeScript\nf(g(x))\n```\n\n### 访问器修饰器\n\n访问器修饰器的接收的参数和方法修饰器接收的参数一样\n\n\n```TypeScript\nfunction dec(value:string) {\n  return function (target:any, propertyKey: string, descriptor: PropertyDescriptor)  {\n  }\n}\n\n// 在这里使用并传入自定义的参数\n@dec('test')\nclass Cat {\n  private _x: number;\n  private _y: number;\n\n  constructor(x: number, y: number) {\n    this._x = x\n    this._y = y\n  }\n  // 访问器修饰器\n  @dec(true)\n  get  x() { return this._x }\n  @dec(false)\n  get  y() { return this._y }\n}\n```\n\n\n### 属性修饰器\n\n属性修饰器只有前两个参数\n```TypeScript\nfunction dec(value:string) {\n  return function (target:any, propertyKey: string)  {\n  }\n}\n\n// 在这里使用并传入自定义的参数\n@dec('test')\nclass Cat {\n  private _x: number;\n  private _y: number;\n\n  constructor(x: number, y: number) {\n    // 属性修饰器\n    @dec(false)\n    this._x = x\n    this._y = y\n  }\n}\n```\n\n### 参数修饰器\n参数修饰器也是三个参数， 但不同的是第三个参数接收\n\n**参数装饰器只能确认一个方法的参数是否被传入**\n\n\n前两个和其他的修饰器都相同， \n\n1. target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象\n2. propertyKey 成员的名称\n3. 参数在所处函数的参数列表中的索引， 说人话就是告诉你他是第几个参数\n\n\n\n```TypeScript\nfunction require(value:boolean) {\n  return function (target:any, propertyKey: string, index: number)  {\n  }\n}\n\n// 在这里使用并传入自定义的参数\n@dec('test')\nclass Cat {\n  run(@require(true) name:string) {\n  }\n}\n```\n\n\n### 装饰器参数\n\n1. 类装饰器\n\n类装饰器的参数只接收一个， 那就是`target` 也就是这个类本身\n\n就和上面演示的那些例子一样\n\n\n2. 方法装饰器\n\n一般会传入三个参数\n\n1. target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象\n2. propertyKey 成员的名称\n3. descriptor 成员属性的描述符\n\n\n我们来验证下方法装饰器的参数\n\n让我们看看这段例子会输出什么\n```TypeScript\nfunction f(value:string) {\n  return function (target:any, propertyKey: string, descriptor: PropertyDescriptor)  {\n    console.log(arguments)\n    console.log(target)    \n  }\n}\n\nclass Tiger {\n  @f('tiger run')\n  run() {\n  }\n}\n```\n输入结果: \n\n![方法装饰器参数](http://img.nixiaolei.com/2019-03-23-11-35-28.png)\n\n\n在控制台输出， 我们看到了， \n第一个参数是 `tiger` 的实例对象（因为`run`是实例成员）\n\n第二个参数是成员名称， 也就是被装饰的`run`\n\n第三个参数是 `run` 的属性描述符\n\n\n## Mixins 混入\n除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。\n\n\nMixins 其实可以拆分为两个单词\n\nMix : 混合\n\nins : 是进入\n\n所以合在一起就是叫 `混入` 的意思的单词\n\n它想要表达的是一个对象中混入另一个对象的方法\n\n\n**让我们来实现一下Mixins**\n\n代码里首先定义两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。\n\n```TypeScript\n// Disposable Mixin\nclass Disposable {\n    isDisposed: boolean;\n    dispose() {\n        this.isDisposed = true;\n    }\n\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive: boolean;\n    activate() {\n        this.isActive = true;\n    }\n    deactivate() {\n        this.isActive = false;\n    }\n}\n```\n创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：\n```TypeScript\n\nclass SmartObject implements Disposable, Activatable { }\n```\n这里我们没有使用extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的。\n\n我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。\n\n也就是这样\n\n```TypeScript\nclass SmartObject implements Disposable, Activatable {\n  constructor() {\n      setInterval(() => console.log(this.isActive + \" : \" + this.isDisposed), 500);\n  }\n\n  interact() {\n      this.activate();\n  }\n\n  // Disposable\n  isDisposed: boolean = false;\n  dispose: () => void;\n  // Activatable\n  isActive: boolean = false;\n  activate: () => void;\n  deactivate: () => void;\n}\n```\n\n最后，把mixins混入定义的类，完成全部实现部分。\n```TypeScript\napplyMixins(SmartObject, [Disposable, Activatable]);\n```\n\n我们同时也需要创建这个帮助函数， 帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\n```TypeScript\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n      Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n          derivedCtor.prototype[name] = baseCtor.prototype[name];\n      })\n  });\n}\n```\n\n\n\n\n\n\n\n## 参考文献\n* https://segmentfault.com/a/1190000016305647\n\n\n-------------------------待完善——----------------------\n\n\n\n\n\n\n\n","slug":"TypeScript手册","published":1,"updated":"2019-09-09T16:57:46.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4wz00g7aas6h3yo5pn2"},{"title":"TypeScript语法","date":"2019-03-24T06:47:50.000Z","_content":"\n\n\n## 初始化配置文件\n> tsc --init      \n> 修改` outDir`\n\n## 定义数组\n> 1\n\n```TypeScript\nvar arr:number[] = [1,2,3,4]\n```\n\n> 2\n\n```TypeScript\nvar arr:Array<number> = [3,4,56,7,8,9]\n```\n> 3\n\n```TypeScript\nvar arr:any[] = [1,'5515', false]\n```\n\n\n## 定义元组\n> 元组表示一个已知元素数量和类型的数组，各元素的类型不必相同。   \n> 1\n\n```TypeScript\nlet arr:[number, string] = [123, 'this is ts']\n```\n\n## 定义枚举\n> 用于处理非数值的数据\n\n```TypeScript\nenum Flag { success=1, error=2 };\nlet s:Flag=Flag.success\n\nconsole.log(s) // 1\n```\n\n## never 类型: \n> never类型表示的是那些永不存在的值的类型, 如null, undefind, error\n\n```TypeScript\nvar a:undefined\na = undefined\n```\n\n## 定义 symbol类型\n> symbol类型的值是通过Symbol构造函数创建的。\n\n```TypeScript\nlet sym1 = Symbol();\n```\n\n\n\n## 容许多个类型\n```TypeScript\nvar num:number | undefined;\n\nnum = 123;\nconsole.log(num)\n```\n\n## 有返回值类型\n> 函数声明\n\n```TypeScript\nfunction run():string {\n  return '32132132'\n}\n```\n\n> 函数表达式\n\n```TypeScript\nvar fun2 = function():number {\n  return 132\n}\n```\n\n\n## 无返回值类型\n```TypeScript\nfunction run():void{\n  console.log('run')\n}\n\n```\n\n\n## 可选参数、 默认参数 、剩余参数\n> 默认必传, 带‘?’可传可不传， 必须配置到参数的最后面\n\n```TypeScript\nfunction getInfo(name:string, age?:number):string {\n  return `${name} ---- ${age}`\n}\n```\n> 默认参数       \n> 写了默认参数就不再需要 '?' 标记\n\n```TypeScript\nfunction getInfo(name:string, age:number=250):string {\n  return `${name} ---- ${age}`\n}\n```\n\n> 剩余参数\n```\n\n```\n\n\n\n## json 属性约束\n```TypeScript\n// json属性约束\nfunction jsonCon(label) {\n    console.log(label.labelJson);\n}\njsonCon({ labelJson: '你好评' });\n\n```\n\n\n## 重载\n> 因为需要遵循js ， 所以无法像java一样实现重载， 实现的只能是变体， 自己判断typeof\n\n```TypeScript\nfunction getInfo(name:string):string;\n\nfunction getInfo(name:string, age:number):string;\n\nfunction getInfo(name:string, age?:any):string {\n  \n  // 判断类型用 typeof\n  if(age) {\n    return `姓名:${name}, 年龄${age}`\n  }else {\n    return `姓名:${name}`\n  }\n}\n\nconsole.log(getInfo('吴大龙'))\n```\n\n## 创建类\n```TypeScript\nclass Person{\n  name:string;  // 属性 ,前面省略了Public 关键词\n\n  constructor(name:string){    // 构造函数  实例化类的时候 触发的方法\n    this.name = name;\n  }\n  getName():string{\n    return this.name\n  }\n  setName(name:string):void{\n    this.name=name;\n  }\n} \nvar aa = new Person('栗色')\n\nconsole.log(aa.getName())\naa.setName('吴大龙')\nconsole.log(aa.getName())\n```\n> 使用类的 get 和 set\n\n```TypeScript\nclass Person{\n  private _name:string;\n  constructor(name:string, age:number){\n    this._name = name;\n  }\n  get name():string{\n    return this._name\n  }\n  set name(name:string){\n    this._name = name;\n  }\n}\nconst p = new Person('吴大龙', 112)\np.name = '吴强' // 赋值\nconsole.log(p.name)  // 取值\n```\n\n\n\n\n## 实现继承\n> 继承自上方类\n\n```TypeScript\nclass Web extends Person {\n  constructor(name:string){\n    super(name);\n  }\n}\n\nvar w=new Web('往');\nconsole.log(w.run())\n```\n## 类修饰符\n> 不加修饰符默认就是 Public  ,  ==外部的意思就是指不被内部函数里被调用, 而是被外部人为调用==    \n> public:  共有,  在类的里面, 子类, 类外部都可以访问\n\n> protected:  保护类型, 在类里面, 子类里面可以访问, 类外部无法访问\n\n> private:   私有, 在类里可以访问, 子类, 类外部都没法访问\n\n## 静态属性和静态方法\n> static  静态方法, 在没有 new 出实例前都可以调用      \n> ==但是没法直接调用类里面的属性==\n\n```TypeScript\nclass Person {\n  public nickname:string= '吴大龙';\n  \n  static speak():void{\n    console.log(`用户姓名:${this.nickname}`)\n  }\n}\n\nPerson.speak()  // 用户姓名:undefined\n```\n\n\n## 多态\n> 父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现       \n> 也是继承的一种表现, 子类实现或重写父类中的已有的方法， 这叫多态\n\n```TypeScript\n// 多态\nclass Animal {\n  name:string;\n  constructor(name:string){\n    this.name = name;\n  }\n  eat():void{\n    console.log(`${this.name}， 在吃屎`)\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name:string){\n    super(name)\n  }\n  // 子类重新定义 eat方法\n  eat():void {\n    console.log(this.name+'吃肉')\n  }\n}\n\nconst wuxiaohong = new Dog('吴晓红')\nwuxiaohong.eat()\n\n// 子类重新定义 eat方法\nclass Cat extends Animal {\n  constructor(name:string) {\n    super(name)\n  }\n  eat():void{\n    console.log(this.name+ '吃粮食')\n  }\n}\n\nvar cc = new Cat('吴强')\ncc.eat()\n```\n\n## 抽象类\n> 用abstract关键字定义抽象类和抽象方法， 是提供其他类继承的基类    \n> ==抽象方法只能放在抽象类里==      \n> 从抽象类继承的方法必须被子类重写, 重新实现\n\n```TypeScript\nabstract class Animal{\n  public name:string;\n  constructor(name:string){\n    this.name=name;\n  }\n  abstract eat():any;\n}\n\nclass Dog extends Animal{\n\n  constructor(name:any){\n    super(name)\n  }\n  eat(){\n    console.log(this.name + '吃粮食')\n  }\n}\n\nvar d = new Dog('小狗')\nd.eat()\n```\n\n## 接口\n* 也是一种定义标准. 类似抽象类, 抽象类只能规定方法， 接口可以规定属性， 函数， 索引和类\n\n> 批量属性接口， 可定义可选参数\n\n```TypeScript\n// 属性接口\ninterface FullName{\n  firstName: string;   //封号结束\n  secondName: string;\n}\nfunction printName (name: FullName) : void{\n  console.log(name.firstName +'====>' + name.secondName);\n}\nprintName({firstName: '吴', secondName: '大龙'})  // 吴====>大龙\n```\n> 数组类型接口\n```TypeScript\ninterface StringArray {\n  [index:number]:string\n}\nvar myArray:StringArray;\nmyArray = [\"iwen\", \"ime\"]\nalert(myArray[1])\n```\n\n\n\n> 函数类型接口,  对方法传入的参数， 以及返回值进行约束\n\n```TypeScript\n// 比如建一个md5加密的接口 的接口\ninterface encrypt{\n  (key:string, value:string):string;\n}\n\nvar md5:encrypt = function(key:string, value:string):string {\n  return key + value;\n}\nconsole.log(md5('name', '吴大龙'))\n```\n\n\n\n> 接口扩展， 接口可以继承接口\n\n```TypeScript\ninterface Animal{\n  eat():void;\n}\n// 继承上方接口\ninterface Person extends Animal {\n  work():void;\n}\n// 有个类 实现 这个接口\nclass Web implements Person {\n  public name:string;\n  constructor(name:string){\n    this.name=name\n  }\n  eat(){\n    console.log(this.name + '喜欢吃馒头')\n  }\n  work(){\n    console.log(this.name + '写代码')\n  }\n}\n\nvar w = new Web('小林')\nw.work()  // 小林写代码\n```\n> 接口多继承  &&  ==创建一个接口对象==\n```TypeScript\n//  多继承 并 创建一个接口对象\ninterface Shape {\n  color:string;\n}\n\ninterface PenStroke {\n  penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength:number;\n}\n\n// 创建接口对象不需要 new  而是这样的语法\nvar s = <Square>{};\ns.color = \"blue\"\ns.penWidth = 10\ns.sideLength = 10\n```\n\n\n\n## 泛型\n* 用于创建可重用的组件， 让一个组件支持多种数据类型\n* ==泛型就是解决类 接口 方法的复用性、 以及对不特定数据类型的支持==\n\n> 基本使用 \n\n```TypeScript\n// 泛型 : 可以支持不特定的数据类型   要求： 传入的参数和返回的参数一致\nfunction getData<T>(value:T):T{    // T表示泛型\n  return value\n}\nconsole.log(getData<string>('我是泛型'))\n```\n> 多个泛型参数\n\n```TypeScript\nclass HelloNumber<T, S>{\n  Ten:T;\n  add:(x:T, y:T) => S;\n}\nvar myHelloNumber = new HelloNumber<number, string>()\nmyHelloNumber.Ten = 10;\nmyHelloNumber.add = function(x, y) {\n  return x+y+''\n}\nconsole.log(myHelloNumber.add(1, 2));\n```\n> lamb 表达式\n\n```TypeScript\nfunction Hello<T>(arg:T):T{\n  return arg;\n}\n// lamb 表达式只是表达具体 参数和返回类型, 需要重新赋值上真函数\nvar myHello:<K>(arg:K)=> K = <K>(arg:K):K => {\n  return arg\n}\nalert(myHello('hello'))\n```\n> 另一种写法， 对象形式\n\n```TypeScript\nfunction Hello<T>(arg:T){\n  return arg\n}\nvar myHello:{<T>(arg:T):T} = Hello;\nalert(myHello(\" Hello\"))\n```\n\n\n\n> 泛型接口\n\n```TypeScript\n// 泛型接口\ninterface ConfigFn{\n  <T>(value:T):T;\n}\nvar getData:ConfigFn = function<T>(value:T):T{\n  return value\n}\nconsole.log( getData<string>('你好') )\n```\n\n\n\n> 泛型小实战 ==需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现==\n\n```TypeScript\n// 泛型类: 比如有个最小堆算法， 需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现\n\nclass MinClass<T>{\n  list:T[]=[]\n  add(value:T):void{\n    this.list.push(value)\n  }\n  min():T{\n    var minNum = this.list[0]\n    for(var i=0;i<this.list.length;i++){\n      if(minNum > this.list[i]){\n        minNum=this.list[i]\n      }\n    }\n    return minNum;\n  }\n}\nvar m1 = new MinClass<string>();\nm1.add('1')\nm1.add('you')\nm1.add('love')\nconsole.log(m1.min())\n```\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/TypeScript语法.md","raw":"---\ntitle: TypeScript语法\ndate: 2019-03-24 14:47:50\ncategories: TypeScript\ntags: [ JavaScript, TypeScript ]\n---\n\n\n\n## 初始化配置文件\n> tsc --init      \n> 修改` outDir`\n\n## 定义数组\n> 1\n\n```TypeScript\nvar arr:number[] = [1,2,3,4]\n```\n\n> 2\n\n```TypeScript\nvar arr:Array<number> = [3,4,56,7,8,9]\n```\n> 3\n\n```TypeScript\nvar arr:any[] = [1,'5515', false]\n```\n\n\n## 定义元组\n> 元组表示一个已知元素数量和类型的数组，各元素的类型不必相同。   \n> 1\n\n```TypeScript\nlet arr:[number, string] = [123, 'this is ts']\n```\n\n## 定义枚举\n> 用于处理非数值的数据\n\n```TypeScript\nenum Flag { success=1, error=2 };\nlet s:Flag=Flag.success\n\nconsole.log(s) // 1\n```\n\n## never 类型: \n> never类型表示的是那些永不存在的值的类型, 如null, undefind, error\n\n```TypeScript\nvar a:undefined\na = undefined\n```\n\n## 定义 symbol类型\n> symbol类型的值是通过Symbol构造函数创建的。\n\n```TypeScript\nlet sym1 = Symbol();\n```\n\n\n\n## 容许多个类型\n```TypeScript\nvar num:number | undefined;\n\nnum = 123;\nconsole.log(num)\n```\n\n## 有返回值类型\n> 函数声明\n\n```TypeScript\nfunction run():string {\n  return '32132132'\n}\n```\n\n> 函数表达式\n\n```TypeScript\nvar fun2 = function():number {\n  return 132\n}\n```\n\n\n## 无返回值类型\n```TypeScript\nfunction run():void{\n  console.log('run')\n}\n\n```\n\n\n## 可选参数、 默认参数 、剩余参数\n> 默认必传, 带‘?’可传可不传， 必须配置到参数的最后面\n\n```TypeScript\nfunction getInfo(name:string, age?:number):string {\n  return `${name} ---- ${age}`\n}\n```\n> 默认参数       \n> 写了默认参数就不再需要 '?' 标记\n\n```TypeScript\nfunction getInfo(name:string, age:number=250):string {\n  return `${name} ---- ${age}`\n}\n```\n\n> 剩余参数\n```\n\n```\n\n\n\n## json 属性约束\n```TypeScript\n// json属性约束\nfunction jsonCon(label) {\n    console.log(label.labelJson);\n}\njsonCon({ labelJson: '你好评' });\n\n```\n\n\n## 重载\n> 因为需要遵循js ， 所以无法像java一样实现重载， 实现的只能是变体， 自己判断typeof\n\n```TypeScript\nfunction getInfo(name:string):string;\n\nfunction getInfo(name:string, age:number):string;\n\nfunction getInfo(name:string, age?:any):string {\n  \n  // 判断类型用 typeof\n  if(age) {\n    return `姓名:${name}, 年龄${age}`\n  }else {\n    return `姓名:${name}`\n  }\n}\n\nconsole.log(getInfo('吴大龙'))\n```\n\n## 创建类\n```TypeScript\nclass Person{\n  name:string;  // 属性 ,前面省略了Public 关键词\n\n  constructor(name:string){    // 构造函数  实例化类的时候 触发的方法\n    this.name = name;\n  }\n  getName():string{\n    return this.name\n  }\n  setName(name:string):void{\n    this.name=name;\n  }\n} \nvar aa = new Person('栗色')\n\nconsole.log(aa.getName())\naa.setName('吴大龙')\nconsole.log(aa.getName())\n```\n> 使用类的 get 和 set\n\n```TypeScript\nclass Person{\n  private _name:string;\n  constructor(name:string, age:number){\n    this._name = name;\n  }\n  get name():string{\n    return this._name\n  }\n  set name(name:string){\n    this._name = name;\n  }\n}\nconst p = new Person('吴大龙', 112)\np.name = '吴强' // 赋值\nconsole.log(p.name)  // 取值\n```\n\n\n\n\n## 实现继承\n> 继承自上方类\n\n```TypeScript\nclass Web extends Person {\n  constructor(name:string){\n    super(name);\n  }\n}\n\nvar w=new Web('往');\nconsole.log(w.run())\n```\n## 类修饰符\n> 不加修饰符默认就是 Public  ,  ==外部的意思就是指不被内部函数里被调用, 而是被外部人为调用==    \n> public:  共有,  在类的里面, 子类, 类外部都可以访问\n\n> protected:  保护类型, 在类里面, 子类里面可以访问, 类外部无法访问\n\n> private:   私有, 在类里可以访问, 子类, 类外部都没法访问\n\n## 静态属性和静态方法\n> static  静态方法, 在没有 new 出实例前都可以调用      \n> ==但是没法直接调用类里面的属性==\n\n```TypeScript\nclass Person {\n  public nickname:string= '吴大龙';\n  \n  static speak():void{\n    console.log(`用户姓名:${this.nickname}`)\n  }\n}\n\nPerson.speak()  // 用户姓名:undefined\n```\n\n\n## 多态\n> 父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现       \n> 也是继承的一种表现, 子类实现或重写父类中的已有的方法， 这叫多态\n\n```TypeScript\n// 多态\nclass Animal {\n  name:string;\n  constructor(name:string){\n    this.name = name;\n  }\n  eat():void{\n    console.log(`${this.name}， 在吃屎`)\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name:string){\n    super(name)\n  }\n  // 子类重新定义 eat方法\n  eat():void {\n    console.log(this.name+'吃肉')\n  }\n}\n\nconst wuxiaohong = new Dog('吴晓红')\nwuxiaohong.eat()\n\n// 子类重新定义 eat方法\nclass Cat extends Animal {\n  constructor(name:string) {\n    super(name)\n  }\n  eat():void{\n    console.log(this.name+ '吃粮食')\n  }\n}\n\nvar cc = new Cat('吴强')\ncc.eat()\n```\n\n## 抽象类\n> 用abstract关键字定义抽象类和抽象方法， 是提供其他类继承的基类    \n> ==抽象方法只能放在抽象类里==      \n> 从抽象类继承的方法必须被子类重写, 重新实现\n\n```TypeScript\nabstract class Animal{\n  public name:string;\n  constructor(name:string){\n    this.name=name;\n  }\n  abstract eat():any;\n}\n\nclass Dog extends Animal{\n\n  constructor(name:any){\n    super(name)\n  }\n  eat(){\n    console.log(this.name + '吃粮食')\n  }\n}\n\nvar d = new Dog('小狗')\nd.eat()\n```\n\n## 接口\n* 也是一种定义标准. 类似抽象类, 抽象类只能规定方法， 接口可以规定属性， 函数， 索引和类\n\n> 批量属性接口， 可定义可选参数\n\n```TypeScript\n// 属性接口\ninterface FullName{\n  firstName: string;   //封号结束\n  secondName: string;\n}\nfunction printName (name: FullName) : void{\n  console.log(name.firstName +'====>' + name.secondName);\n}\nprintName({firstName: '吴', secondName: '大龙'})  // 吴====>大龙\n```\n> 数组类型接口\n```TypeScript\ninterface StringArray {\n  [index:number]:string\n}\nvar myArray:StringArray;\nmyArray = [\"iwen\", \"ime\"]\nalert(myArray[1])\n```\n\n\n\n> 函数类型接口,  对方法传入的参数， 以及返回值进行约束\n\n```TypeScript\n// 比如建一个md5加密的接口 的接口\ninterface encrypt{\n  (key:string, value:string):string;\n}\n\nvar md5:encrypt = function(key:string, value:string):string {\n  return key + value;\n}\nconsole.log(md5('name', '吴大龙'))\n```\n\n\n\n> 接口扩展， 接口可以继承接口\n\n```TypeScript\ninterface Animal{\n  eat():void;\n}\n// 继承上方接口\ninterface Person extends Animal {\n  work():void;\n}\n// 有个类 实现 这个接口\nclass Web implements Person {\n  public name:string;\n  constructor(name:string){\n    this.name=name\n  }\n  eat(){\n    console.log(this.name + '喜欢吃馒头')\n  }\n  work(){\n    console.log(this.name + '写代码')\n  }\n}\n\nvar w = new Web('小林')\nw.work()  // 小林写代码\n```\n> 接口多继承  &&  ==创建一个接口对象==\n```TypeScript\n//  多继承 并 创建一个接口对象\ninterface Shape {\n  color:string;\n}\n\ninterface PenStroke {\n  penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength:number;\n}\n\n// 创建接口对象不需要 new  而是这样的语法\nvar s = <Square>{};\ns.color = \"blue\"\ns.penWidth = 10\ns.sideLength = 10\n```\n\n\n\n## 泛型\n* 用于创建可重用的组件， 让一个组件支持多种数据类型\n* ==泛型就是解决类 接口 方法的复用性、 以及对不特定数据类型的支持==\n\n> 基本使用 \n\n```TypeScript\n// 泛型 : 可以支持不特定的数据类型   要求： 传入的参数和返回的参数一致\nfunction getData<T>(value:T):T{    // T表示泛型\n  return value\n}\nconsole.log(getData<string>('我是泛型'))\n```\n> 多个泛型参数\n\n```TypeScript\nclass HelloNumber<T, S>{\n  Ten:T;\n  add:(x:T, y:T) => S;\n}\nvar myHelloNumber = new HelloNumber<number, string>()\nmyHelloNumber.Ten = 10;\nmyHelloNumber.add = function(x, y) {\n  return x+y+''\n}\nconsole.log(myHelloNumber.add(1, 2));\n```\n> lamb 表达式\n\n```TypeScript\nfunction Hello<T>(arg:T):T{\n  return arg;\n}\n// lamb 表达式只是表达具体 参数和返回类型, 需要重新赋值上真函数\nvar myHello:<K>(arg:K)=> K = <K>(arg:K):K => {\n  return arg\n}\nalert(myHello('hello'))\n```\n> 另一种写法， 对象形式\n\n```TypeScript\nfunction Hello<T>(arg:T){\n  return arg\n}\nvar myHello:{<T>(arg:T):T} = Hello;\nalert(myHello(\" Hello\"))\n```\n\n\n\n> 泛型接口\n\n```TypeScript\n// 泛型接口\ninterface ConfigFn{\n  <T>(value:T):T;\n}\nvar getData:ConfigFn = function<T>(value:T):T{\n  return value\n}\nconsole.log( getData<string>('你好') )\n```\n\n\n\n> 泛型小实战 ==需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现==\n\n```TypeScript\n// 泛型类: 比如有个最小堆算法， 需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现\n\nclass MinClass<T>{\n  list:T[]=[]\n  add(value:T):void{\n    this.list.push(value)\n  }\n  min():T{\n    var minNum = this.list[0]\n    for(var i=0;i<this.list.length;i++){\n      if(minNum > this.list[i]){\n        minNum=this.list[i]\n      }\n    }\n    return minNum;\n  }\n}\nvar m1 = new MinClass<string>();\nm1.add('1')\nm1.add('you')\nm1.add('love')\nconsole.log(m1.min())\n```\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"TypeScript语法","published":1,"updated":"2019-09-09T16:57:46.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4x000gaaas6xvlhthpm"},{"title":"【Three】Three.js入门之几何和网格对象","date":"2019-04-03T09:48:05.000Z","_content":"\n## Geometry\n\nThree.js 中自带了很多的几何体， 我们可以直接使用他们的方法就可以轻松的创造出一个几何体，\n\n比如:\n\n创建一个面\n```Js\nnew THREE.PlaneGeometry()\n```\n\n创建一个立方体\n```Js\nnew THREE.CubeGeometry()\n```\n\n我们可以看到都带有`Geometry` 这个单词， 翻译过来也是“几何体”的意思\n其实这个`THREE.Geometry`是所有几何对象的基类( 简称 geom )\n\n\n### vertices顶点数组\n> 翻译： 顶点\n\n一个集合体我们可以看成是由几个顶点构成的， 比如一个立方体， 他就是由8个在空间中的顶点构成的。 \n\n在Three中， `geom.vertices`表示几何体的顶点， 它是一个数组\n\n所以我们不但可以利用`Three`已有的几何体， 还可以自己提供顶点， 自己来创建一个集合体\n\n\n### faces 侧面\n> 翻译: 面\n\n`geom.faces` 表示几何体的侧面\n\n\n\n### 动手创建一个立方体\n\n上面我们说了， 一个立方体， 由8个顶点 和 6个面构成， 如果让我们自己来实现， 我们就需要手动来创建下\n#### 定义8个顶点\n\n```Js\nvar vertices = [\n  new THREE.Vector3(1, 3, 1),\n  new THREE.Vector3(1, 3, -1),\n  new THREE.Vector3(1, -1, 1),\n  new THREE.Vector3(1, -1, -1),\n  new THREE.Vector3(-1, 3, -1),\n  new THREE.Vector3(-1, 3, 1),\n  new THREE.Vector3(-1, -1, -1),\n  new THREE.Vector3(-1, -1, 1)\n]\n```\n\n#### 定义6个面\n因为在Three 中，可以理解为万物都由 三角形构成， 所以要想有正方形， 需要通过三角形创建( 以前支持直接创建正方形， 后来被删除 )\n\n```Js\n// 增加 6个面\nvar faces = [\n  // 一个正方形由两个三角形构成\n  new THREE.Face3(0, 2, 1),\n  new THREE.Face3(2, 3, 1),\n\n  new THREE.Face3(4, 5, 6),\n  new THREE.Face3(6, 7, 5),\n\n  new THREE.Face3(4, 5, 1),\n  new THREE.Face3(5, 0, 1),\n  \n  new THREE.Face3(7, 6, 2),\n  new THREE.Face3(6, 3, 2),\n  \n  new THREE.Face3(5, 7, 0),\n  new THREE.Face3(7, 2, 0),\n  \n  new THREE.Face3(1, 3, 4),\n  new THREE.Face3(3, 4, 4),\n]\n```\n\n\n#### 生成几何物体\n刚刚我们配置的只是所需的数据， 现在我们要做的是将他合并成一个完整的几何体\n\n```Js\n// 创建几何体\nvar geom = new THREE.Geometry()\ngeom.vertices = vertices\ngeom.faces = faces\ngeom.computeFaceNormals()\n```\n\n\n#### 添加材质\n\n\n![控制台报错](http://img.nixiaolei.com/sceneUtils-error.png)\n如果控制带出现这个错误， 说明`SceneUtils` 已经被Three 独立拆除去了， 所以要想使用需要单独引入\n\n```Js\n\n// 增加材质\nvar materials = [\n  new THREE.MeshLambertMaterial({\n    opacity: 0.5, \n    color: 0x44ff44, \n    transparent: true\n  }),\n  new THREE.MeshBasicMaterial({\n    color: 0x000000, \n    wireframe: true\n  })\n]\n\n// 构成物体\nvar mesh = new THREE.SceneUtils.createMultiMaterialObject(geom, materials)\nmesh.children.forEach(\n  (e) => {\n    e.castShadow = true\n  }\n)\n\n```\n\n\n#### 渲染场景\n加入到场景渲染一下我们刚刚创建的立方体\n```Js\nscene.add(mesh)\nrenderer.render(scene, camera)\n```\n\n此时，我们可以看到画布上真的出现了一个立方体\n![渲染场景结果](http://img.nixiaolei.com/three-gemo-mesh.png)\n\n\n\n\n\n## 网格对象的属性和函数\n* position 决定该对象相对于父对象的位置。\n* rotation 设置对象绕任何一个轴的旋转弧度\n* scale沿 x, y 和 z轴缩放对象\n* translateX x轴平移\n* translateY y轴平移\n* translateZ z轴平移\n\n\n使用这些api移动一下我们刚刚创建的立方体吧\n\n### 移动一下立方体\n\n```Js\n// 平移\nmesh.position.x = 10\nmesh.position.y = 10\nmesh.position.z = 1\n// // 等同于\n// mesh.position.set(10, 10, 1)\n```\n\n此时效果\n![移动立方体](http://img.nixiaolei.com/2019-05-03-23-41-13.png)\n\n### 再旋转一下立方体\n```Js\n// // 旋转\nmesh.rotation.x = 2\nmesh.rotation.y = 2\nmesh.rotation.z = 2\n```\n\n此时效果\n![旋转立方体](http://img.nixiaolei.com/three-mesh-rotation.png)\n\n### 缩放一下立方体\n我们可以针对某一个轴进行缩放， 这里我们缩放x轴， 其他轴同理\n\n```Js\n// x 轴方向放大4倍\nmesh.scale.x = 4\n```\n\n此时效果\n\n![立方体缩放效果](http://img.nixiaolei.com/three-mesh-scale.png)\n\n\n\n\n## 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script>\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 10\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    // 打开阴影\n    renderer.shadowMapEnabled = true\n\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n\n    plane.receiveShadow = true\n    // 加入场景\n    scene.add(plane)\n\n\n    /*\n    *\n    *  添加材质和灯光\n    *\n    * */\n\n    // 设置点光源\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    // 设置位置\n    spotLight.position.set(-40, 60, -10)\n    spotLight.castShadow = true\n    // 添加进点光源\n    scene.add(spotLight)\n\n\n    // 将renderer的输出挂到 body\n    document.body.appendChild(renderer.domElement)\n    renderer.render(scene, camera)\n\n    // 定义一个方块\n    // 1.定义8个顶点\n    // 2. 6个面\n    var vertices = [\n      new THREE.Vector3(1, 3, 1),\n      new THREE.Vector3(1, 3, -1),\n      new THREE.Vector3(1, -1, 1),\n      new THREE.Vector3(1, -1, -1),\n      new THREE.Vector3(-1, 3, -1),\n      new THREE.Vector3(-1, 3, 1),\n      new THREE.Vector3(-1, -1, -1),\n      new THREE.Vector3(-1, -1, 1)\n    ]\n\n    // 增加 6个面\n    var faces = [\n      // 一个正方形由两个三角形构成\n      new THREE.Face3(0, 2, 1),\n      new THREE.Face3(2, 3, 1),\n\n      new THREE.Face3(4, 5, 6),\n      new THREE.Face3(6, 7, 5),\n\n      new THREE.Face3(4, 5, 1),\n      new THREE.Face3(5, 0, 1),\n      \n      new THREE.Face3(7, 6, 2),\n      new THREE.Face3(6, 3, 2),\n      \n      new THREE.Face3(5, 7, 0),\n      new THREE.Face3(7, 2, 0),\n      \n      new THREE.Face3(1, 3, 4),\n      new THREE.Face3(3, 4, 4),\n    ]\n\n    // 创建几何体\n    var geom = new THREE.Geometry()\n    geom.vertices = vertices\n    geom.faces = faces\n    geom.computeFaceNormals()\n\n    // 增加材质\n    var materials = [\n      new THREE.MeshLambertMaterial({\n        opacity: 0.5, \n        color: 0x44ff44, \n        transparent: true\n      }),\n      new THREE.MeshLambertMaterial({\n        color: 0x000000, \n        wireframe: true\n      })\n    ]\n\n    // 构成物体\n    var mesh = new THREE.SceneUtils.createMultiMaterialObject(geom, materials)\n    mesh.children.forEach(\n      (e) => {\n        e.castShadow = true\n      }\n    )\n\n\n    // 平移\n    mesh.position.x = 10\n    mesh.position.y = 10\n    mesh.position.z = 1\n    // // 等同于\n    // mesh.position.set(10, 10, 1)\n    \n    // // 旋转\n    mesh.rotation.x = 2\n    mesh.rotation.y = 2\n    mesh.rotation.z = 2\n\n    // // x 轴方向放大4倍\n    mesh.scale.x = 4\n\n\n    scene.add(mesh)\n    renderer.render(scene, camera)\n\n</script>\n</html>\n```","source":"_posts/【Three】Three-js入门之几何和网格对象.md","raw":"---\ntitle: 【Three】Three.js入门之几何和网格对象\ndate: 2019-04-03 17:48:05\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n## Geometry\n\nThree.js 中自带了很多的几何体， 我们可以直接使用他们的方法就可以轻松的创造出一个几何体，\n\n比如:\n\n创建一个面\n```Js\nnew THREE.PlaneGeometry()\n```\n\n创建一个立方体\n```Js\nnew THREE.CubeGeometry()\n```\n\n我们可以看到都带有`Geometry` 这个单词， 翻译过来也是“几何体”的意思\n其实这个`THREE.Geometry`是所有几何对象的基类( 简称 geom )\n\n\n### vertices顶点数组\n> 翻译： 顶点\n\n一个集合体我们可以看成是由几个顶点构成的， 比如一个立方体， 他就是由8个在空间中的顶点构成的。 \n\n在Three中， `geom.vertices`表示几何体的顶点， 它是一个数组\n\n所以我们不但可以利用`Three`已有的几何体， 还可以自己提供顶点， 自己来创建一个集合体\n\n\n### faces 侧面\n> 翻译: 面\n\n`geom.faces` 表示几何体的侧面\n\n\n\n### 动手创建一个立方体\n\n上面我们说了， 一个立方体， 由8个顶点 和 6个面构成， 如果让我们自己来实现， 我们就需要手动来创建下\n#### 定义8个顶点\n\n```Js\nvar vertices = [\n  new THREE.Vector3(1, 3, 1),\n  new THREE.Vector3(1, 3, -1),\n  new THREE.Vector3(1, -1, 1),\n  new THREE.Vector3(1, -1, -1),\n  new THREE.Vector3(-1, 3, -1),\n  new THREE.Vector3(-1, 3, 1),\n  new THREE.Vector3(-1, -1, -1),\n  new THREE.Vector3(-1, -1, 1)\n]\n```\n\n#### 定义6个面\n因为在Three 中，可以理解为万物都由 三角形构成， 所以要想有正方形， 需要通过三角形创建( 以前支持直接创建正方形， 后来被删除 )\n\n```Js\n// 增加 6个面\nvar faces = [\n  // 一个正方形由两个三角形构成\n  new THREE.Face3(0, 2, 1),\n  new THREE.Face3(2, 3, 1),\n\n  new THREE.Face3(4, 5, 6),\n  new THREE.Face3(6, 7, 5),\n\n  new THREE.Face3(4, 5, 1),\n  new THREE.Face3(5, 0, 1),\n  \n  new THREE.Face3(7, 6, 2),\n  new THREE.Face3(6, 3, 2),\n  \n  new THREE.Face3(5, 7, 0),\n  new THREE.Face3(7, 2, 0),\n  \n  new THREE.Face3(1, 3, 4),\n  new THREE.Face3(3, 4, 4),\n]\n```\n\n\n#### 生成几何物体\n刚刚我们配置的只是所需的数据， 现在我们要做的是将他合并成一个完整的几何体\n\n```Js\n// 创建几何体\nvar geom = new THREE.Geometry()\ngeom.vertices = vertices\ngeom.faces = faces\ngeom.computeFaceNormals()\n```\n\n\n#### 添加材质\n\n\n![控制台报错](http://img.nixiaolei.com/sceneUtils-error.png)\n如果控制带出现这个错误， 说明`SceneUtils` 已经被Three 独立拆除去了， 所以要想使用需要单独引入\n\n```Js\n\n// 增加材质\nvar materials = [\n  new THREE.MeshLambertMaterial({\n    opacity: 0.5, \n    color: 0x44ff44, \n    transparent: true\n  }),\n  new THREE.MeshBasicMaterial({\n    color: 0x000000, \n    wireframe: true\n  })\n]\n\n// 构成物体\nvar mesh = new THREE.SceneUtils.createMultiMaterialObject(geom, materials)\nmesh.children.forEach(\n  (e) => {\n    e.castShadow = true\n  }\n)\n\n```\n\n\n#### 渲染场景\n加入到场景渲染一下我们刚刚创建的立方体\n```Js\nscene.add(mesh)\nrenderer.render(scene, camera)\n```\n\n此时，我们可以看到画布上真的出现了一个立方体\n![渲染场景结果](http://img.nixiaolei.com/three-gemo-mesh.png)\n\n\n\n\n\n## 网格对象的属性和函数\n* position 决定该对象相对于父对象的位置。\n* rotation 设置对象绕任何一个轴的旋转弧度\n* scale沿 x, y 和 z轴缩放对象\n* translateX x轴平移\n* translateY y轴平移\n* translateZ z轴平移\n\n\n使用这些api移动一下我们刚刚创建的立方体吧\n\n### 移动一下立方体\n\n```Js\n// 平移\nmesh.position.x = 10\nmesh.position.y = 10\nmesh.position.z = 1\n// // 等同于\n// mesh.position.set(10, 10, 1)\n```\n\n此时效果\n![移动立方体](http://img.nixiaolei.com/2019-05-03-23-41-13.png)\n\n### 再旋转一下立方体\n```Js\n// // 旋转\nmesh.rotation.x = 2\nmesh.rotation.y = 2\nmesh.rotation.z = 2\n```\n\n此时效果\n![旋转立方体](http://img.nixiaolei.com/three-mesh-rotation.png)\n\n### 缩放一下立方体\n我们可以针对某一个轴进行缩放， 这里我们缩放x轴， 其他轴同理\n\n```Js\n// x 轴方向放大4倍\nmesh.scale.x = 4\n```\n\n此时效果\n\n![立方体缩放效果](http://img.nixiaolei.com/three-mesh-scale.png)\n\n\n\n\n## 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script>\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 10\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    // 打开阴影\n    renderer.shadowMapEnabled = true\n\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n\n    plane.receiveShadow = true\n    // 加入场景\n    scene.add(plane)\n\n\n    /*\n    *\n    *  添加材质和灯光\n    *\n    * */\n\n    // 设置点光源\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    // 设置位置\n    spotLight.position.set(-40, 60, -10)\n    spotLight.castShadow = true\n    // 添加进点光源\n    scene.add(spotLight)\n\n\n    // 将renderer的输出挂到 body\n    document.body.appendChild(renderer.domElement)\n    renderer.render(scene, camera)\n\n    // 定义一个方块\n    // 1.定义8个顶点\n    // 2. 6个面\n    var vertices = [\n      new THREE.Vector3(1, 3, 1),\n      new THREE.Vector3(1, 3, -1),\n      new THREE.Vector3(1, -1, 1),\n      new THREE.Vector3(1, -1, -1),\n      new THREE.Vector3(-1, 3, -1),\n      new THREE.Vector3(-1, 3, 1),\n      new THREE.Vector3(-1, -1, -1),\n      new THREE.Vector3(-1, -1, 1)\n    ]\n\n    // 增加 6个面\n    var faces = [\n      // 一个正方形由两个三角形构成\n      new THREE.Face3(0, 2, 1),\n      new THREE.Face3(2, 3, 1),\n\n      new THREE.Face3(4, 5, 6),\n      new THREE.Face3(6, 7, 5),\n\n      new THREE.Face3(4, 5, 1),\n      new THREE.Face3(5, 0, 1),\n      \n      new THREE.Face3(7, 6, 2),\n      new THREE.Face3(6, 3, 2),\n      \n      new THREE.Face3(5, 7, 0),\n      new THREE.Face3(7, 2, 0),\n      \n      new THREE.Face3(1, 3, 4),\n      new THREE.Face3(3, 4, 4),\n    ]\n\n    // 创建几何体\n    var geom = new THREE.Geometry()\n    geom.vertices = vertices\n    geom.faces = faces\n    geom.computeFaceNormals()\n\n    // 增加材质\n    var materials = [\n      new THREE.MeshLambertMaterial({\n        opacity: 0.5, \n        color: 0x44ff44, \n        transparent: true\n      }),\n      new THREE.MeshLambertMaterial({\n        color: 0x000000, \n        wireframe: true\n      })\n    ]\n\n    // 构成物体\n    var mesh = new THREE.SceneUtils.createMultiMaterialObject(geom, materials)\n    mesh.children.forEach(\n      (e) => {\n        e.castShadow = true\n      }\n    )\n\n\n    // 平移\n    mesh.position.x = 10\n    mesh.position.y = 10\n    mesh.position.z = 1\n    // // 等同于\n    // mesh.position.set(10, 10, 1)\n    \n    // // 旋转\n    mesh.rotation.x = 2\n    mesh.rotation.y = 2\n    mesh.rotation.z = 2\n\n    // // x 轴方向放大4倍\n    mesh.scale.x = 4\n\n\n    scene.add(mesh)\n    renderer.render(scene, camera)\n\n</script>\n</html>\n```","slug":"【Three】Three-js入门之几何和网格对象","published":1,"updated":"2019-09-09T16:57:46.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4x100gdaas6r6i12ide"},{"title":"【Three】Three.js入门之相机","date":"2019-04-03T15:51:33.000Z","_content":"\n\n有两种相机\n* 近交投影\n* 正交投影\n\n## 近交投影\n和真实世界中我们所看到的物体一样， 近大远小\n![近交投影](http://img.nixiaolei.com/three-camera-a.png)\n\n\n### 透视投影照相机\n> THREE.PerspectiveCamera(fov, aspect, near, far)\n\n![透视投影照相机](http://img.nixiaolei.com/perspectiveCamera.png)\n\n* fov ---- 视野宽度\n* aspect ---- 长宽比， 推荐使用 window.innerWidth / window.innerHeight\n* near ---- 近裁面， 推荐值 0.1\n* far ---- 远裁面， 推荐值 1000，  值太大影响性能， 值太小场景显示不全\n\n\n## 正交投影\n> 建模类软件使用的比较多\n\n\n正交投影就像老师在黑板上画的立方体，保证三维世界平行的线到了二维世界也是平行的， 不存在近大远小的概念，\n\n### 正交投影相机\n> THREE.OrthographicCamera(left, right, top, bottom, near, far)  // near far决定远近范围\n\n* left ---- 左边界\n* right ---- 右边界\n* top ---- 上边界\n* bottom ---- 下边界\n* near ---- 近裁面\n* far ---- 远裁面\n* camera.lookAt ---- 设置目标点\n\n\n在Three中， 创建正交投影相机的参数决定了所看到的`视景体`, `视景体`内部的物体才能显示在屏幕上，视景体外部的就会被裁剪掉\n\n\n\n图中灰色区域就是`视景体`\n![正交投影相机](http://img.nixiaolei.com/OrthographicCamera.png)\n\n\n\n\n## 摄影机效果比对\n说概念总是比较抽象， 我们来实际操作一下，\n\n大概思路就是， 首先将立方体铺满平面， 然后我们使用定时器来切换相机类型 ， 以此来区别出两种相机的效果\n\n\n### 第一步----将立方体铺满平面\n\n利用我们之前设定的面的宽高， 计算出一列应该有多少立方体， 一行应该有多少立方体， 然后将其排列好， 添加入场景\n\n```Js\n// 将立方体铺满屏幕\nvar cubeGeometry = new THREE.BoxGeometry(4,4,4)\nfor ( var j=0; j < planeGeometry.parameters.height / 5 ;j++) {  // 面高 50\n  for ( var i=0; i < planeGeometry.parameters.width / 5 ; i++) { // 面宽 70\n    // 随机生成\n    var rnd = Math.random() * 0.75 + 0.25\n    // 添加材质\n    var cubeMaterial = new THREE.MeshLambertMaterial()\n    // 添加颜色\n    cubeMaterial.color = new THREE.Color(rnd, 0, 0)\n    // 创建立方体\n    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n    // 设置立方体的位置\n    cube.position.x = -(planeGeometry.parameters.width / 2) + 2 +(i * 5)\n    cube.position.y = 2\n    cube.position.z = -(planeGeometry.parameters.height / 2) + 2 +(j * 5)\n    // 立方体加入场景\n    scene.add(cube)\n  }\n}\n```\n\n### 第二步----用键盘控制相机角度\n每当按下左右键时， 就调整相机的y 轴方向的旋转角度， 然后重新绘制场景\n\n```Js\n// 绑定键盘事件\ndocument.onkeydown = function(e) {\n  switch(e.keyCode) {\n    case 37:\n      camera.rotation.y += 0.02\n      render()\n      break;\n    case 39:\n      camera.rotation.y -= 0.02\n      render()\n      break;\n  }\n}\nfunction render() {\n  renderer.render(scene, camera)\n}\nrender()\n```\n\n\n\n### 第三步----利用定时器切换摄像机的模式\n\n利用定时器切换 相机的模式，然后就会在下次一用户按下键盘时被渲染出来\n\n```Js\n// 用于切换相机模式\nvar controls = new function () {\n  this.perspective = \"Perspective\"\n  this.switchCamera = function () {\n    if( camera instanceof THREE.PerspectiveCamera ) {\n      console.log('Orthographic')\n      this.perspective = 'Orthographic' \n      camera = new THREE.OrthographicCamera (\n        window.innerWidth / -16,\n        window.innerWidth / 16,\n        window.innerHeight / -16,\n        window.innerHeight / 16,\n        -200, \n        500\n      )\n      camera.position.x = -20\n      camera.position.y = 60\n      camera.position.z = 50\n      camera.lookAt(scene.position)\n    }else {\n      console.log('Perspective')\n      this.perspective = \"Perspective\"\n      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\n      camera.position.x = -20\n      camera.position.y = 60\n      camera.position.z = 50\n      camera.lookAt(scene.position)\n    }\n  }\n}\n// 切换相机模式\nsetInterval(() => {\n  controls.switchCamera()\n}, 2000)\n```\n\n\n### 查看效果\n随着我不断地按下键盘的方向键， 画布被重新渲染， 我们可以看到两种相机的不同效果在来回切换\n\n![两种摄影机模式](http://img.nixiaolei.com/camera-doubule-mode.gif)\n\n\n\n\n## 完整代码\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script>\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 10\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    // 打开阴影\n    renderer.shadowMapEnabled = true\n\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n\n    plane.receiveShadow = true\n    // 加入场景\n    scene.add(plane)\n\n\n    /*\n    *\n    *  添加材质和灯光\n    *\n    * */\n\n    // 设置点光源\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    // 设置位置\n    spotLight.position.set(-40, 60, -10)\n    spotLight.castShadow = true\n    // 添加进点光源\n    scene.add(spotLight)\n\n    // --------------------------关键区域-----------------------------------------\n\n    // 将立方体铺满屏幕\n    var cubeGeometry = new THREE.BoxGeometry(4,4,4)\n    for ( var j=0; j < planeGeometry.parameters.height / 5 ;j++) {  // 面高 50\n      for ( var i=0; i < planeGeometry.parameters.width / 5 ; i++) { // 面宽 70\n        // 随机生成\n        var rnd = Math.random() * 0.75 + 0.25\n        // 添加材质\n        var cubeMaterial = new THREE.MeshLambertMaterial()\n        // 添加颜色\n        cubeMaterial.color = new THREE.Color(rnd, 0, 0)\n        // 创建立方体\n        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n        // 设置立方体的位置\n        cube.position.x = -(planeGeometry.parameters.width / 2) + 2 +(i * 5)\n        cube.position.y = 2\n        cube.position.z = -(planeGeometry.parameters.height / 2) + 2 +(j * 5)\n        // 立方体加入场景\n        scene.add(cube)\n      }\n    }\n    // 用于切换相机模式\n    var controls = new function () {\n      this.perspective = \"Perspective\"\n      this.switchCamera = function () {\n        if( camera instanceof THREE.PerspectiveCamera ) {\n          console.log('Orthographic')\n          this.perspective = 'Orthographic' \n          camera = new THREE.OrthographicCamera (\n            window.innerWidth / -16,\n            window.innerWidth / 16,\n            window.innerHeight / -16,\n            window.innerHeight / 16,\n            -200, \n            500\n          )\n          camera.position.x = -20\n          camera.position.y = 60\n          camera.position.z = 50\n          camera.lookAt(scene.position)\n        }else {\n          console.log('Perspective')\n          this.perspective = \"Perspective\"\n          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\n          camera.position.x = -20\n          camera.position.y = 60\n          camera.position.z = 50\n          camera.lookAt(scene.position)\n        }\n      }\n    }\n    // 切换相机模式\n    setInterval(() => {\n      controls.switchCamera()\n    }, 2000)\n\n\n    // 绑定键盘事件\n    document.onkeydown = function(e) {\n      switch(e.keyCode) {\n        case 37:\n          camera.rotation.y += 0.02\n          render()\n          break;\n        case 39:\n          camera.rotation.y -= 0.02\n          render()\n          break;\n      }\n    }\n    function render() {\n      renderer.render(scene, camera)\n    }\n    render()\n\n    // --------------------------关键区域-----------------------------------------\n\n\n    // 将renderer的输出挂到 body\n    document.body.appendChild(renderer.domElement)\n\n\n</script>\n</html>\n```","source":"_posts/【Three】Three-js入门之相机.md","raw":"---\ntitle: 【Three】Three.js入门之相机\ndate: 2019-04-03 23:51:33\ncategories: 图形学\ntags: [图形学, ThreeJs]\n---\n\n\n有两种相机\n* 近交投影\n* 正交投影\n\n## 近交投影\n和真实世界中我们所看到的物体一样， 近大远小\n![近交投影](http://img.nixiaolei.com/three-camera-a.png)\n\n\n### 透视投影照相机\n> THREE.PerspectiveCamera(fov, aspect, near, far)\n\n![透视投影照相机](http://img.nixiaolei.com/perspectiveCamera.png)\n\n* fov ---- 视野宽度\n* aspect ---- 长宽比， 推荐使用 window.innerWidth / window.innerHeight\n* near ---- 近裁面， 推荐值 0.1\n* far ---- 远裁面， 推荐值 1000，  值太大影响性能， 值太小场景显示不全\n\n\n## 正交投影\n> 建模类软件使用的比较多\n\n\n正交投影就像老师在黑板上画的立方体，保证三维世界平行的线到了二维世界也是平行的， 不存在近大远小的概念，\n\n### 正交投影相机\n> THREE.OrthographicCamera(left, right, top, bottom, near, far)  // near far决定远近范围\n\n* left ---- 左边界\n* right ---- 右边界\n* top ---- 上边界\n* bottom ---- 下边界\n* near ---- 近裁面\n* far ---- 远裁面\n* camera.lookAt ---- 设置目标点\n\n\n在Three中， 创建正交投影相机的参数决定了所看到的`视景体`, `视景体`内部的物体才能显示在屏幕上，视景体外部的就会被裁剪掉\n\n\n\n图中灰色区域就是`视景体`\n![正交投影相机](http://img.nixiaolei.com/OrthographicCamera.png)\n\n\n\n\n## 摄影机效果比对\n说概念总是比较抽象， 我们来实际操作一下，\n\n大概思路就是， 首先将立方体铺满平面， 然后我们使用定时器来切换相机类型 ， 以此来区别出两种相机的效果\n\n\n### 第一步----将立方体铺满平面\n\n利用我们之前设定的面的宽高， 计算出一列应该有多少立方体， 一行应该有多少立方体， 然后将其排列好， 添加入场景\n\n```Js\n// 将立方体铺满屏幕\nvar cubeGeometry = new THREE.BoxGeometry(4,4,4)\nfor ( var j=0; j < planeGeometry.parameters.height / 5 ;j++) {  // 面高 50\n  for ( var i=0; i < planeGeometry.parameters.width / 5 ; i++) { // 面宽 70\n    // 随机生成\n    var rnd = Math.random() * 0.75 + 0.25\n    // 添加材质\n    var cubeMaterial = new THREE.MeshLambertMaterial()\n    // 添加颜色\n    cubeMaterial.color = new THREE.Color(rnd, 0, 0)\n    // 创建立方体\n    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n    // 设置立方体的位置\n    cube.position.x = -(planeGeometry.parameters.width / 2) + 2 +(i * 5)\n    cube.position.y = 2\n    cube.position.z = -(planeGeometry.parameters.height / 2) + 2 +(j * 5)\n    // 立方体加入场景\n    scene.add(cube)\n  }\n}\n```\n\n### 第二步----用键盘控制相机角度\n每当按下左右键时， 就调整相机的y 轴方向的旋转角度， 然后重新绘制场景\n\n```Js\n// 绑定键盘事件\ndocument.onkeydown = function(e) {\n  switch(e.keyCode) {\n    case 37:\n      camera.rotation.y += 0.02\n      render()\n      break;\n    case 39:\n      camera.rotation.y -= 0.02\n      render()\n      break;\n  }\n}\nfunction render() {\n  renderer.render(scene, camera)\n}\nrender()\n```\n\n\n\n### 第三步----利用定时器切换摄像机的模式\n\n利用定时器切换 相机的模式，然后就会在下次一用户按下键盘时被渲染出来\n\n```Js\n// 用于切换相机模式\nvar controls = new function () {\n  this.perspective = \"Perspective\"\n  this.switchCamera = function () {\n    if( camera instanceof THREE.PerspectiveCamera ) {\n      console.log('Orthographic')\n      this.perspective = 'Orthographic' \n      camera = new THREE.OrthographicCamera (\n        window.innerWidth / -16,\n        window.innerWidth / 16,\n        window.innerHeight / -16,\n        window.innerHeight / 16,\n        -200, \n        500\n      )\n      camera.position.x = -20\n      camera.position.y = 60\n      camera.position.z = 50\n      camera.lookAt(scene.position)\n    }else {\n      console.log('Perspective')\n      this.perspective = \"Perspective\"\n      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\n      camera.position.x = -20\n      camera.position.y = 60\n      camera.position.z = 50\n      camera.lookAt(scene.position)\n    }\n  }\n}\n// 切换相机模式\nsetInterval(() => {\n  controls.switchCamera()\n}, 2000)\n```\n\n\n### 查看效果\n随着我不断地按下键盘的方向键， 画布被重新渲染， 我们可以看到两种相机的不同效果在来回切换\n\n![两种摄影机模式](http://img.nixiaolei.com/camera-doubule-mode.gif)\n\n\n\n\n## 完整代码\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>第一个ThreeJs</title>\n</head>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n  }\n</style>\n<body>\n</body>\n<script src=\"../three.js\"></script>\n<!-- 游戏帧率辅助库 -->\n<script src=\"../stats.min.js\"></script>\n<script src=\"../SceneUtils.js\"></script>\n<script>\n    // 设置场景,\n    var scene = new THREE.Scene();\n    // 设置相机                      视角,  宽度/高度,   近距离点,  远距点\n    var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)\n    camera.position.x = -30\n    camera.position.y = 40\n    camera.position.z = 10\n    camera.lookAt(scene.position) // 看向场景的中央\n\n\n    // 设置绘制对象---基于Webgl的渲染器\n    var renderer = new THREE.WebGLRenderer()\n    renderer.setClearColor(new THREE.Color(0xeeeeee));\n    // 控制渲染尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    // 打开阴影\n    renderer.shadowMapEnabled = true\n\n\n    // 设置辅助测试工具\n    var axes = new THREE.AxisHelper(20)\n    scene.add(axes)\n\n    // 设置平面\n    var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度\n    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc}) // 设置颜色\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial)\n    // 设置旋转角度\n    plane.rotation.x = -0.5 * Math.PI;\n    // 设置坐标\n    plane.position.x = 15\n    plane.position.y = 0\n    plane.position.z = 0\n\n    plane.receiveShadow = true\n    // 加入场景\n    scene.add(plane)\n\n\n    /*\n    *\n    *  添加材质和灯光\n    *\n    * */\n\n    // 设置点光源\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    // 设置位置\n    spotLight.position.set(-40, 60, -10)\n    spotLight.castShadow = true\n    // 添加进点光源\n    scene.add(spotLight)\n\n    // --------------------------关键区域-----------------------------------------\n\n    // 将立方体铺满屏幕\n    var cubeGeometry = new THREE.BoxGeometry(4,4,4)\n    for ( var j=0; j < planeGeometry.parameters.height / 5 ;j++) {  // 面高 50\n      for ( var i=0; i < planeGeometry.parameters.width / 5 ; i++) { // 面宽 70\n        // 随机生成\n        var rnd = Math.random() * 0.75 + 0.25\n        // 添加材质\n        var cubeMaterial = new THREE.MeshLambertMaterial()\n        // 添加颜色\n        cubeMaterial.color = new THREE.Color(rnd, 0, 0)\n        // 创建立方体\n        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)\n        // 设置立方体的位置\n        cube.position.x = -(planeGeometry.parameters.width / 2) + 2 +(i * 5)\n        cube.position.y = 2\n        cube.position.z = -(planeGeometry.parameters.height / 2) + 2 +(j * 5)\n        // 立方体加入场景\n        scene.add(cube)\n      }\n    }\n    // 用于切换相机模式\n    var controls = new function () {\n      this.perspective = \"Perspective\"\n      this.switchCamera = function () {\n        if( camera instanceof THREE.PerspectiveCamera ) {\n          console.log('Orthographic')\n          this.perspective = 'Orthographic' \n          camera = new THREE.OrthographicCamera (\n            window.innerWidth / -16,\n            window.innerWidth / 16,\n            window.innerHeight / -16,\n            window.innerHeight / 16,\n            -200, \n            500\n          )\n          camera.position.x = -20\n          camera.position.y = 60\n          camera.position.z = 50\n          camera.lookAt(scene.position)\n        }else {\n          console.log('Perspective')\n          this.perspective = \"Perspective\"\n          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\n          camera.position.x = -20\n          camera.position.y = 60\n          camera.position.z = 50\n          camera.lookAt(scene.position)\n        }\n      }\n    }\n    // 切换相机模式\n    setInterval(() => {\n      controls.switchCamera()\n    }, 2000)\n\n\n    // 绑定键盘事件\n    document.onkeydown = function(e) {\n      switch(e.keyCode) {\n        case 37:\n          camera.rotation.y += 0.02\n          render()\n          break;\n        case 39:\n          camera.rotation.y -= 0.02\n          render()\n          break;\n      }\n    }\n    function render() {\n      renderer.render(scene, camera)\n    }\n    render()\n\n    // --------------------------关键区域-----------------------------------------\n\n\n    // 将renderer的输出挂到 body\n    document.body.appendChild(renderer.domElement)\n\n\n</script>\n</html>\n```","slug":"【Three】Three-js入门之相机","published":1,"updated":"2019-09-09T16:57:46.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4x200gfaas6yokz6f26"},{"title":"使用Jenkins构建前端持续集成","date":"2019-03-16T04:34:36.000Z","_content":"<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\n1. 安装JDK\n\n直接使用yum 安装的是 `openjdk` , 和sun 公司发布的jdk有略微区别， 但这里我们并不需要使用java,所以使用最快的方式安装\n\n\n```\nyum install -y java\n```\n\n2. 安装jenkins\n\n添加Jenkins库到yum库，Jenkins将从这里下载安装。\n\n```\nwget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo\nrpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key\nyum install -y jenkins\n```\n\n添加Jenkins库到yum库，Jenkins将从这里下载安装。\n```\nwget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpm\nrpm -ivh jenkins-2.7.3-1.1.noarch.rpm\n```\n\n3. 配置jenkis的端口\n\njenkins 的默认端口为 8080 ， 为了避免和其他的应用程序冲突， 所以建议修改一下默认占用的端口\n\n```\nvim /etc/sysconfig/jenkins\n```\n\n找到修改端口号：\n\n> JENKINS_PORT=\"8080\" \n\n4. 启动jenkins \n\n\n```\nservice jenkins start/stop/restart\n```\n* 安装成功后Jenkins将作为一个守护进程随系统启动\n* 系统会创建一个“jenkins”用户来允许这个服务，如果改变服务所有者，同时需要修改`/var/log/jenkins`, `/var/lib/jenkins`, 和`/var/cache/jenkins`的所有者\n* 启动的时候将从/etc/sysconfig/jenkins获取配置参数\n* 默认情况下，Jenkins运行在8080端口，在浏览器中直接访问该端进行服务配置\n* Jenkins的RPM仓库配置被加到/etc/yum.repos.d/jenkins.repo\n\n\n## 配置阶段\n安装好`jenkins` 后 ， 我们就可以根据刚才所设置的端口号访问 `jenkins` 服务了 \n\n比如进入 `127.0.0.1:8081` 访问`jenkins`\n\n首先会看到让我们输入初始密码\n\n它提示我们进入 `/var/lib/jenkins/secrets/initialAdminPassword ` 查看\n\n![输入初始密码](http://img.nixiaolei.com/2019-03-09-16-16-27.png)\n\n\n\n输入密码无误后， 就是提示我们安装对应的插件了，\n\n左边是推荐安装， 右边是自定义安装，  这里我们建议点击 `推荐安装`\n\n![选择推荐安装](http://img.nixiaolei.com/2019-03-09-16-17-31.png)\n\n\n\n\n安装过程可能稍长\n\n![等待安装完毕 ](http://img.nixiaolei.com/jenkins03.png)\n\n\n这时我们创建一个 `Jenkins` 账户， \n一定要牢记你的输入账号和密码， 用作之后的登录\n\n![创建账户](http://img.nixiaolei.com/2019-03-09-16-29-08.png)\n\n\n\n创建账户之后， 会显示一个 `jenkins` 的资源根路径， 一般不需要修改， 保持默认即可\n\n\n![资源路径](http://img.nixiaolei.com/2019-03-09-16-32-04.png)\n\n\n\n\n之后就是愉快的`jenkins` 之旅啦\n\n![开始使用Jenkins](http://img.nixiaolei.com/2019-03-09-16-32-37.png)\n\n\n## 补善插件阶段\n我们要做的前端持续集成， 所以 `jenkins` 默认安装的插件 并不能完全的满足我们的需求\n\n进入`jenkins` 主页面后， 找到插件管理\n\n![插件管理](http://img.nixiaolei.com/2019-03-09-16-36-26.png)\n\n\n\n首先查看我们必要的插件是否安装好了\n* NodeJs Plugin\n* Publish Over SSH\n* GitHub\n\n如果发现没有安装的就安装， 查漏补缺\n\n\n\n## 变量及远程服务器基本配置\n\n插件安装好后, 进入`系统设置` 界面, 进行变量的相关配置, 这里就展示几个可以修改的参数, 大部分都可以不用动, 使用默认就好\n\n![系统设置](http://img.nixiaolei.com/2019-03-09-17-36-54.png)\n\n\n管理员邮件地址, 推荐填写,  当jenkins 工作完成后会把 构建信息发送至此邮箱\n\n![邮件地址](http://img.nixiaolei.com/2019-03-09-17-42-24.png)\n\n(这条选择填写) 可以选择配置 github 服务器, 并且可以配置多个, 因为你的项目代码有可能在多个服务器上\n\n![github](http://img.nixiaolei.com/2019-03-09-17-43-51.png)\n\n\n比较重要的就是这里了 ,  配置远程服务器, 也就是你的发布地址\n\n点击新增添加你的服务器\n\n![添加你的服务器](http://img.nixiaolei.com/2019-03-09-17-48-05.png)\n\n\n\n点击新增后, 这里有几个关键的参数,  需要注意\n\n![参数注意](http://img.nixiaolei.com/2019-03-09-17-51-39.png)\n\n连接目标服务器肯定需要登录,  下面几个参数就是对应的验证参数, 你可以输入固定的密码, 也可以告诉Jenkins 你的本地私钥路径或私钥的内容,  前提是你配置了 ssh 的免密登录\n\n![配置免密](http://img.nixiaolei.com/2019-03-09-17-54-49.png)\n\n\n> 填写密钥路径这里你很有可能会出现权限不够的错误， 如下图，\n\n\n![编路径错误](http://img.nixiaolei.com/2019-03-10-10-43-33.png)\n\n\n\n\n因为`jenkins `的在运行时会自动的创建一个名为`jenkins`的用户， 而这个用户的权限不够，无法访问你的目录\n\n![编运行身份](http://img.nixiaolei.com/2019-03-10-10-46-12.png)\n\n\n\n解决方案有两个:\n1. 把密钥切换至一个普通用户可以访问的目录， 并修改密钥的所属用户身份和访问权限\n2. 把`jenkins` 的运行身份修改为 `root`, 但是会有点安全性问题\n\n本次实践以学习为目的， 所以这里我选择了第二钟\n\n> 相关操作文章: https://blog.csdn.net/jeikerxiao/article/details/80768949\n\n\nssh 免密配置成功后， 我们就可以开始创建一个自己的任务了\n\n\n\n## 创建任务阶段\n\n回到主页， 找到`新建任务`\n\n\n![编新建任务](http://img.nixiaolei.com/2019-03-10-10-55-02.png)\n\n\n\n进入新建任务后， 有几种不同的项目， 我们这里选择 `自由风格`， 并且输入项目名称\n\n![编自由风格](http://img.nixiaolei.com/2019-03-10-10-59-00.png)\n\n创建好项目后就会自动进入 当前项目的配置文件中\n\n\n首先我们看到`General`, 这是一些全局的配置， 在这里我们可以写上该项目的描述\n\n![编全局配置](http://img.nixiaolei.com/2019-03-10-11-02-26.png)\n\n\n`General`的后面几个类目是构建项目阶段几个比较大的步骤和流程\n\n\n如果你要配置的“github”项目， 可以在`Git`这里打上勾\n\n并且填写上仓库地址 及 分支 即可， 如果需要填写账户密码， 则可在`\tCredentials` 处新增配置\n\n\n![编github项目](http://img.nixiaolei.com/2019-03-10-11-11-35.png)\n\n\n接下来是看看构建触发器， 这里的填写根据你的工程需要， \n\n可以配置定时任务 或 多任务构建\n\n> 本次演示我并没有用到\n\n![编触发器](http://img.nixiaolei.com/2019-03-10-13-26-16.png)\n\n\n\n现在来到我们的重点`构建` ， \n\n我们可以添加步骤，我们可以看到能够支持 `Node`、`shell` 、`批处理`等等方式\n\n这些添加的步骤会按顺序执行， \n\n![编构建](http://img.nixiaolei.com/2019-03-10-13-30-56.png)\n\n\n我们需要`shell` 脚本来运行npm 命令\n\n所以我创建了 `shell`的操作步骤\n\n![编shell脚本](http://img.nixiaolei.com/2019-03-10-13-35-35.png)\n\n\n\n基于此， `jenkins` 就会自动帮我们做好 测试与打包的步骤，\n\n在此之后， 我们需要将测试通过的项目代码推送到远程发布服务器上， 所以， 我们添加一个`send files or execute commands over SSH` 步骤， \n\n\n![编overSSH](http://img.nixiaolei.com/2019-03-16-13-05-58.png)\n\n\n建议新旧文件搞两个文件夹存放， 这样可以先删除掉旧文件再把新文件拷贝过去\n\n> deploy文件参考\n\n![编deploy文件参考](http://img.nixiaolei.com/2019-03-16-13-08-32.png)\n\n\n\n## 你可能遇到的问题\n\n### 命令无效或不存在\n> 这里拿npm举例，  其他命令如:node ,都是同理\n\n![编无法使用npm命令](http://img.nixiaolei.com/2019-03-16-12-54-06.png)\n\n\n因为全局的命令需要设置`软连接` Jenkins 才可以访问的到\n\n如何设置:\n\n先查看一下你的 npm 在哪\n> whereis npm\n\n![编查看npm位置](http://img.nixiaolei.com/2019-03-16-12-57-08.png)\n\n这个`/usr/local/bin/npm` 就是你的npm所在位置 ( 使用带 `local` 的地址)\n\n我们来创建 `软连接`, 这里使用刚刚获取到的npm \n\n> ln -s /usr/local/bin/npm   /usr/bin\n \n\n如果出现无法修改的情况， 那我们就将他强制更改 😄\n\n> ln -sf /usr/local/bin/npm   /usr/bin\n\n\n再去构建一次Jenkins 任务\n\n看到控制台输出， 现在npm 可以正常运行了\n\n![编npm运行成功](http://img.nixiaolei.com/2019-03-10-18-56-51.png)\n\n\n\n\n\n\n## 持续集成的必要条件\n1. 必须有github 、svn或私有git服务器\n2. 完整的项目\n  1. test\n  2. 接口测试\n  3. 其他的测试内容\n3. CI 平台\n4. 项目代码要提交到Github、 svn等服务器上\n5. 保证代码在开发机的正常\n  1. bug\n  2. 运行环境 ( 引用的包要写入packa)\n6. 保证jenkins 环境一切正常\n7. 发布服务器上也要存在基础的运行环境(不包括项目本身引用的包)\n8. 必要的静态资源服务器\n9. 配置jenkins的自动化处理流程\n\n\n\n\n参考文章:\n> https://www.cnblogs.com/loveyouyou616/p/8714544.html\n\n","source":"_posts/使用Jenkins构建前端持续集成.md","raw":"---\ntitle: 使用Jenkins构建前端持续集成\ndate: 2019-03-16 12:34:36\ncategories: CI\ntags: [CI, Jenkins, Centos, 前端持续集成]\n---\n<script type=\"text/javascript\" src=\"/js/src/bai.js\"></script>\n\n\n1. 安装JDK\n\n直接使用yum 安装的是 `openjdk` , 和sun 公司发布的jdk有略微区别， 但这里我们并不需要使用java,所以使用最快的方式安装\n\n\n```\nyum install -y java\n```\n\n2. 安装jenkins\n\n添加Jenkins库到yum库，Jenkins将从这里下载安装。\n\n```\nwget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo\nrpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key\nyum install -y jenkins\n```\n\n添加Jenkins库到yum库，Jenkins将从这里下载安装。\n```\nwget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpm\nrpm -ivh jenkins-2.7.3-1.1.noarch.rpm\n```\n\n3. 配置jenkis的端口\n\njenkins 的默认端口为 8080 ， 为了避免和其他的应用程序冲突， 所以建议修改一下默认占用的端口\n\n```\nvim /etc/sysconfig/jenkins\n```\n\n找到修改端口号：\n\n> JENKINS_PORT=\"8080\" \n\n4. 启动jenkins \n\n\n```\nservice jenkins start/stop/restart\n```\n* 安装成功后Jenkins将作为一个守护进程随系统启动\n* 系统会创建一个“jenkins”用户来允许这个服务，如果改变服务所有者，同时需要修改`/var/log/jenkins`, `/var/lib/jenkins`, 和`/var/cache/jenkins`的所有者\n* 启动的时候将从/etc/sysconfig/jenkins获取配置参数\n* 默认情况下，Jenkins运行在8080端口，在浏览器中直接访问该端进行服务配置\n* Jenkins的RPM仓库配置被加到/etc/yum.repos.d/jenkins.repo\n\n\n## 配置阶段\n安装好`jenkins` 后 ， 我们就可以根据刚才所设置的端口号访问 `jenkins` 服务了 \n\n比如进入 `127.0.0.1:8081` 访问`jenkins`\n\n首先会看到让我们输入初始密码\n\n它提示我们进入 `/var/lib/jenkins/secrets/initialAdminPassword ` 查看\n\n![输入初始密码](http://img.nixiaolei.com/2019-03-09-16-16-27.png)\n\n\n\n输入密码无误后， 就是提示我们安装对应的插件了，\n\n左边是推荐安装， 右边是自定义安装，  这里我们建议点击 `推荐安装`\n\n![选择推荐安装](http://img.nixiaolei.com/2019-03-09-16-17-31.png)\n\n\n\n\n安装过程可能稍长\n\n![等待安装完毕 ](http://img.nixiaolei.com/jenkins03.png)\n\n\n这时我们创建一个 `Jenkins` 账户， \n一定要牢记你的输入账号和密码， 用作之后的登录\n\n![创建账户](http://img.nixiaolei.com/2019-03-09-16-29-08.png)\n\n\n\n创建账户之后， 会显示一个 `jenkins` 的资源根路径， 一般不需要修改， 保持默认即可\n\n\n![资源路径](http://img.nixiaolei.com/2019-03-09-16-32-04.png)\n\n\n\n\n之后就是愉快的`jenkins` 之旅啦\n\n![开始使用Jenkins](http://img.nixiaolei.com/2019-03-09-16-32-37.png)\n\n\n## 补善插件阶段\n我们要做的前端持续集成， 所以 `jenkins` 默认安装的插件 并不能完全的满足我们的需求\n\n进入`jenkins` 主页面后， 找到插件管理\n\n![插件管理](http://img.nixiaolei.com/2019-03-09-16-36-26.png)\n\n\n\n首先查看我们必要的插件是否安装好了\n* NodeJs Plugin\n* Publish Over SSH\n* GitHub\n\n如果发现没有安装的就安装， 查漏补缺\n\n\n\n## 变量及远程服务器基本配置\n\n插件安装好后, 进入`系统设置` 界面, 进行变量的相关配置, 这里就展示几个可以修改的参数, 大部分都可以不用动, 使用默认就好\n\n![系统设置](http://img.nixiaolei.com/2019-03-09-17-36-54.png)\n\n\n管理员邮件地址, 推荐填写,  当jenkins 工作完成后会把 构建信息发送至此邮箱\n\n![邮件地址](http://img.nixiaolei.com/2019-03-09-17-42-24.png)\n\n(这条选择填写) 可以选择配置 github 服务器, 并且可以配置多个, 因为你的项目代码有可能在多个服务器上\n\n![github](http://img.nixiaolei.com/2019-03-09-17-43-51.png)\n\n\n比较重要的就是这里了 ,  配置远程服务器, 也就是你的发布地址\n\n点击新增添加你的服务器\n\n![添加你的服务器](http://img.nixiaolei.com/2019-03-09-17-48-05.png)\n\n\n\n点击新增后, 这里有几个关键的参数,  需要注意\n\n![参数注意](http://img.nixiaolei.com/2019-03-09-17-51-39.png)\n\n连接目标服务器肯定需要登录,  下面几个参数就是对应的验证参数, 你可以输入固定的密码, 也可以告诉Jenkins 你的本地私钥路径或私钥的内容,  前提是你配置了 ssh 的免密登录\n\n![配置免密](http://img.nixiaolei.com/2019-03-09-17-54-49.png)\n\n\n> 填写密钥路径这里你很有可能会出现权限不够的错误， 如下图，\n\n\n![编路径错误](http://img.nixiaolei.com/2019-03-10-10-43-33.png)\n\n\n\n\n因为`jenkins `的在运行时会自动的创建一个名为`jenkins`的用户， 而这个用户的权限不够，无法访问你的目录\n\n![编运行身份](http://img.nixiaolei.com/2019-03-10-10-46-12.png)\n\n\n\n解决方案有两个:\n1. 把密钥切换至一个普通用户可以访问的目录， 并修改密钥的所属用户身份和访问权限\n2. 把`jenkins` 的运行身份修改为 `root`, 但是会有点安全性问题\n\n本次实践以学习为目的， 所以这里我选择了第二钟\n\n> 相关操作文章: https://blog.csdn.net/jeikerxiao/article/details/80768949\n\n\nssh 免密配置成功后， 我们就可以开始创建一个自己的任务了\n\n\n\n## 创建任务阶段\n\n回到主页， 找到`新建任务`\n\n\n![编新建任务](http://img.nixiaolei.com/2019-03-10-10-55-02.png)\n\n\n\n进入新建任务后， 有几种不同的项目， 我们这里选择 `自由风格`， 并且输入项目名称\n\n![编自由风格](http://img.nixiaolei.com/2019-03-10-10-59-00.png)\n\n创建好项目后就会自动进入 当前项目的配置文件中\n\n\n首先我们看到`General`, 这是一些全局的配置， 在这里我们可以写上该项目的描述\n\n![编全局配置](http://img.nixiaolei.com/2019-03-10-11-02-26.png)\n\n\n`General`的后面几个类目是构建项目阶段几个比较大的步骤和流程\n\n\n如果你要配置的“github”项目， 可以在`Git`这里打上勾\n\n并且填写上仓库地址 及 分支 即可， 如果需要填写账户密码， 则可在`\tCredentials` 处新增配置\n\n\n![编github项目](http://img.nixiaolei.com/2019-03-10-11-11-35.png)\n\n\n接下来是看看构建触发器， 这里的填写根据你的工程需要， \n\n可以配置定时任务 或 多任务构建\n\n> 本次演示我并没有用到\n\n![编触发器](http://img.nixiaolei.com/2019-03-10-13-26-16.png)\n\n\n\n现在来到我们的重点`构建` ， \n\n我们可以添加步骤，我们可以看到能够支持 `Node`、`shell` 、`批处理`等等方式\n\n这些添加的步骤会按顺序执行， \n\n![编构建](http://img.nixiaolei.com/2019-03-10-13-30-56.png)\n\n\n我们需要`shell` 脚本来运行npm 命令\n\n所以我创建了 `shell`的操作步骤\n\n![编shell脚本](http://img.nixiaolei.com/2019-03-10-13-35-35.png)\n\n\n\n基于此， `jenkins` 就会自动帮我们做好 测试与打包的步骤，\n\n在此之后， 我们需要将测试通过的项目代码推送到远程发布服务器上， 所以， 我们添加一个`send files or execute commands over SSH` 步骤， \n\n\n![编overSSH](http://img.nixiaolei.com/2019-03-16-13-05-58.png)\n\n\n建议新旧文件搞两个文件夹存放， 这样可以先删除掉旧文件再把新文件拷贝过去\n\n> deploy文件参考\n\n![编deploy文件参考](http://img.nixiaolei.com/2019-03-16-13-08-32.png)\n\n\n\n## 你可能遇到的问题\n\n### 命令无效或不存在\n> 这里拿npm举例，  其他命令如:node ,都是同理\n\n![编无法使用npm命令](http://img.nixiaolei.com/2019-03-16-12-54-06.png)\n\n\n因为全局的命令需要设置`软连接` Jenkins 才可以访问的到\n\n如何设置:\n\n先查看一下你的 npm 在哪\n> whereis npm\n\n![编查看npm位置](http://img.nixiaolei.com/2019-03-16-12-57-08.png)\n\n这个`/usr/local/bin/npm` 就是你的npm所在位置 ( 使用带 `local` 的地址)\n\n我们来创建 `软连接`, 这里使用刚刚获取到的npm \n\n> ln -s /usr/local/bin/npm   /usr/bin\n \n\n如果出现无法修改的情况， 那我们就将他强制更改 😄\n\n> ln -sf /usr/local/bin/npm   /usr/bin\n\n\n再去构建一次Jenkins 任务\n\n看到控制台输出， 现在npm 可以正常运行了\n\n![编npm运行成功](http://img.nixiaolei.com/2019-03-10-18-56-51.png)\n\n\n\n\n\n\n## 持续集成的必要条件\n1. 必须有github 、svn或私有git服务器\n2. 完整的项目\n  1. test\n  2. 接口测试\n  3. 其他的测试内容\n3. CI 平台\n4. 项目代码要提交到Github、 svn等服务器上\n5. 保证代码在开发机的正常\n  1. bug\n  2. 运行环境 ( 引用的包要写入packa)\n6. 保证jenkins 环境一切正常\n7. 发布服务器上也要存在基础的运行环境(不包括项目本身引用的包)\n8. 必要的静态资源服务器\n9. 配置jenkins的自动化处理流程\n\n\n\n\n参考文章:\n> https://www.cnblogs.com/loveyouyou616/p/8714544.html\n\n","slug":"使用Jenkins构建前端持续集成","published":1,"updated":"2019-09-09T16:57:46.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4x300ghaas6hlv3p4ks"},{"title":"面向对象设计原则之S.O.L.I.D","date":"2019-03-24T01:39:12.000Z","_content":"\n\n作为一名优秀的工程师，最重要的不是招式， 而是内功， 像武侠小说里的高手， 一旦有了几十年的内功， 学什么武功都能快人一步\n\n\n那编程里如何提升内功， 主要就是体现在编程思想上了，\n\n## 逐层提升你编程思想\n比如从一开始的最传统的面向对象 到 面向切面\n\n面向对象 -> 工厂模式 -> 面向切面\n\n\n从 \"oop 的静态抽象\" 演变为 \"aop的动态抽象\"\n\n![提升思想](http://img.nixiaolei.com/2019-03-24-09-45-24.png)\n\n\n## SOLID原则的基本概念\n\n让我们来看下 `SOLID` 的概念\n\n程序设计领域， SOLID (单一一功能、开闭原则、⾥里里⽒氏替换、接⼝口隔离以及依赖反转)是由罗伯特·C·⻢马丁在21世纪早期 引⼊入的记忆术⾸首字⺟母缩略略字，指代了了⾯面向对象编程和⾯面向对象设计的五个基本原则。当这些原则被一一起应⽤用时，它们使得一一个程序员开发一一个容易易进⾏行行软件维护和扩展的系统变得更更加可能SOLID被典型的应⽤用在测试驱动开发上，并且是敏敏捷开发以及⾃自适应软件开发的基本原则的重要组成部分。\n\n\n## SOLID这几个字母代表什么意义？\n\n\n### S (单一一功能原则)\n> Single Responsibility Principle \n\n单一一功能原则 ：单一一功能原则 认为对象应该仅具有一一种单一一功能的概念。\n换句句话说就是让一一个类只做一一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。\n在所有的SOLID原则中，这是⼤大多数开发⼈人员感到最能完全理理解的一一条。严格来说，这也可能是违反最频繁的一一条原则了了。\n单一一责任原则可以看作是低耦合、⾼内聚在面向对象原则上的引申，将责任定义为引起变化的原因，以提高内聚性来减少引起变化的原因。\n责任过多，可能引起它变化的原因就越多，这将导致责任依赖，相互之间就产⽣生影响，\n从⽽而极⼤大的损伤其内聚性和耦合度。单一一责任，通常意味着单一一的功能，因此不不要为一一个模块实 现过多的功能点，以保证实体只有一一个引起它变化的原因。\n\n\n**缩减一下就是:**\n> 让每个函数和每个类都只做一件小事，职责单一，解耦和\n\n\n\n### O (开闭原则)\n> Open Close Principle\n\n开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。\n软件实体应该是可扩展，而不不可修改的。也就是说，对扩展是开放的，而对修改是封闭的（“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不不应该被修改。也就是说你可以新增功能但不能去修改源码。）。这个原则是诸多面向对象编程原则中最抽象、最难理理解的一个。\n\n对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独⽴立完成其⼯工作，⽽而不要对类进⾏行行任何修改。可以使用变化和不变来说明：封装不变部分，开放变化部分，一般使用接口继承实现⽅方式来实现“开放”应对变化。\n\n说大白话就是：你不不是要变化吗？，那么我就让你继承实现一个对象，用一个接口来抽象你的职责，你变化越多，继承实现的子类就越多。\n\n\n让我们来看下一个简单的 `Ts` demo\n\n**糟糕的实现**\n```TypeScript\nclass Animal {\n\n  constructor(name: any) {\n    super(name)\n    this.name = name\n  }\n  eat() {\n    if(this.name == '小猫') {\n      console.log(this.name + '吃猫粮')\n    } else if( this.name == \"小狗\") {\n      console.log(this.name + '吃狗粮')\n    }\n  }\n}\n```\n\n这种糟糕的实现不但使程序的可扩展性降低， 而且每次新增一种动物都需要修改之前的代码， 容易造成隐患， 这和编程思想极大的违背\n\n\n\n**利用 `OCP` 思想**\n```TypeScript\n// Animal 抽象类\nabstract class Animal {\n  public name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  abstract eat(): any;\n}\n\n// 实现Animal抽象类\nclass Dog extends Animal {\n  constructor(name: any) {\n    super(name)\n  }\n  eat() {\n    console.log(this.name + '吃狗粮')\n  }\n}\nvar d = new Dog('小狗')\nd.eat()\n```\n\n上面的代码中， 首先使用`abstract` 定义抽象类和抽象方法，提供其他类继承的基类\n我们定义只要是`Animal`就必须要有`eat`方法\n\n于是， 我们创建了一个`Dog` 继承`Animal` ,  \n这个`Dog`就不一般了， 它规定了必须重新实现 `eat` 方法， 并且可以扩展自己的方法\n\n当我们将来如果需要一只 `Cat`\n我们一样只需要让他继承`Animal`抽象类， 然后实现一个自己的`eat`方法\n\n\n\n### L (里⽒氏替换原则)\n> Liskov Substitution Principle\n\n里氏替换原则: 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下提前被它的子类所替换的”的概念。\n\n**子类必须能够替换他们的基类**。即： 子类应该可以替换任何基类能够出现的地方， 并且经过替换以后， 代码还能正常工作。 另外， 不应该在代码中出现`if/else`之类对子类类型进行判断的条件。 里氏替换原则`LSP`使使代码符合开闭原则的一个重要保证。 正是由于子类的替换性才使得父类型的模块在无需修改的情况下就可以扩展。在很多情况下， 在设计初期我们类之间的关系不是很明确， `LSP`则给了我们一个判断和设计类之间关系的基准: 需不需要继承， 以及怎样设计继承关系。\n\n当一个子类的实例应该能够替换任何其超类的实例时， 它们之间才具有is-A关系。 继承对于OCP， 就相当于多态性对于里氏替换原则。子类可以代替基类， 客户使用基类， 他们不需要知道派生类所做的事情。这是一个针对行为职责可替代的原则， 如果S是T的子类型， 那么S对象就应该在不改变任何抽象属性情况下替换所有T对象。\n\n\n\n\n**缩减一下就是:**\n> 老爸能干的事， 儿子必须都能干， 并且还要干的能多， 只要有儿子在， 老爸不在现场都没关系\n\n\n\n### I (接⼝隔离原则)\n> Interface Segregation Principle\n\n接口隔离原则: 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。\n\n不能强迫用户去依赖那些他们不能使用的接口。 换句话说， **使用多个专门的接口比使用单一的总接口总要好(JavaScript几乎没有接口的概念， 所以使用ts)。** 注意： 在代码中应用 `ISP` 并不一定意味着服务就是绝对安全的。 仍然需要采用良好的编码实践， 以确保正确的验证与授权。\n\n这个原则起源于施乐公司， 他们需要建立了一个新的打印机系统， 可以执行诸如装订的印刷品一套，传真多种任务。此系统软件创建从底层开始编制， 并实现了这些任务功能， 但是不断增长的软件功能却使软件本身越来越难适应变化和维护。 每一次改变，即使是最小的变化， 有人可能需要近一个小时的重新编译和重新部署。这几乎不可能再继续发展， 所以他们聘请罗伯特(Robert)帮助他们。他们首先设计了一个主要类Job,几乎能够用于实现所有任务功能。 只要调用Job类的一个方法就可以实现一个功能， Job类就变动非常大， 是一个胖模型啊， 对于客户端如果只需要一个打印功能， 但是其他无关打印的方法功能也和其耦合， `ISP`原则建议在客户端和Job类之间增加一个接口层， 对于不同功能有不同的接口， 比如打印功能就是Print接口， 然后将大的Job类切分为继承不同接口的子类， 这样有一个Print Job类 等等。\n\n\n\n**缩减一下就是:**\n> 每一个业务都要准备一个接口， 每个不同功能的接口再继承自公共的基础接口\n\n\n\n\n### D (依赖反转原则)\n> Dependency Inversion Principle\n\n依赖倒置原则（Dependency Inversion Principle， DIP）规定： 代码应当取决于抽象概念， 而不是具体实现。\n\n**高层模块不应该依赖于底层模块， 二者都应该依赖于抽象**\n**抽象不应该依赖于细节， 细节应该依赖于抽象(总结解耦)**\n\n类可能依赖于其他类来执行其工作， 但是， 他们不应当依赖于该类的特定具体实现， 而应当是它的抽象。 这个原则实在是太重要了， 社会的分工化， 标准化都是这个设计原则的体现。显然， 这一概念会大大提高系统的灵活性。 如果类只是关心他们支持特定锲约而不是特定类型的组件， 就可以快速而轻松地修改这些低级服务的功能， 同时最大限度地降低对系统其余部分地影响。\n\n\n**举个例子:**\n\n你家里需要洗衣机， 不可能把整个洗衣机的生产流程都给实现了， 搬到自己家里， 当然时去超市商场购买一台洗衣机。 你需要电饭煲，也不可能把电饭煲地生产工艺实现了， 也是去商场买现成地。\n\n此时商场就是一个容器， 商场帮我们去各个工厂采购这些商品，  当我们需要某件物品时就可以去商场购买现成地商品\n\n\n\n#### 依赖反转原则\n\n**依赖注入**\n\n当某个⻆角⾊色要另一个角色协助时，通常由调用者来创建被调用者的实例。现在创建实例由容器来完成然后注⼊调用者。\n\n**注⼊入过程**\n\n如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注⼊\n\n\n**依赖反转有两种方式**\n1. 设值注入（在类上方设置字段）\n2. 构造注入 （在`constructor`中接收需要地参数）\n\n![依赖反转原则](http://img.nixiaolei.com/2019-03-24-13-25-50.png)\n\n\n#### DI（依赖注⼊入）\n> 依赖注⼊入（Dependency Injection）\n\n为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注⼊是该原则的一种实现⽅方式。\n\n\n\n\n\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/面向对象设计原则之SOLID.md","raw":"---\ntitle: 面向对象设计原则之S.O.L.I.D\ndate: 2019-03-24 09:39:12\ncategories: 编程思想\ntags: [oop, 编程原则]\n---\n\n\n作为一名优秀的工程师，最重要的不是招式， 而是内功， 像武侠小说里的高手， 一旦有了几十年的内功， 学什么武功都能快人一步\n\n\n那编程里如何提升内功， 主要就是体现在编程思想上了，\n\n## 逐层提升你编程思想\n比如从一开始的最传统的面向对象 到 面向切面\n\n面向对象 -> 工厂模式 -> 面向切面\n\n\n从 \"oop 的静态抽象\" 演变为 \"aop的动态抽象\"\n\n![提升思想](http://img.nixiaolei.com/2019-03-24-09-45-24.png)\n\n\n## SOLID原则的基本概念\n\n让我们来看下 `SOLID` 的概念\n\n程序设计领域， SOLID (单一一功能、开闭原则、⾥里里⽒氏替换、接⼝口隔离以及依赖反转)是由罗伯特·C·⻢马丁在21世纪早期 引⼊入的记忆术⾸首字⺟母缩略略字，指代了了⾯面向对象编程和⾯面向对象设计的五个基本原则。当这些原则被一一起应⽤用时，它们使得一一个程序员开发一一个容易易进⾏行行软件维护和扩展的系统变得更更加可能SOLID被典型的应⽤用在测试驱动开发上，并且是敏敏捷开发以及⾃自适应软件开发的基本原则的重要组成部分。\n\n\n## SOLID这几个字母代表什么意义？\n\n\n### S (单一一功能原则)\n> Single Responsibility Principle \n\n单一一功能原则 ：单一一功能原则 认为对象应该仅具有一一种单一一功能的概念。\n换句句话说就是让一一个类只做一一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。\n在所有的SOLID原则中，这是⼤大多数开发⼈人员感到最能完全理理解的一一条。严格来说，这也可能是违反最频繁的一一条原则了了。\n单一一责任原则可以看作是低耦合、⾼内聚在面向对象原则上的引申，将责任定义为引起变化的原因，以提高内聚性来减少引起变化的原因。\n责任过多，可能引起它变化的原因就越多，这将导致责任依赖，相互之间就产⽣生影响，\n从⽽而极⼤大的损伤其内聚性和耦合度。单一一责任，通常意味着单一一的功能，因此不不要为一一个模块实 现过多的功能点，以保证实体只有一一个引起它变化的原因。\n\n\n**缩减一下就是:**\n> 让每个函数和每个类都只做一件小事，职责单一，解耦和\n\n\n\n### O (开闭原则)\n> Open Close Principle\n\n开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。\n软件实体应该是可扩展，而不不可修改的。也就是说，对扩展是开放的，而对修改是封闭的（“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不不应该被修改。也就是说你可以新增功能但不能去修改源码。）。这个原则是诸多面向对象编程原则中最抽象、最难理理解的一个。\n\n对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独⽴立完成其⼯工作，⽽而不要对类进⾏行行任何修改。可以使用变化和不变来说明：封装不变部分，开放变化部分，一般使用接口继承实现⽅方式来实现“开放”应对变化。\n\n说大白话就是：你不不是要变化吗？，那么我就让你继承实现一个对象，用一个接口来抽象你的职责，你变化越多，继承实现的子类就越多。\n\n\n让我们来看下一个简单的 `Ts` demo\n\n**糟糕的实现**\n```TypeScript\nclass Animal {\n\n  constructor(name: any) {\n    super(name)\n    this.name = name\n  }\n  eat() {\n    if(this.name == '小猫') {\n      console.log(this.name + '吃猫粮')\n    } else if( this.name == \"小狗\") {\n      console.log(this.name + '吃狗粮')\n    }\n  }\n}\n```\n\n这种糟糕的实现不但使程序的可扩展性降低， 而且每次新增一种动物都需要修改之前的代码， 容易造成隐患， 这和编程思想极大的违背\n\n\n\n**利用 `OCP` 思想**\n```TypeScript\n// Animal 抽象类\nabstract class Animal {\n  public name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  abstract eat(): any;\n}\n\n// 实现Animal抽象类\nclass Dog extends Animal {\n  constructor(name: any) {\n    super(name)\n  }\n  eat() {\n    console.log(this.name + '吃狗粮')\n  }\n}\nvar d = new Dog('小狗')\nd.eat()\n```\n\n上面的代码中， 首先使用`abstract` 定义抽象类和抽象方法，提供其他类继承的基类\n我们定义只要是`Animal`就必须要有`eat`方法\n\n于是， 我们创建了一个`Dog` 继承`Animal` ,  \n这个`Dog`就不一般了， 它规定了必须重新实现 `eat` 方法， 并且可以扩展自己的方法\n\n当我们将来如果需要一只 `Cat`\n我们一样只需要让他继承`Animal`抽象类， 然后实现一个自己的`eat`方法\n\n\n\n### L (里⽒氏替换原则)\n> Liskov Substitution Principle\n\n里氏替换原则: 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下提前被它的子类所替换的”的概念。\n\n**子类必须能够替换他们的基类**。即： 子类应该可以替换任何基类能够出现的地方， 并且经过替换以后， 代码还能正常工作。 另外， 不应该在代码中出现`if/else`之类对子类类型进行判断的条件。 里氏替换原则`LSP`使使代码符合开闭原则的一个重要保证。 正是由于子类的替换性才使得父类型的模块在无需修改的情况下就可以扩展。在很多情况下， 在设计初期我们类之间的关系不是很明确， `LSP`则给了我们一个判断和设计类之间关系的基准: 需不需要继承， 以及怎样设计继承关系。\n\n当一个子类的实例应该能够替换任何其超类的实例时， 它们之间才具有is-A关系。 继承对于OCP， 就相当于多态性对于里氏替换原则。子类可以代替基类， 客户使用基类， 他们不需要知道派生类所做的事情。这是一个针对行为职责可替代的原则， 如果S是T的子类型， 那么S对象就应该在不改变任何抽象属性情况下替换所有T对象。\n\n\n\n\n**缩减一下就是:**\n> 老爸能干的事， 儿子必须都能干， 并且还要干的能多， 只要有儿子在， 老爸不在现场都没关系\n\n\n\n### I (接⼝隔离原则)\n> Interface Segregation Principle\n\n接口隔离原则: 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。\n\n不能强迫用户去依赖那些他们不能使用的接口。 换句话说， **使用多个专门的接口比使用单一的总接口总要好(JavaScript几乎没有接口的概念， 所以使用ts)。** 注意： 在代码中应用 `ISP` 并不一定意味着服务就是绝对安全的。 仍然需要采用良好的编码实践， 以确保正确的验证与授权。\n\n这个原则起源于施乐公司， 他们需要建立了一个新的打印机系统， 可以执行诸如装订的印刷品一套，传真多种任务。此系统软件创建从底层开始编制， 并实现了这些任务功能， 但是不断增长的软件功能却使软件本身越来越难适应变化和维护。 每一次改变，即使是最小的变化， 有人可能需要近一个小时的重新编译和重新部署。这几乎不可能再继续发展， 所以他们聘请罗伯特(Robert)帮助他们。他们首先设计了一个主要类Job,几乎能够用于实现所有任务功能。 只要调用Job类的一个方法就可以实现一个功能， Job类就变动非常大， 是一个胖模型啊， 对于客户端如果只需要一个打印功能， 但是其他无关打印的方法功能也和其耦合， `ISP`原则建议在客户端和Job类之间增加一个接口层， 对于不同功能有不同的接口， 比如打印功能就是Print接口， 然后将大的Job类切分为继承不同接口的子类， 这样有一个Print Job类 等等。\n\n\n\n**缩减一下就是:**\n> 每一个业务都要准备一个接口， 每个不同功能的接口再继承自公共的基础接口\n\n\n\n\n### D (依赖反转原则)\n> Dependency Inversion Principle\n\n依赖倒置原则（Dependency Inversion Principle， DIP）规定： 代码应当取决于抽象概念， 而不是具体实现。\n\n**高层模块不应该依赖于底层模块， 二者都应该依赖于抽象**\n**抽象不应该依赖于细节， 细节应该依赖于抽象(总结解耦)**\n\n类可能依赖于其他类来执行其工作， 但是， 他们不应当依赖于该类的特定具体实现， 而应当是它的抽象。 这个原则实在是太重要了， 社会的分工化， 标准化都是这个设计原则的体现。显然， 这一概念会大大提高系统的灵活性。 如果类只是关心他们支持特定锲约而不是特定类型的组件， 就可以快速而轻松地修改这些低级服务的功能， 同时最大限度地降低对系统其余部分地影响。\n\n\n**举个例子:**\n\n你家里需要洗衣机， 不可能把整个洗衣机的生产流程都给实现了， 搬到自己家里， 当然时去超市商场购买一台洗衣机。 你需要电饭煲，也不可能把电饭煲地生产工艺实现了， 也是去商场买现成地。\n\n此时商场就是一个容器， 商场帮我们去各个工厂采购这些商品，  当我们需要某件物品时就可以去商场购买现成地商品\n\n\n\n#### 依赖反转原则\n\n**依赖注入**\n\n当某个⻆角⾊色要另一个角色协助时，通常由调用者来创建被调用者的实例。现在创建实例由容器来完成然后注⼊调用者。\n\n**注⼊入过程**\n\n如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注⼊\n\n\n**依赖反转有两种方式**\n1. 设值注入（在类上方设置字段）\n2. 构造注入 （在`constructor`中接收需要地参数）\n\n![依赖反转原则](http://img.nixiaolei.com/2019-03-24-13-25-50.png)\n\n\n#### DI（依赖注⼊入）\n> 依赖注⼊入（Dependency Injection）\n\n为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注⼊是该原则的一种实现⽅方式。\n\n\n\n\n\n\n\n\n<div style='display: none;'>\n谢谢最可爱的贝玺\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"面向对象设计原则之SOLID","published":1,"updated":"2019-09-09T16:57:46.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf4x400glaas6qi3d5h58"},{"title":"【Vue】源码解析","date":"2019-03-18T01:50:34.000Z","_content":"\n现在三大框架风起云涌， `JQuery`老大哥的光辉不再， 使前端成为了各路诸侯的兵家必争之地， \n\n当然作为一名优质的前端，光跟风学框架是肯定不行的， 要知其然而知其所以然\n\n要了解`MVVM`的本质原理， `virtual Dom`和 `Diff`算法解决的问题\n\n拒绝盲目跟风\n\n\n## 🍎diffDom优劣\n现在很多人都说 `Vue`, `React` 多牛， `Diff`算法快，不用操作`Dom`。\n\n只能无语。\n\n`Diff`算法不是不需要操作`Dom`,  而是不需要开发者去操作`Dom`了， `Diff`算法其实不快， 就算使用了`virtual Dom`,  还得花实现把真实`Dom` 转换为 `virtual Dom` 再去比对， 这远远没有`js`直接 `getElementById`直达目标来的快\n\n那Diff算法不快为什么还要用呢?\n\n`Diff`算法其实是给那些比较随意的新手开发者准备的\n\n看这个例子\n\n```HTML\n<!-- 原本的dom -->\n<ul id=\"ul\">\n  <li>a</li>\n  <li>a</li>\n  <li>a</li>\n</ul>\n```\n```JavaScript\n// 拿到结果不管三七二十一把旧dom全替换了\n$.get('/api', (res) => {\n  var _HTML = \"\"\n  for(var i=0; i< res.length; i++){\n    _HTML = \"<li>\" + res[i] +\"</li>\"\n  }\n  $(\"#ul\").html(_HTML)\n})\n```\n\n如果是原始的`Dom`操作， 有很多小白会像这个例子一样， 不管`Dom`需不需要更新， 他都把`ajax`返回的请求全部跑一边，生成`HTML`模板， 然后把原本的所有`li`都删了，  再把新的模板放进去， `Dom`少还看不出来， 如果`Dom`多了呢， 上千的`Dom`， 这顿操作一下就玩炸了。\n\n况且网站优化原则就是尽量减小`Dom`操作， 如果是有经验的开发者， 会选择找到有变化的位置，使用`append`插入\n\n\n\n## 📄Vue架构目录\n去[Vue官网](https://github.com/vuejs/vue)下载`Vue`源码看看，\n\n打开里面会有一个 `src`目录， 里面就是整个的`Vue`源码\n\n目前有6个目录， 作用分别如下\n\n![Vue目录](http://img.nixiaolei.com/2019-03-30-10-44-35.png)\n\n\n`Vue.js` 的组成是由 `core` + 对应的 '平台' 补充代码构成（独立构建和运行时构建只是 `platforms` 下 `web` 平台的两种选择）\n\n`Vue`的核心原理就在`core`文件夹中， 让我们进入 `core` 文件夹看看\n\n![core文件夹](http://img.nixiaolei.com/2019-03-30-10-57-26.png)\n\n了解了目录，接下来我们就来研究`Vue`的双向绑定\n\n## 🔗双向绑定（响应式原理） 所涉及到的技术\n* ✅ **Obejct.defineProperty** _【提供getter 和 setter】_\n* ✅ **Observer** _【提供getter 和 setter】_\n* ✅ **watcher**  _【提供getter 和 setter】_\n* ✅ **Dep** _【负责收集watcher】_\n* ✅ **Directive** _【处理Vue模板指令】_\n\n\n### Obejct.defineProperty\n\n\n`Obejct.defineProperty` 是整个`Vue`的灵魂， \n\n来看一下`Obejct.defineProperty` 如何使用\n```JavaScript\nvar obj = {}\nvar c;\nObject.defineProperty(obj, 'a', {\n  get() {\n    console.log('getter')\n    return a\n  },\n  set(newVal) {\n    console.log('setter')\n    c = newVal\n    this.a = newVal\n  }\n})\n\nobj.a = '234'\nconsole.log(c) // 234\nconsole.log(obj.a) // 234\n```\n\n\n它帮助`Vue`实现了双向绑定, 但也因为这个， `Vue`也只能舍弃了对低版本浏览器的支持。\n\n\n![defineProperty兼容](http://img.nixiaolei.com/2019-03-30-11-48-41.png)\n\n它只能兼容到`IE9` ， 并且市面上的`polyfill`实现的也并不是很好\n\n那低版本如何代替`Obejct.defineProperty` ， 难道真没了它就不行吗？\n\n\n**当然有**：\n\n1. 👆 > IE 7\n\n实际上在`IE7`的时候就已经有暴露了 `__defineGetter__` 方法，\n![__defineGetter__](http://img.nixiaolei.com/2019-03-30-12-57-56.png)\n\n具体用法如下\n```JavaScript\nvar random = {};\nrandom.__defineGetter__('ten', function() { \n    return Math.floor(Math.random()*10); });\nrandom.__defineGetter__('hundred', function() { \n    return Math.floor(Math.random()*100); });\n\nrandom.ten // 随机的一个值\n```\n\n2.  👇 < IE 7\n\n早年间的`IE` 是支持`VBScript`,  [VBScript](http://www.w3school.com.cn/vbscript/index.asp) 就可以直接写类， 并且也支持`get`，`set`方法\n\n```JavaScript\nclass Test {\n  get name () {\n    \n  }\n  set name() {\n\n  }\n}\n```\n\n### 🐶霸道的IE\n说了这么多`IE`的坏， 这里也带一嘴`IE`的好，\n\n`IE`能够调用`EXE`程序, 比如`JS`无法设置打印机的宽高，就可以利用`ActiveObjectX`来做到, 甚至可以修改`word`格式等等  , 所以办公类的项目离不开`IE`\n\n\n\n\n\n## 😕MVVM 双向数据绑定流程\n\n\nMVVM: Model–view–viewmodel\n\n那怎么区分这些层呢\n\n* 🚀**Model**: `Observer`\n* ✈️**view** : `directive`\n* 🚚**viewmodel**: `Watcher` && `Dep`  _【用于连接 Model 和 view】_\n\n\n![双向数据绑定](http://img.nixiaolei.com/2019-03-30-11-51-42.png)\n\n\n\n先看`Directive`, 这就是我们平时写的`vue`指令， 如上面举例得的`v-text=\"times\"`, 这就是一个指令， 一个`Directive`会分配一个`Watcher`\n\n\n\n### Observer\n\n观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。订阅者模式涉及三个对象：发布者、主题对象、订阅者，三个对象间的是一对多的关系，每当主题对象状态发生改变时，其相关依赖对象都会得到通知，并被自动更新。\n\n简单的描述就是:\n\n你想买漫画， 但是问了报刊亭的大爷， 大爷说现在没有， 还没到货， 然后你回去了， 第二天你又去问， 大爷还是说没有， 如果你每天这样问， 大爷估计会嫌你烦。 如果这时候你把你的电话给大爷， 大爷记录到他的**本子**上,  当大爷的漫画到货的时候电话通知你。\n\n这时你就是`订阅者`, 大爷就是`发布者`, 你们就存在一个发布订阅者的关系\n\n\n\n**Vue 中的Observer**\n\nObserver会观察两种类型的数据，`Object` 与 `Array`\n对于`Array`类型的数据，由于 `JavaScript` 的限制， `Vue` 不能检测变化,会先重写操作数组的原型方法，重写后能达到两个目的，\n\n当数组发生变化时，触发 `notify` 如果是 `push`，`unshift`，`splice` 这些添加新元素的操作，则会使用`observer`观察新添加的数据重写完原型方法后，遍历拿到数组中的每个数据 使用`observer`观察它而对于`Object`类型的数据，则遍历它的每个`key`，使用 `defineProperty` 设置 `getter` 和 `setter`，当触发`getter`的时候，`observer`则开始收集依赖，而触发`setter`的时候，`observer`则触发`notify`。\n\n\n#### 对 Object 的处理\n`Observer` 对象的标志就是`__ob__` 这个属性，这个属性保存了 `Observer` 对象自己本身。对象在转化为 `Observer` 对象的过程中是一个递归的过程，对象的子元素如果是对象或数组的话，也会转化为 `Observer` 对象\n\n\n#### 对数组的处理\n\n其实 `observeArray` 方法就是对数组进行遍历，递归调用 `observe` 方法，最终都会走入 `walk` 方监控单个元素。而 `walk` 方法就是遍历对象，结合 defineReactive 方法递归将属性转化为 `getter` 和 `setter`\n\n\n### Watcher\n`Watcher` 是将模板和 `Observer` 对象结合在一起的纽带。`Watcher` 是订阅者模式中的订阅者。`Watcher` 的两个参数： `expOrFn` 最终会被转换为 `getter` 函数， cb 是更新时执行的回调。依赖收集的入口就是get函数。\n\n> getter 函数是用来连接监控属性与 `Watcher` 的关键\n\n\n只有通过`watcher` 触发的getter 会收集依赖，而所谓的被收集的依赖就是当前`watcher`.初始化时传入的参数 expOrFn 中涉及到的每一项数据，然后触发该数据项的 getter 函数；getter 函数中就是通过判断 Dep.target的有无来判断是 `Watcher` 初始化时调用的还是普通数据读取，如果有则进行依赖收集\n\n\n### Dep\n\n这个方法是在响应式的过程中调用的，用户修改数据触发 setter 函数，函数的最后一行就是调用 dep.notify 去通知订阅者更新视图。\n\n### Directive\n\n![Directive](http://img.nixiaolei.com/2019-03-30-14-50-38.png)\n\n\n关于编译这块vue分了两种类型，一种是文本节点，一种是元素节点\n\n\nvue内置了这么多的指令，这些指令都会抛出两个接口bind 和 update，这两个接口的作用是，编译的最后一步是执行所有用到的指令的bind方法，而 update 方法则是当watcher 触发 update 时，Directive会触发指令的update方法\n\n\nobserve -> 触发setter -> watcher -> 触发update -> Directive -> 触发update -> 指令\n\n\n\n\n\n## 💥源码分析\nVue的完全版源码有很多判断以及其他的逻辑， 对于观看源码的人，会造成极大的困难，\n\n因此准备了这版仿照Vue流程实现的 实现了双向绑定的[简版Vue](https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue), 方便学习理解\n\n通过这版对[Vue源码的简易翻版](https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue)， 我们来快速理解Vue原理\n\n### ✨ new Vue\n\n首先看一下，我们的 new Vue, 这是所有操作的入口\n\n```JavaScript\nnew Vue({\n  data: {\n    nickname: '张三',\n    email: \"123123@qq.com\"\n  },\n  el: '#app'\n})\n```\n相信使用过`Vue `的小伙伴都明白， 这里定义了一个`data`， 用于存放变量， el是目标`dom`的选择器\n\n### 🔥 new Vue 执行时做了什么\n\n```JavaScript\nfunction Vue(option) {\n  var data = option.data \n  this.data = data\n  // 挂载 getter 和 setter\n  observe(data, this)\n  var id = option.el\n  // 编译 模板\n  var dom = new Compile(document.querySelector(id), this)\n  // 把编译好的模板挂载到 #app 上\n  document.querySelector(id).appendChild(dom)\n}\n```\n\n我们可以看到， Vue其实是一个构造函数， 它接收了一个参数`option`， 这个`option`就是我们`new Vue`传入的那个对象\n因此我们可以通过`option` 拿到`data`和`el`两个变量， 当然这是js基础哈， 我就不再说了\n\n拿到`data`后， 我们可以看到它调用了一个 `observe`方法, 将data和this传入( 此时this时Vue实例 )\n\n接下来又根据`el`来获取`dom`， 同样的将获取到的`dom`和`this`传入了 `Compile`中，  并且还接收了一个返回值， 然后又将这个返回值挂到了 `#app`上\n\n是不是感觉， 什么鬼？, 这顿操作是啥\n\n首先看一下疑惑的 `observe`， 传入了 `data`， `this`, 然后就没动静了， 既然如此， 我们就进入`observe`看看\n\n找到`Observe`的构造函数\n```JavaScript\nfunction observe(obj, vm) {\n  Object.keys(obj).forEach(key => {\n    defineReactive(vm, key, obj[key])\n  })\n}\n```\n可以看到，它接收一个`obj`和 `vm`， 哦， 这里就一一对应上了， 就是我们刚才传入的 `data`和`this` \n\n来看看它做了什么， \n\n它把`obj`枚举了一遍， 并将每一次的  `vm`, `key`,`value` 都传入一个叫 `defineReactive`的方法\n\n\n好，那就让来看`defineReactive`做了什么\n\n```JavaScript\nfunction defineReactive(vm, key, val) {\n  // 为每个变量分配一个 dep实例\n  var dep = new Dep()\n  // 配置getter和setter并且挂载到vm上\n  Object.defineProperty(vm, key, {\n    get() {\n      if ( Dep.target ) {\n        // JS的浏览器单线程特性， 保证整个全局变量在同一时间内， 只有一个监听器使用\n        dep.addSub(Dep.target)\n      }\n      return val\n    },\n    set(newVal) {\n      if ( newVal == val ) return;\n      val = newVal;\n      // 作为发布者发出通知\n      dep.notify()\n    }\n  })\n}\n```\n\n我们看到， 它`new`了一个`Dep`， 这个`Dep`就是报刊亭大爷的电话本， 用来收集所有想买报纸或杂志的人的电话， 等到到货时就好挨个通知\n\n然后我们看到了灵魂函数 `Object.defineProperty`,  \n\n嗷那我们应该就明白了， 这里的一顿操作就是为了给`data`里的每个属性都挂载上 `getter`，`setter`, 并且将这些属性直接转移到了`vm`上（Vue实例）\n\n那既然如此， \n\n🤪让我们看看 `getter`方法做了什么， \n\n首先它判断了一下`Dep.target`，  如果`Dep.target`为`true` , 就调用`dep`的`addSub`方法， 这里`Dep.target`是啥我们先不管， 留个印象即可\n\n然后它直接`return`了`val`\n\n😵再来看看`setter`方法\n\n`setter`方法接收一个新值，  首先就是判断了新值和原本的值是否相等， 如果相等就不做处理了， 如果不相等， 它将新值赋给`val`\n\n然后调用`dep`实例上的`notify`方法， `notify` 看着名字也知道是通知， 也就是大爷挨个打电话的一个操作\n\n\n好, 这一块我们理顺了， 是为了挂上`getter`和`setter`， 但又遇到了新问题`dep`， `dep`到底在干什么， 为什么被`getter`，`setter`都使用了 \n\n\n找到`Dep`的构造函数\n```JavaScript\nfunction Dep() {\n  // 存放watcher\n  this.subs = []\n}\n\nDep.prototype = {\n  // 添加watcher, 也就是添加订阅\n  addSub(sub) {\n    this.subs.push(sub)\n  },\n  // 通知所有watcher\n  notify() {\n    this.subs.forEach(sub => {\n      sub.update()\n    })\n  }\n}\n```\n\n我们可以看到， `Dep`构造函数中维护了一个 `subs`数组， 并且下面的在`prototype`上定义了几个方法， `addSub` 和`notify`，\n这不就是刚刚`observe`里调用的两个方法吗， \n哦，明白了， `addSub`原来是将`getter`中传入的 `Dep.target`追加到每个`Dep`实例都单独维护的一个`subs`数组中呀， `notify`就是遍历整个数组，挨个调用`update`方法（先不管update的具体实现）\n\n\n好， 解决了`observe`方法，那我们就回到最初的`Vue`构造函数中,  继续往下走, 攻克剩余的绿色区域\n\n![Compile](http://img.nixiaolei.com/2019-03-31-11-36-41.png)\n\n\n我们可以看到，它通过`el` 获取到了`dom`, 并在`new Compile` 将`dom` 传入\n\n那我们就找到`Compile`的构造函数一探究竟\n```JavaScript\nfunction Compile(node, vm) {\n  if(node) {\n    this.$frag = this.nodeToFragment(node, vm)\n    return this.$frag\n  }\n}\n```\n\n可以看到， 它接收了一个`node`， 和一个`vm` , 并且判断了一下`node`是否存在， \n\n并将`node`和`vm`，传入了`this.nodeToFragment`方法， 又将其的返回结果`return`出去， 也就是`new Compile`之后返回的值 ，如下\n\n![Compile02](http://img.nixiaolei.com/2019-03-31-11-49-23.png)\n\n\n那`this.nodeToFragment`这个方法做了什么， 让我们找到他\n```JavaScript\nCompile.prototype = {\n  nodeToFragment(node, vm) {\n    var _this = this\n    // 创建文档片段\n    var frag = document.createDocumentFragment()\n    var child;\n    while ( child = node.firstChild ) {\n      // 替换变量\n      _this.compileElement(child, vm)\n      // 剪贴子元素\n      frag.append(child)\n    }\n    return frag\n  },\n  compileElement(node, vm) {\n    var reg = /\\{\\{(.*)\\}\\}/;\n    // 节点类型为元素, 根据nodeType来判断\n    if ( node.nodeType === 1 ) {\n      // 获取自定义属性\n      var attr = node.attributes\n      for (var i = 0; i < attr.length; i++) {\n        if (attr[i].nodeName == \"v-model\") {\n          // 获取v-model 绑定的属性名\n          var name = attr[i].nodeValue\n          // 双向绑定\n          node.addEventListener('input', function(e) {\n            // 给相应的data属性赋值， 进而触发该属性的set方法\n            // 再批处理渲染元素\n            vm[name] = e.target.value \n          })\n          // 把this ，节点， 还有v-model绑定的变量交给watcher\n          new Watcher(vm, node, name, \"value\")\n        }\n      }\n    }\n\n    // 节点类型为text\n    if ( node.nodeType === 3 ) {\n      if ( reg.test(node.nodeValue) ) {\n        var name = RegExp.$1; // 获取匹配到的字符串\n        name = name.trim()\n         // 把this ，节点， 还有{{ xxx }}中使用的变量交给watcher\n        new Watcher(vm, node, name, 'nodeValue')\n      }\n    }\n  }\n}\n```\n\n我们看到它在`Compile`原型上挂了`nodeToFragment`, `compileElement`两个方法，  `nodeToFragment`方法接收 `node`, `vm`参数\n\n先保存了一下`this`指向,  然后使用`document.createDocumentFragment()`方法创建了一个文档片段， 并将在`while`循环中传入的`node`节点的第一个元素赋值给 `child`变量，\n然后使用`compileElement(child, vm)` 将`child`和`vm` 传入, 然后将`child` 追加给创建好的文档片段`frag`, 你肯定会觉得这是个死循环, 其实不是的， 这个`append`对`dom`有剪切的效果，\n所以他会一直抽离`node`的第一个节点，直至`node`空了， 吸干他\n\n完成了这顿操作后， 再将`frag`文档片段返回\n\n然后我们来看看它在`while`中调用的`compileElement`方法做了什么\n\n它同样接收`node`和`vm` , 首先就是定义一个正则， 这是用来匹配`{{ xxx }}`双括号的， 也就是我们平时的变量写法\n\n然后它判断了一下这个 `node`的节点类型,  如果`nodeType == 1`, 那就说明是元素，  如果`nodeType == 3` 那就说明节点类型是`text`\n      \n如果节点类型是元素， 就利用`attributes` 方法，获取到该元素身上的属性,  查看是否存在`v-model`这样一个属性， 如果有，就获取到`v-model`填写的变量，交给变量`name`,\n然后监听该元素的`input`事件， \n\n所以每当改元素发生`input`时间时，就将元素上的`value`根据`v-model`上获取到的`name`作为`vm`的`key`去修改`vm`实例上的对应的值， 因为`vm`上的变量已经被挂载此来触发`vm`\n\n最后还创建了一个`Watcher`实例,  传入`vm, node ,name, \"value\"`这几个参数，\n\n`Watcher`的具体实现我们待会去看\n\n接下来就是判断`node.nodeType == 3`， 也就是text类型的节点， 如果是此类节点， 就先用正则去匹配一下`{{ xxx }}`语法， 看看有没有使用到某个变量， \n如果匹配到了， 则通过`RegExp.$1`获取到被匹配到的值， 然后去除左右的空格， 交给变量`name`\n最后，同样的创建了一个`Watcher`实例,  传入`vm, node ,name, \"value\"`这几个参数，\n\n出现两次`Watcher`， 什么情况， 到底干了啥\n那， 现在就来让我们看看神秘的`Watcher`构造函数\n\n找到`Watcher`的构造函数\n```JavaScript\nlet uid = 0;\n\nfunction Watcher(vm, node, name, type) {\n  // 单例， 使用原因未知\n  Dep.target = this\n  // 姓名\n  this.name = name;\n  // 呵呵哒 uid\n  this.id = ++uid;\n  // 与变量相关的Node节点\n  this.node = node;\n  // vm 实例\n  this.vm = vm;\n  // 变量类型  nodeValue  || value\n  this.type = type;\n  // 触发自己原型上的update方法\n  this.update()\n  // Watcher 实例创建结束就把单例置空\n  Dep.target = null\n}\n```\n\n此时我们发现了一个关键的东西`Dep.target` ， 这个鬼东西原来在这里， 它被赋值为了`Watcher`的实例， 然后在`Watcher`实例上挂载了`name`，也就是用到的变量， 还使用了一个`uid`， 不过这`uid`也是呵呵了，用数字作为`uid`, `Vue`的真实源码就这么干的， 为每个`Watcher`都配分一个`uid`， 这会造成数组空间的不连续， 引发内存泄漏\n\n接着说， 然后他将传入的`node`节点， `vm`实例， 还有`type`( 'nodeValue' 和 'value' ), 都挂到了实例上面， 并且还在调用了`update`方法后， 将`Dep.target`设为`null`\n\n那我们来看下`update`做了啥\n\n```JavaScript\nWatcher.prototype = {\n  update() {\n    this.get()\n    if(!batcher) {\n      // bastcher 单例\n      batcher = new Batcher()\n    }\n    // 加入队列\n    batcher.push(this)\n  },\n  // 获取新值挂到自己的实例上\n  get() {\n    this.value = this.vm[this.name]  // 触发getter\n  }\n}\n```\n\n看到`update`方法， 首先调用了一下`get`方法， 这个`get`呢就是根据`this.name`从 `vm`实例上取一次值， 并挂到`Watcher`实例上的`value`属性上, 并且他还会触发一次`getter`方法，将自己加入到`dep`中， 也就是加入到报刊亭大爷的电话本中， 便于之后的通知\n\n然后判断了一下`window.batcher`是否存在， 如果不存在就创建一个， 保证其是一个单例模式,\n如果存在， 就将自己(`watcher`实例)，通过`push`方法传入\n\n看到这里，又晕了， 什么时候又冒出来一个`Batcher`\n\n我们又找到`Batcher`的构造函数好好分析下，\n```JavaScript\n// 批处理构造函数\nfunction Batcher() {\n  //  重置  has  queue waiting\n  this.reset()\n}\n\nBatcher.prototype.reset = function () {\n  this.has = {}\n  this.queue = []\n  this.waiting = false\n} \n\n// 将watcher 添加到队列中\nBatcher.prototype.push = function (job) {\n  let id = job.id\n  // 先根据 对象的key 看看是否已经有了这个watcher\n  if (!this.has[id]) {\n    // console.log(batcher)\n    this.queue.push(job)\n    // 将watcher 的key的设为true\n    this.has[id] = true\n\n    // 延迟执行\n    if (!this.waiting ) {\n      this.waiting = true\n      if ( \"Promise\" in window ) {\n        Promise.resolve().then(() => {\n          this.flush()\n        })\n      } else {\n        setTimeout(() => {\n          this.flush()\n        }, 0)\n      }\n    }\n  }\n}\n\n\n// 执行并情况事件队列\nBatcher.prototype.flush = function() {\n  this.queue.forEach(job => {\n    job.cb()\n  })\n  this.reset()\n}\n\n\n```\n\n`Batcher`的构造函数很简单， 就调用了一下自己的`reset`方法， 但好像事情远没有这么简单，我们不是在 `Watcher`的`update`方法中调用了`batcher.push`吗， 我也可以在这原型上找的这个方法， 首先它接收一个`job`参数， 也就是`Watcher`实例， \n\n获取到该`watcher`的`id`, 然后使用这个`id`,去`has`这个对象上访问一下， 看看是否存在，\n如果不存在，在证明之前没有添加进来过， 然后将该`watcher`实例加到`queue`队列中， \n并将`has`对象中`id`对应的值设为`true`, 以防止重复加入队列\n\n并且判断一下`waiting`，得知当前是否处于等待状态， 如果不是， 就将`waiting`改为`true`, 然后就是判断当前浏览器的支持情况， 将处理的任务扔到异步队列中\n\n它这里这么做是为了，只批处理一次， 你一瞬间加入多个`watcher`, 很容易造成重复执行， 利用`Watcher`的`id`来过滤， 并且利用异步， 等你要加的`watcher`都加完了， 我再给你统一的去执行所有`Watcher`\n\n也就是异步任务结束后调用的`flush`方法， 它在内部会遍历`queue`队列， 挨个的调用`Watcher`的`cb`方法\n在这一切都执行完成之后， 又调用了一次`reset`方法， 将`bascher`的三个属性重置为初始状态\n\n此时关注点又回到了`Watcher`身上， 它的`cb`方法又做了什么\n```JavaScript\nWatcher.prototype = {\n  // ...省略其他方法\n\n  // 给dom赋值\n  cb() {\n    // 最终实际虚拟dom 处理结果， 只处理一次\n    // 虚拟dom -> diff( 虚拟dom ) -> 局部更新 -> createElement(vNode) -> render\n    this.node[this.type] = this.value\n  },\n}\n```\n\n可以看到`cb`方法做的事情很简单那， 就是**根据元素的值类型去修改元素对象的值**， 而这个`this.value`早在之前调用 `Watcher`的`get`方法时就被赋上了\n\n到这里，整个流程就走完了， 相信你还是一头雾水， 我们把整个流程来串一下\n\n1. new Vue\n2. 将`data`中的值挂上 `getter`和`setter` 的相应方法， 然后暂且搁置，因为此时还无人调用`getter`和`setter`\n3. 通过 `Compile`解析模板， 挨个递归`#app`下的`dom`, 判断元素类型， 如果是元素，并且使用了`v-model`， 就绑定一个`input`事件,  如果是文本类型节点,就去匹配是使用了`{{ xx }}`语法， 最后为他们都创建了一个`watcher`\n4. 每个`watcher` 用来保存相关的元素对象， `vm`实例，使用的`变量` 以及元素值类型, 并将自己的实例交给， `Dep.target`， 并触发自己的`update`方法，`update`方法又会调用`get`方法， `get`方法又会触发该变量的`getter`， 这也就使得`getter`中可以将该`watcher`放入`dep`实例中， 最后将自己也放入`Bacher`中，用以批处理以及将`Dep.target`置空\n5. `Batcher`是个单例， 根据`Watcher`的`id`, 它用来过滤重复传入的`Watcher`, 保证一个`Watcher`只触发一次, 并将更新事件丢入异步，等当前的连续操作执行完成后去调用`Watcher`的`cb`方法更新`dom`\n6. 之后用户修改了变量, `setter`又会调用`dep`这个发布者来发出通知， 相关的`Watcher`的`update`方法再次被调用， 又会加入`batcher` , `batcher`等待异步完成后又调用`Watcher`的`cb`方法更新`dom`\n\n\n**到这里就整个串完了，但是感觉废话还是有点多， 再简化一点流程**:\n\nnew Vue --> `Observe` 挂载 `setter` 和 `getter` -->  `Compile` 编译模板 --> 为每个指令分配一个`watcher` --> 创建时会调用一次`watcher.update` 将自己加入到`batcher`的队列 -->\n并且此时会触发 `getter` 将`watcher`加入`dep` -->  `batcher` 统一来处理`watcher`后初始化自己 -->  当用户修改某个变量时 --> `dep`通知`watcher` --> `watcher`又被加入`batcher`处理 --> `watcher` 更新`dom`\n\n\n`Vue`的`batcher`还是实现的不是很好， 缺少调度机制， 这点上还是`React Fiber`更优秀点，`Fiber`如果遇上了长时间的任务会选择放弃， 避免阻塞进程。\n\n\n😕好了， 神秘的`Vue`源码已被揭开面纱， 但这仅仅是简易版的实现， 真实的`Vue`非常庞大， 还有更多的内容， 这里只是让大家明白`MVVM`的核心原理\n\n\n项目源码:\n> https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue\n\n优质文献: \n* [汤姆大叔的观察者模式](http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html)","source":"_posts/【Vue】源码解析.md","raw":"---\ntitle: 【Vue】源码解析\ndate: 2019-03-18 09:50:34\ncategories: Vue\ntags: Vue\n---\n\n现在三大框架风起云涌， `JQuery`老大哥的光辉不再， 使前端成为了各路诸侯的兵家必争之地， \n\n当然作为一名优质的前端，光跟风学框架是肯定不行的， 要知其然而知其所以然\n\n要了解`MVVM`的本质原理， `virtual Dom`和 `Diff`算法解决的问题\n\n拒绝盲目跟风\n\n\n## 🍎diffDom优劣\n现在很多人都说 `Vue`, `React` 多牛， `Diff`算法快，不用操作`Dom`。\n\n只能无语。\n\n`Diff`算法不是不需要操作`Dom`,  而是不需要开发者去操作`Dom`了， `Diff`算法其实不快， 就算使用了`virtual Dom`,  还得花实现把真实`Dom` 转换为 `virtual Dom` 再去比对， 这远远没有`js`直接 `getElementById`直达目标来的快\n\n那Diff算法不快为什么还要用呢?\n\n`Diff`算法其实是给那些比较随意的新手开发者准备的\n\n看这个例子\n\n```HTML\n<!-- 原本的dom -->\n<ul id=\"ul\">\n  <li>a</li>\n  <li>a</li>\n  <li>a</li>\n</ul>\n```\n```JavaScript\n// 拿到结果不管三七二十一把旧dom全替换了\n$.get('/api', (res) => {\n  var _HTML = \"\"\n  for(var i=0; i< res.length; i++){\n    _HTML = \"<li>\" + res[i] +\"</li>\"\n  }\n  $(\"#ul\").html(_HTML)\n})\n```\n\n如果是原始的`Dom`操作， 有很多小白会像这个例子一样， 不管`Dom`需不需要更新， 他都把`ajax`返回的请求全部跑一边，生成`HTML`模板， 然后把原本的所有`li`都删了，  再把新的模板放进去， `Dom`少还看不出来， 如果`Dom`多了呢， 上千的`Dom`， 这顿操作一下就玩炸了。\n\n况且网站优化原则就是尽量减小`Dom`操作， 如果是有经验的开发者， 会选择找到有变化的位置，使用`append`插入\n\n\n\n## 📄Vue架构目录\n去[Vue官网](https://github.com/vuejs/vue)下载`Vue`源码看看，\n\n打开里面会有一个 `src`目录， 里面就是整个的`Vue`源码\n\n目前有6个目录， 作用分别如下\n\n![Vue目录](http://img.nixiaolei.com/2019-03-30-10-44-35.png)\n\n\n`Vue.js` 的组成是由 `core` + 对应的 '平台' 补充代码构成（独立构建和运行时构建只是 `platforms` 下 `web` 平台的两种选择）\n\n`Vue`的核心原理就在`core`文件夹中， 让我们进入 `core` 文件夹看看\n\n![core文件夹](http://img.nixiaolei.com/2019-03-30-10-57-26.png)\n\n了解了目录，接下来我们就来研究`Vue`的双向绑定\n\n## 🔗双向绑定（响应式原理） 所涉及到的技术\n* ✅ **Obejct.defineProperty** _【提供getter 和 setter】_\n* ✅ **Observer** _【提供getter 和 setter】_\n* ✅ **watcher**  _【提供getter 和 setter】_\n* ✅ **Dep** _【负责收集watcher】_\n* ✅ **Directive** _【处理Vue模板指令】_\n\n\n### Obejct.defineProperty\n\n\n`Obejct.defineProperty` 是整个`Vue`的灵魂， \n\n来看一下`Obejct.defineProperty` 如何使用\n```JavaScript\nvar obj = {}\nvar c;\nObject.defineProperty(obj, 'a', {\n  get() {\n    console.log('getter')\n    return a\n  },\n  set(newVal) {\n    console.log('setter')\n    c = newVal\n    this.a = newVal\n  }\n})\n\nobj.a = '234'\nconsole.log(c) // 234\nconsole.log(obj.a) // 234\n```\n\n\n它帮助`Vue`实现了双向绑定, 但也因为这个， `Vue`也只能舍弃了对低版本浏览器的支持。\n\n\n![defineProperty兼容](http://img.nixiaolei.com/2019-03-30-11-48-41.png)\n\n它只能兼容到`IE9` ， 并且市面上的`polyfill`实现的也并不是很好\n\n那低版本如何代替`Obejct.defineProperty` ， 难道真没了它就不行吗？\n\n\n**当然有**：\n\n1. 👆 > IE 7\n\n实际上在`IE7`的时候就已经有暴露了 `__defineGetter__` 方法，\n![__defineGetter__](http://img.nixiaolei.com/2019-03-30-12-57-56.png)\n\n具体用法如下\n```JavaScript\nvar random = {};\nrandom.__defineGetter__('ten', function() { \n    return Math.floor(Math.random()*10); });\nrandom.__defineGetter__('hundred', function() { \n    return Math.floor(Math.random()*100); });\n\nrandom.ten // 随机的一个值\n```\n\n2.  👇 < IE 7\n\n早年间的`IE` 是支持`VBScript`,  [VBScript](http://www.w3school.com.cn/vbscript/index.asp) 就可以直接写类， 并且也支持`get`，`set`方法\n\n```JavaScript\nclass Test {\n  get name () {\n    \n  }\n  set name() {\n\n  }\n}\n```\n\n### 🐶霸道的IE\n说了这么多`IE`的坏， 这里也带一嘴`IE`的好，\n\n`IE`能够调用`EXE`程序, 比如`JS`无法设置打印机的宽高，就可以利用`ActiveObjectX`来做到, 甚至可以修改`word`格式等等  , 所以办公类的项目离不开`IE`\n\n\n\n\n\n## 😕MVVM 双向数据绑定流程\n\n\nMVVM: Model–view–viewmodel\n\n那怎么区分这些层呢\n\n* 🚀**Model**: `Observer`\n* ✈️**view** : `directive`\n* 🚚**viewmodel**: `Watcher` && `Dep`  _【用于连接 Model 和 view】_\n\n\n![双向数据绑定](http://img.nixiaolei.com/2019-03-30-11-51-42.png)\n\n\n\n先看`Directive`, 这就是我们平时写的`vue`指令， 如上面举例得的`v-text=\"times\"`, 这就是一个指令， 一个`Directive`会分配一个`Watcher`\n\n\n\n### Observer\n\n观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。订阅者模式涉及三个对象：发布者、主题对象、订阅者，三个对象间的是一对多的关系，每当主题对象状态发生改变时，其相关依赖对象都会得到通知，并被自动更新。\n\n简单的描述就是:\n\n你想买漫画， 但是问了报刊亭的大爷， 大爷说现在没有， 还没到货， 然后你回去了， 第二天你又去问， 大爷还是说没有， 如果你每天这样问， 大爷估计会嫌你烦。 如果这时候你把你的电话给大爷， 大爷记录到他的**本子**上,  当大爷的漫画到货的时候电话通知你。\n\n这时你就是`订阅者`, 大爷就是`发布者`, 你们就存在一个发布订阅者的关系\n\n\n\n**Vue 中的Observer**\n\nObserver会观察两种类型的数据，`Object` 与 `Array`\n对于`Array`类型的数据，由于 `JavaScript` 的限制， `Vue` 不能检测变化,会先重写操作数组的原型方法，重写后能达到两个目的，\n\n当数组发生变化时，触发 `notify` 如果是 `push`，`unshift`，`splice` 这些添加新元素的操作，则会使用`observer`观察新添加的数据重写完原型方法后，遍历拿到数组中的每个数据 使用`observer`观察它而对于`Object`类型的数据，则遍历它的每个`key`，使用 `defineProperty` 设置 `getter` 和 `setter`，当触发`getter`的时候，`observer`则开始收集依赖，而触发`setter`的时候，`observer`则触发`notify`。\n\n\n#### 对 Object 的处理\n`Observer` 对象的标志就是`__ob__` 这个属性，这个属性保存了 `Observer` 对象自己本身。对象在转化为 `Observer` 对象的过程中是一个递归的过程，对象的子元素如果是对象或数组的话，也会转化为 `Observer` 对象\n\n\n#### 对数组的处理\n\n其实 `observeArray` 方法就是对数组进行遍历，递归调用 `observe` 方法，最终都会走入 `walk` 方监控单个元素。而 `walk` 方法就是遍历对象，结合 defineReactive 方法递归将属性转化为 `getter` 和 `setter`\n\n\n### Watcher\n`Watcher` 是将模板和 `Observer` 对象结合在一起的纽带。`Watcher` 是订阅者模式中的订阅者。`Watcher` 的两个参数： `expOrFn` 最终会被转换为 `getter` 函数， cb 是更新时执行的回调。依赖收集的入口就是get函数。\n\n> getter 函数是用来连接监控属性与 `Watcher` 的关键\n\n\n只有通过`watcher` 触发的getter 会收集依赖，而所谓的被收集的依赖就是当前`watcher`.初始化时传入的参数 expOrFn 中涉及到的每一项数据，然后触发该数据项的 getter 函数；getter 函数中就是通过判断 Dep.target的有无来判断是 `Watcher` 初始化时调用的还是普通数据读取，如果有则进行依赖收集\n\n\n### Dep\n\n这个方法是在响应式的过程中调用的，用户修改数据触发 setter 函数，函数的最后一行就是调用 dep.notify 去通知订阅者更新视图。\n\n### Directive\n\n![Directive](http://img.nixiaolei.com/2019-03-30-14-50-38.png)\n\n\n关于编译这块vue分了两种类型，一种是文本节点，一种是元素节点\n\n\nvue内置了这么多的指令，这些指令都会抛出两个接口bind 和 update，这两个接口的作用是，编译的最后一步是执行所有用到的指令的bind方法，而 update 方法则是当watcher 触发 update 时，Directive会触发指令的update方法\n\n\nobserve -> 触发setter -> watcher -> 触发update -> Directive -> 触发update -> 指令\n\n\n\n\n\n## 💥源码分析\nVue的完全版源码有很多判断以及其他的逻辑， 对于观看源码的人，会造成极大的困难，\n\n因此准备了这版仿照Vue流程实现的 实现了双向绑定的[简版Vue](https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue), 方便学习理解\n\n通过这版对[Vue源码的简易翻版](https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue)， 我们来快速理解Vue原理\n\n### ✨ new Vue\n\n首先看一下，我们的 new Vue, 这是所有操作的入口\n\n```JavaScript\nnew Vue({\n  data: {\n    nickname: '张三',\n    email: \"123123@qq.com\"\n  },\n  el: '#app'\n})\n```\n相信使用过`Vue `的小伙伴都明白， 这里定义了一个`data`， 用于存放变量， el是目标`dom`的选择器\n\n### 🔥 new Vue 执行时做了什么\n\n```JavaScript\nfunction Vue(option) {\n  var data = option.data \n  this.data = data\n  // 挂载 getter 和 setter\n  observe(data, this)\n  var id = option.el\n  // 编译 模板\n  var dom = new Compile(document.querySelector(id), this)\n  // 把编译好的模板挂载到 #app 上\n  document.querySelector(id).appendChild(dom)\n}\n```\n\n我们可以看到， Vue其实是一个构造函数， 它接收了一个参数`option`， 这个`option`就是我们`new Vue`传入的那个对象\n因此我们可以通过`option` 拿到`data`和`el`两个变量， 当然这是js基础哈， 我就不再说了\n\n拿到`data`后， 我们可以看到它调用了一个 `observe`方法, 将data和this传入( 此时this时Vue实例 )\n\n接下来又根据`el`来获取`dom`， 同样的将获取到的`dom`和`this`传入了 `Compile`中，  并且还接收了一个返回值， 然后又将这个返回值挂到了 `#app`上\n\n是不是感觉， 什么鬼？, 这顿操作是啥\n\n首先看一下疑惑的 `observe`， 传入了 `data`， `this`, 然后就没动静了， 既然如此， 我们就进入`observe`看看\n\n找到`Observe`的构造函数\n```JavaScript\nfunction observe(obj, vm) {\n  Object.keys(obj).forEach(key => {\n    defineReactive(vm, key, obj[key])\n  })\n}\n```\n可以看到，它接收一个`obj`和 `vm`， 哦， 这里就一一对应上了， 就是我们刚才传入的 `data`和`this` \n\n来看看它做了什么， \n\n它把`obj`枚举了一遍， 并将每一次的  `vm`, `key`,`value` 都传入一个叫 `defineReactive`的方法\n\n\n好，那就让来看`defineReactive`做了什么\n\n```JavaScript\nfunction defineReactive(vm, key, val) {\n  // 为每个变量分配一个 dep实例\n  var dep = new Dep()\n  // 配置getter和setter并且挂载到vm上\n  Object.defineProperty(vm, key, {\n    get() {\n      if ( Dep.target ) {\n        // JS的浏览器单线程特性， 保证整个全局变量在同一时间内， 只有一个监听器使用\n        dep.addSub(Dep.target)\n      }\n      return val\n    },\n    set(newVal) {\n      if ( newVal == val ) return;\n      val = newVal;\n      // 作为发布者发出通知\n      dep.notify()\n    }\n  })\n}\n```\n\n我们看到， 它`new`了一个`Dep`， 这个`Dep`就是报刊亭大爷的电话本， 用来收集所有想买报纸或杂志的人的电话， 等到到货时就好挨个通知\n\n然后我们看到了灵魂函数 `Object.defineProperty`,  \n\n嗷那我们应该就明白了， 这里的一顿操作就是为了给`data`里的每个属性都挂载上 `getter`，`setter`, 并且将这些属性直接转移到了`vm`上（Vue实例）\n\n那既然如此， \n\n🤪让我们看看 `getter`方法做了什么， \n\n首先它判断了一下`Dep.target`，  如果`Dep.target`为`true` , 就调用`dep`的`addSub`方法， 这里`Dep.target`是啥我们先不管， 留个印象即可\n\n然后它直接`return`了`val`\n\n😵再来看看`setter`方法\n\n`setter`方法接收一个新值，  首先就是判断了新值和原本的值是否相等， 如果相等就不做处理了， 如果不相等， 它将新值赋给`val`\n\n然后调用`dep`实例上的`notify`方法， `notify` 看着名字也知道是通知， 也就是大爷挨个打电话的一个操作\n\n\n好, 这一块我们理顺了， 是为了挂上`getter`和`setter`， 但又遇到了新问题`dep`， `dep`到底在干什么， 为什么被`getter`，`setter`都使用了 \n\n\n找到`Dep`的构造函数\n```JavaScript\nfunction Dep() {\n  // 存放watcher\n  this.subs = []\n}\n\nDep.prototype = {\n  // 添加watcher, 也就是添加订阅\n  addSub(sub) {\n    this.subs.push(sub)\n  },\n  // 通知所有watcher\n  notify() {\n    this.subs.forEach(sub => {\n      sub.update()\n    })\n  }\n}\n```\n\n我们可以看到， `Dep`构造函数中维护了一个 `subs`数组， 并且下面的在`prototype`上定义了几个方法， `addSub` 和`notify`，\n这不就是刚刚`observe`里调用的两个方法吗， \n哦，明白了， `addSub`原来是将`getter`中传入的 `Dep.target`追加到每个`Dep`实例都单独维护的一个`subs`数组中呀， `notify`就是遍历整个数组，挨个调用`update`方法（先不管update的具体实现）\n\n\n好， 解决了`observe`方法，那我们就回到最初的`Vue`构造函数中,  继续往下走, 攻克剩余的绿色区域\n\n![Compile](http://img.nixiaolei.com/2019-03-31-11-36-41.png)\n\n\n我们可以看到，它通过`el` 获取到了`dom`, 并在`new Compile` 将`dom` 传入\n\n那我们就找到`Compile`的构造函数一探究竟\n```JavaScript\nfunction Compile(node, vm) {\n  if(node) {\n    this.$frag = this.nodeToFragment(node, vm)\n    return this.$frag\n  }\n}\n```\n\n可以看到， 它接收了一个`node`， 和一个`vm` , 并且判断了一下`node`是否存在， \n\n并将`node`和`vm`，传入了`this.nodeToFragment`方法， 又将其的返回结果`return`出去， 也就是`new Compile`之后返回的值 ，如下\n\n![Compile02](http://img.nixiaolei.com/2019-03-31-11-49-23.png)\n\n\n那`this.nodeToFragment`这个方法做了什么， 让我们找到他\n```JavaScript\nCompile.prototype = {\n  nodeToFragment(node, vm) {\n    var _this = this\n    // 创建文档片段\n    var frag = document.createDocumentFragment()\n    var child;\n    while ( child = node.firstChild ) {\n      // 替换变量\n      _this.compileElement(child, vm)\n      // 剪贴子元素\n      frag.append(child)\n    }\n    return frag\n  },\n  compileElement(node, vm) {\n    var reg = /\\{\\{(.*)\\}\\}/;\n    // 节点类型为元素, 根据nodeType来判断\n    if ( node.nodeType === 1 ) {\n      // 获取自定义属性\n      var attr = node.attributes\n      for (var i = 0; i < attr.length; i++) {\n        if (attr[i].nodeName == \"v-model\") {\n          // 获取v-model 绑定的属性名\n          var name = attr[i].nodeValue\n          // 双向绑定\n          node.addEventListener('input', function(e) {\n            // 给相应的data属性赋值， 进而触发该属性的set方法\n            // 再批处理渲染元素\n            vm[name] = e.target.value \n          })\n          // 把this ，节点， 还有v-model绑定的变量交给watcher\n          new Watcher(vm, node, name, \"value\")\n        }\n      }\n    }\n\n    // 节点类型为text\n    if ( node.nodeType === 3 ) {\n      if ( reg.test(node.nodeValue) ) {\n        var name = RegExp.$1; // 获取匹配到的字符串\n        name = name.trim()\n         // 把this ，节点， 还有{{ xxx }}中使用的变量交给watcher\n        new Watcher(vm, node, name, 'nodeValue')\n      }\n    }\n  }\n}\n```\n\n我们看到它在`Compile`原型上挂了`nodeToFragment`, `compileElement`两个方法，  `nodeToFragment`方法接收 `node`, `vm`参数\n\n先保存了一下`this`指向,  然后使用`document.createDocumentFragment()`方法创建了一个文档片段， 并将在`while`循环中传入的`node`节点的第一个元素赋值给 `child`变量，\n然后使用`compileElement(child, vm)` 将`child`和`vm` 传入, 然后将`child` 追加给创建好的文档片段`frag`, 你肯定会觉得这是个死循环, 其实不是的， 这个`append`对`dom`有剪切的效果，\n所以他会一直抽离`node`的第一个节点，直至`node`空了， 吸干他\n\n完成了这顿操作后， 再将`frag`文档片段返回\n\n然后我们来看看它在`while`中调用的`compileElement`方法做了什么\n\n它同样接收`node`和`vm` , 首先就是定义一个正则， 这是用来匹配`{{ xxx }}`双括号的， 也就是我们平时的变量写法\n\n然后它判断了一下这个 `node`的节点类型,  如果`nodeType == 1`, 那就说明是元素，  如果`nodeType == 3` 那就说明节点类型是`text`\n      \n如果节点类型是元素， 就利用`attributes` 方法，获取到该元素身上的属性,  查看是否存在`v-model`这样一个属性， 如果有，就获取到`v-model`填写的变量，交给变量`name`,\n然后监听该元素的`input`事件， \n\n所以每当改元素发生`input`时间时，就将元素上的`value`根据`v-model`上获取到的`name`作为`vm`的`key`去修改`vm`实例上的对应的值， 因为`vm`上的变量已经被挂载此来触发`vm`\n\n最后还创建了一个`Watcher`实例,  传入`vm, node ,name, \"value\"`这几个参数，\n\n`Watcher`的具体实现我们待会去看\n\n接下来就是判断`node.nodeType == 3`， 也就是text类型的节点， 如果是此类节点， 就先用正则去匹配一下`{{ xxx }}`语法， 看看有没有使用到某个变量， \n如果匹配到了， 则通过`RegExp.$1`获取到被匹配到的值， 然后去除左右的空格， 交给变量`name`\n最后，同样的创建了一个`Watcher`实例,  传入`vm, node ,name, \"value\"`这几个参数，\n\n出现两次`Watcher`， 什么情况， 到底干了啥\n那， 现在就来让我们看看神秘的`Watcher`构造函数\n\n找到`Watcher`的构造函数\n```JavaScript\nlet uid = 0;\n\nfunction Watcher(vm, node, name, type) {\n  // 单例， 使用原因未知\n  Dep.target = this\n  // 姓名\n  this.name = name;\n  // 呵呵哒 uid\n  this.id = ++uid;\n  // 与变量相关的Node节点\n  this.node = node;\n  // vm 实例\n  this.vm = vm;\n  // 变量类型  nodeValue  || value\n  this.type = type;\n  // 触发自己原型上的update方法\n  this.update()\n  // Watcher 实例创建结束就把单例置空\n  Dep.target = null\n}\n```\n\n此时我们发现了一个关键的东西`Dep.target` ， 这个鬼东西原来在这里， 它被赋值为了`Watcher`的实例， 然后在`Watcher`实例上挂载了`name`，也就是用到的变量， 还使用了一个`uid`， 不过这`uid`也是呵呵了，用数字作为`uid`, `Vue`的真实源码就这么干的， 为每个`Watcher`都配分一个`uid`， 这会造成数组空间的不连续， 引发内存泄漏\n\n接着说， 然后他将传入的`node`节点， `vm`实例， 还有`type`( 'nodeValue' 和 'value' ), 都挂到了实例上面， 并且还在调用了`update`方法后， 将`Dep.target`设为`null`\n\n那我们来看下`update`做了啥\n\n```JavaScript\nWatcher.prototype = {\n  update() {\n    this.get()\n    if(!batcher) {\n      // bastcher 单例\n      batcher = new Batcher()\n    }\n    // 加入队列\n    batcher.push(this)\n  },\n  // 获取新值挂到自己的实例上\n  get() {\n    this.value = this.vm[this.name]  // 触发getter\n  }\n}\n```\n\n看到`update`方法， 首先调用了一下`get`方法， 这个`get`呢就是根据`this.name`从 `vm`实例上取一次值， 并挂到`Watcher`实例上的`value`属性上, 并且他还会触发一次`getter`方法，将自己加入到`dep`中， 也就是加入到报刊亭大爷的电话本中， 便于之后的通知\n\n然后判断了一下`window.batcher`是否存在， 如果不存在就创建一个， 保证其是一个单例模式,\n如果存在， 就将自己(`watcher`实例)，通过`push`方法传入\n\n看到这里，又晕了， 什么时候又冒出来一个`Batcher`\n\n我们又找到`Batcher`的构造函数好好分析下，\n```JavaScript\n// 批处理构造函数\nfunction Batcher() {\n  //  重置  has  queue waiting\n  this.reset()\n}\n\nBatcher.prototype.reset = function () {\n  this.has = {}\n  this.queue = []\n  this.waiting = false\n} \n\n// 将watcher 添加到队列中\nBatcher.prototype.push = function (job) {\n  let id = job.id\n  // 先根据 对象的key 看看是否已经有了这个watcher\n  if (!this.has[id]) {\n    // console.log(batcher)\n    this.queue.push(job)\n    // 将watcher 的key的设为true\n    this.has[id] = true\n\n    // 延迟执行\n    if (!this.waiting ) {\n      this.waiting = true\n      if ( \"Promise\" in window ) {\n        Promise.resolve().then(() => {\n          this.flush()\n        })\n      } else {\n        setTimeout(() => {\n          this.flush()\n        }, 0)\n      }\n    }\n  }\n}\n\n\n// 执行并情况事件队列\nBatcher.prototype.flush = function() {\n  this.queue.forEach(job => {\n    job.cb()\n  })\n  this.reset()\n}\n\n\n```\n\n`Batcher`的构造函数很简单， 就调用了一下自己的`reset`方法， 但好像事情远没有这么简单，我们不是在 `Watcher`的`update`方法中调用了`batcher.push`吗， 我也可以在这原型上找的这个方法， 首先它接收一个`job`参数， 也就是`Watcher`实例， \n\n获取到该`watcher`的`id`, 然后使用这个`id`,去`has`这个对象上访问一下， 看看是否存在，\n如果不存在，在证明之前没有添加进来过， 然后将该`watcher`实例加到`queue`队列中， \n并将`has`对象中`id`对应的值设为`true`, 以防止重复加入队列\n\n并且判断一下`waiting`，得知当前是否处于等待状态， 如果不是， 就将`waiting`改为`true`, 然后就是判断当前浏览器的支持情况， 将处理的任务扔到异步队列中\n\n它这里这么做是为了，只批处理一次， 你一瞬间加入多个`watcher`, 很容易造成重复执行， 利用`Watcher`的`id`来过滤， 并且利用异步， 等你要加的`watcher`都加完了， 我再给你统一的去执行所有`Watcher`\n\n也就是异步任务结束后调用的`flush`方法， 它在内部会遍历`queue`队列， 挨个的调用`Watcher`的`cb`方法\n在这一切都执行完成之后， 又调用了一次`reset`方法， 将`bascher`的三个属性重置为初始状态\n\n此时关注点又回到了`Watcher`身上， 它的`cb`方法又做了什么\n```JavaScript\nWatcher.prototype = {\n  // ...省略其他方法\n\n  // 给dom赋值\n  cb() {\n    // 最终实际虚拟dom 处理结果， 只处理一次\n    // 虚拟dom -> diff( 虚拟dom ) -> 局部更新 -> createElement(vNode) -> render\n    this.node[this.type] = this.value\n  },\n}\n```\n\n可以看到`cb`方法做的事情很简单那， 就是**根据元素的值类型去修改元素对象的值**， 而这个`this.value`早在之前调用 `Watcher`的`get`方法时就被赋上了\n\n到这里，整个流程就走完了， 相信你还是一头雾水， 我们把整个流程来串一下\n\n1. new Vue\n2. 将`data`中的值挂上 `getter`和`setter` 的相应方法， 然后暂且搁置，因为此时还无人调用`getter`和`setter`\n3. 通过 `Compile`解析模板， 挨个递归`#app`下的`dom`, 判断元素类型， 如果是元素，并且使用了`v-model`， 就绑定一个`input`事件,  如果是文本类型节点,就去匹配是使用了`{{ xx }}`语法， 最后为他们都创建了一个`watcher`\n4. 每个`watcher` 用来保存相关的元素对象， `vm`实例，使用的`变量` 以及元素值类型, 并将自己的实例交给， `Dep.target`， 并触发自己的`update`方法，`update`方法又会调用`get`方法， `get`方法又会触发该变量的`getter`， 这也就使得`getter`中可以将该`watcher`放入`dep`实例中， 最后将自己也放入`Bacher`中，用以批处理以及将`Dep.target`置空\n5. `Batcher`是个单例， 根据`Watcher`的`id`, 它用来过滤重复传入的`Watcher`, 保证一个`Watcher`只触发一次, 并将更新事件丢入异步，等当前的连续操作执行完成后去调用`Watcher`的`cb`方法更新`dom`\n6. 之后用户修改了变量, `setter`又会调用`dep`这个发布者来发出通知， 相关的`Watcher`的`update`方法再次被调用， 又会加入`batcher` , `batcher`等待异步完成后又调用`Watcher`的`cb`方法更新`dom`\n\n\n**到这里就整个串完了，但是感觉废话还是有点多， 再简化一点流程**:\n\nnew Vue --> `Observe` 挂载 `setter` 和 `getter` -->  `Compile` 编译模板 --> 为每个指令分配一个`watcher` --> 创建时会调用一次`watcher.update` 将自己加入到`batcher`的队列 -->\n并且此时会触发 `getter` 将`watcher`加入`dep` -->  `batcher` 统一来处理`watcher`后初始化自己 -->  当用户修改某个变量时 --> `dep`通知`watcher` --> `watcher`又被加入`batcher`处理 --> `watcher` 更新`dom`\n\n\n`Vue`的`batcher`还是实现的不是很好， 缺少调度机制， 这点上还是`React Fiber`更优秀点，`Fiber`如果遇上了长时间的任务会选择放弃， 避免阻塞进程。\n\n\n😕好了， 神秘的`Vue`源码已被揭开面纱， 但这仅仅是简易版的实现， 真实的`Vue`非常庞大， 还有更多的内容， 这里只是让大家明白`MVVM`的核心原理\n\n\n项目源码:\n> https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue\n\n优质文献: \n* [汤姆大叔的观察者模式](http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html)","slug":"【Vue】源码解析","published":1,"updated":"2019-09-09T16:57:46.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf50y00h9aas6sj2ll0dm"},{"title":"【React】Fiber架构","date":"2019-06-29T17:06:56.000Z","_content":"## Fiber 是什么\n\nFiber 是一个名词， 在计算机科学中除了进程（Process） 和线程（Thread）的概念还有一个概念叫做Fiber, 英文含义就是“纤维”， 意指比Thread更细的线， 也就是比线程（Thread）控制得更精密的并发处理机制。Fiber可以提升复杂React应用的可响应性和性能。 Fiber 即是React 新的调度算法（ reconciliation algorithm） 现有React 中， 更新过程是同步的，当组件树比较庞大的时候， 浏览器主线程被React占用。用户此时输入Input 会造成页面卡顿。\n\nFiber使用协作式多任务处理任务。 将原来的整个Virtual Dom 的更新任务拆分成一个个小的任务。 每次做完一个小任务之后， 放弃一下自己的执行将线程空闲出来， 看看有没有其他的任务。如果有的话， 就暂停本次仍无， 执行其他的任务， 如果没有的话，就继续下一个任务。\n\n## React16与Fiber\n1. react16升级了reconcile 算法架构， 从stack升级为fiber 架构。每次组件的state更新都会出发reconcile的执行也是一个递归过程， 而且一开始知道递归完所有节点才停止， 因此称为stack算法。由于js是单线程的， 因此此时就可能会影响用户的输入或者Ui的渲染帧频造成卡顿， 降低用户体验。而fiber 架构则不一样， 底层是基于 requestdleCallback来调度diff算法的执行， 它的特点顾名思义就是利用空闲时间来完成任务。 注意这里的空闲时间就是相对于那些优先级更高的任务（比如用户输入、 Ui渲染）来说的。\n\n2. requestIdelCallback Polyfill 使用了一个33毫秒， 这个时间是React 认为的一个可以接收的最大值， 如果运行设备能做到大与30fps， 那么它会去调整这个值（通常情况下可以调整到16.6ms）。 调整策略是用当前每帧的总时间与实际每帧的时间进行比较， 当实际时间小于当前时间且稳定( 前后两次都小于当前时间 )， 那么就会认为这个值是有效的， 然后将没帧时间调整为该值（取前后两次中时间大的值）， 还有就是requestAnimationFrame 回调的第一个参数， 每一帧的起始时间， 最终借助requestAnimationFrame 让一批扁平任务恰好控制在一块一块的33ms这样的时间片内执行即可\n\n\n\n## Fiber的两个阶段\n由reconciler和 renderer两个概念引出的是Phase的概念， Phase指的是React组件渲染时的阶段。\n\n1. Reconcile 阶段。 此阶段中， 依序遍历组件， 通过diff算法， 判断组件是否需要更新， 给需要更新的组件加上tag， 遍历完之后， 将所有带有tag的组件加到一个数组中。 这个阶段的任务可以被打断。\n\n2. Commit 阶段。 根据Reconcile 阶段生成的数组， 遍历更新DOM， 这个阶段需要一次性执行完。（无法被打断）\n\n\n![2019-06-30-13-11-52](http://img.nixiaolei.com/2019-06-30-13-11-52.png)\n\n### 如何打断任务\nFiber的打断方式就是使用`cancelIdleCallback`方法取消掉回调\n\n## Fiber如何排列任务\n> 利用双向链表， 按照任务的优先级设定任务的过期时间，然后根据任务的过期时间，插入到双向链表中\n\n\n\nReact Fiber 把更新过程碎片化， 每执行完一段更新过程， 就把控制权交还给React 负责仍无协调的模块， 看看有没有其他紧急任务要做， 如果没有就继续去更新， 如果由紧急任务， 那就去做紧急任务。Fiber分为2个阶段， \n\n1. 第一阶段Reconciliation Phase( componentWillMount、componentWillReceiveProps、 shouldComponentUpdate、componentWillUpdate)  \n\n2. 第二阶段Commit Phase(componentDidMount、componentDidUpdate、componentWillUnmount )第一阶段可能会被打断， 也就意味着第一阶段中的生命周期函数在一次加载和更新过程中可能会被多次调用！\n\n***\ngetDerivedStateFromProps在处在Render Phase阶段， 每次的更新都要触发。这个生命周期是纯函数、静态方法为了隔离实例(禁止this.refs等)单纯且高效， getSnapshotBeforeUpdate到了commit 阶段，因此这个函数只会运行一次\n\n## 概述Fiber原理\nFiber 核心思想是渲染和js执行之间的调度,  为了在进行复杂的js代码时不阻碍到用户体验, 比如React 在执行某些代码时, input 的框没有办法在用户执行时及时的做出响应, 这就会让用户觉得这个网页卡死了!,  Fiber 就是为了解决这个问题而生的\n\nFiber 可以说是参考了操作系统管理进程的方式, 分时调度, 给每个进程一定的执行时间来回切换,   而Fiber 是让js任务与浏览器渲染之间来回切换, 以防止出现无响应的情况.\n\n那Fiber 会如何做呢:\n\n首先, Fiber 会模拟一个requestIdleCallback 方法, 是利用requestAnimationFrame 实现的polyfill 方法,  利用该方法回调中接收的参数来判定每一帧留下的空闲期,   然后给每一个任务都判定级别, 轻重缓急, 如下\n\n```js\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n```\n\n每个优先级都对应着不一样的 deadline(超时时间):\n\n```js\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\n// 250ms以后过期\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\n// 永不过期 - 为什么是12天， 因为v8整数上限\nvar IDLE_PRIORITY = maxSigned31BitInt;\n```\n\n规定好每个不同优先级任务的 超时时间后, 我们就可以对每个任务进行排队了, 那如何排队最灵活呢?  首先Fiber 会构建一个 `循环双向链` , 将每个任务都作为一个节点, 并根据超时时间作为排序的依据, 每当有新任务进入时, 从头挨个对比每个节点, 直至遇到超时时间大于该任务自身的节点, 将其插入到该位置, 如果整个链表中都没有找到超时时间大于该任务的节点, 那么就他就作为了链表的末尾节点, 并将 Next 指向链表的首节点. 又或者,如果首节点就符合条件, 那该节点就转而变成了首节点\n\nFiber对浏览器的帧率有个最低下限的取值, 也就是33 ( 根据每秒30帧得出 ),  但是这个值也并不是写死的, 它会去跑两次方法尝试计算, 如果两次计算所花费的时间小于这个值, 也就是用两次测试来判断浏览器性能, 如果浏览器性能超出预期, 那么就会使用着两次计算结果的最大值. 这是Fiber在进行动态的压帧. 根据性能提供最优的时间.\n\n\n优先次序排列好了, 执行间隔也确定了, 那剩下的事情就是执行了,  执行呢就是我们刚刚说的, 利用`requestAnimationFrame` 计算出每一帧的空档期,  这里需要注意, Fiber 还留有一手备用, 那就是 `setTimeout`. 为什么要使用`setTimeout` 呢, 这是因为, `requestAnimationFrame`有个致命的问题, 当用户切换浏览器tab页以后, `requestAnimationFrame` 就会停止执行, 所以Fiber就会转而切换至使用`setTimeout` 代替.  并且在 `requestAnimationFrame` 执行时打断了 `setTimeout` , 在`setTimeout` 执行时打断了`requestAnimationFrame`\n\n```js\nvar requestAnimationFrameWithTimeout = function(callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function(timestamp) {\n    //每一次系统执行的performance.now 默认间隔是16.7\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function() {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n```\n\nFiber在每一帧的具体执行期间,会尽可能多的执行任务, 也就是说一个任务执行完如果时间还没到还会再找下一个任务,  并使用`MessageChannel`来进行分配任务, 并且有时候会有浏览器渲染任务较重时,如重排, 导致了占用时间超时, 那么Fiber会强制执行以超时的那些任务, 因为这些任务实在不能再拖了, 再拖下去,整个程序就废了, 所以必须现在执行完毕,  执行完的任务就会退出链表, 当本次查找到的超时任务都执行完毕后, Fiber 又会再去遍历一遍链表看看还有没有新的超时任务, 如果有那就接着执行掉, 执行完了同理, 又去再查找一遍, 一直重复, 直至没有超时任务了, 然后让出线程让浏览器渲染.  \n\n到这里就是Fiber 调度的主要原理, 写的很糙, 可能直有我自己能看懂了\n\n## Fiber 源码 + 注释\n\n```Js\n/** @license React v0.13.6\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * 老袁解析react fiber\n * 1.获取当前系统的开始时间\n * 2.设置任务的优先级\n * 3.根据优先级别设置对应的过期时间\n * 4.根据过期时间进行双向链表的排序\n * 5.排完序了 然后如何执行呢？？？ensureHostCallbackIsScheduled\n * 6.按照每一帧之后的空闲开始进行更新 requestAnimationFrameWithTimeout\n * 7.animationTick是线索 计算帧过期时间并压缩帧\n * 8.配合MessageChannel进行具体的调度任务\n * 9.prevScheduledCallback == flushWork最终执行调度\n * 原则：有过期的执行全部过期 没过期尽可能多的执行\n * 剩下没执行完轮回到5 如果插入了高优先级的立即执行\n *  */\n\"use strict\";\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n\n    var enableSchedulerDebugging = false;\n\n    /* eslint-disable no-var */\n\n    // TODO: Use symbols?\n    //yideng 2.设置任务的优先级\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    // var ImmediatePriority = 1;  //最高优先级\n    // var UserBlockingPriority = 2; //用户阻塞型优先级\n    // var NormalPriority = 3; //普通优先级\n    // var LowPriority = 4; // 低优先级\n    // var IdlePriority = 5; // 空闲优先级\n    //==========接下来是对五种优先级别设置的五个过期时间=============\n    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n    //3.根据优先级别设置对应的过期时间\n    //32位系统V8引擎里最大的整数 据粗略计算这个时间大概是12.427天\n    //tab页开着12天才会过期\n    var maxSigned31BitInt = 1073741823;\n    // 立马过期 ==> ImmediatePriority\n    // Times out immediately\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n    // Eventually times out\n    // 250ms以后过期\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000;\n    // Never times out\n    // 永不过期 - 为什么是12天， 因为v8整数上限\n    var IDLE_PRIORITY = maxSigned31BitInt;\n    /*每个任务在添加到链表里的时候，都会通过 performance.now() + timeout\n    来得出这个任务的过期时间，随着时间的推移，当前时间会越来越接近这个过期时间，\n    所以过期时间越小的代表优先级越高。如果过期时间已经比当前时间小了，\n    说明这个任务已经过期了还没执行，需要立马去执行(asap)。*/\n    // Callbacks are stored as a circular, doubly linked list.\n\n    //第一个任务节点\n    var firstCallbackNode = null;\n\n    var currentDidTimeout = false;\n    // Pausing the scheduler is useful for debugging.\n    var isSchedulerPaused = false;\n\n    var currentPriorityLevel = NormalPriority;\n    var currentEventStartTime = -1;\n    var currentExpirationTime = -1;\n\n    // This is set when a callback is being executed, to prevent re-entrancy.\n    var isExecutingCallback = false;\n\n    var isHostCallbackScheduled = false;\n    //yideng 1.获取当前系统的开始时间-performance.now\n    var hasNativePerformanceNow =\n      typeof performance === \"object\" && typeof performance.now === \"function\";\n\n    function ensureHostCallbackIsScheduled() {\n      if (isExecutingCallback) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      }\n      // Schedule the host callback using the earliest expiration in the list.\n      var expirationTime = firstCallbackNode.expirationTime;\n      // 加锁\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelHostCallback();\n      }\n      requestHostCallback(flushWork, expirationTime);\n    }\n\n    function flushFirstCallback() {\n      var flushedNode = firstCallbackNode;\n\n      // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = firstCallbackNode.next;\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var lastCallbackNode = firstCallbackNode.previous;\n        firstCallbackNode = lastCallbackNode.next = next;\n        next.previous = lastCallbackNode;\n      }\n\n      flushedNode.next = flushedNode.previous = null;\n\n      // Now it's safe to call the callback.\n      var callback = flushedNode.callback;\n      var expirationTime = flushedNode.expirationTime;\n      var priorityLevel = flushedNode.priorityLevel;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousExpirationTime = currentExpirationTime;\n      currentPriorityLevel = priorityLevel;\n      currentExpirationTime = expirationTime;\n      var continuationCallback;\n      try {\n        continuationCallback = callback();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentExpirationTime = previousExpirationTime;\n      }\n\n      // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n      if (typeof continuationCallback === \"function\") {\n        var continuationNode = {\n          callback: continuationCallback,\n          priorityLevel: priorityLevel,\n          expirationTime: expirationTime,\n          next: null,\n          previous: null\n        };\n\n        // Insert the new callback into the list, sorted by its expiration. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal expiration instead\n        // of after.\n        if (firstCallbackNode === null) {\n          // This is the first callback in the list.\n          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n        } else {\n          var nextAfterContinuation = null;\n          var node = firstCallbackNode;\n          do {\n            if (node.expirationTime >= expirationTime) {\n              // This callback expires at or after the continuation. We will insert\n              // the continuation *before* this callback.\n              nextAfterContinuation = node;\n              break;\n            }\n            node = node.next;\n          } while (node !== firstCallbackNode);\n\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority callback was found, which means the new\n            // callback is the lowest priority callback in the list.\n            nextAfterContinuation = firstCallbackNode;\n          } else if (nextAfterContinuation === firstCallbackNode) {\n            // The new callback is the highest priority callback in the list.\n            firstCallbackNode = continuationNode;\n            ensureHostCallbackIsScheduled();\n          }\n\n          var previous = nextAfterContinuation.previous;\n          previous.next = nextAfterContinuation.previous = continuationNode;\n          continuationNode.next = nextAfterContinuation;\n          continuationNode.previous = previous;\n        }\n      }\n    }\n\n    function flushImmediateWork() {\n      if (\n        // Confirm we've exited the outer most event handler\n        currentEventStartTime === -1 &&\n        firstCallbackNode !== null &&\n        firstCallbackNode.priorityLevel === ImmediatePriority\n      ) {\n        isExecutingCallback = true;\n        try {\n          do {\n            flushFirstCallback();\n          } while (\n            // Keep flushing until there are no more immediate callbacks\n            firstCallbackNode !== null &&\n            firstCallbackNode.priorityLevel === ImmediatePriority\n          );\n        } finally {\n          isExecutingCallback = false;\n          if (firstCallbackNode !== null) {\n            // There's still work remaining. Request another callback.\n            ensureHostCallbackIsScheduled();\n          } else {\n            isHostCallbackScheduled = false;\n          }\n        }\n      }\n    }\n\n    function flushWork(didTimeout) {\n      // Exit right away if we're currently paused\n\n      if (enableSchedulerDebugging && isSchedulerPaused) {\n        return;\n      }\n\n      isExecutingCallback = true;\n      var previousDidTimeout = currentDidTimeout;\n      currentDidTimeout = didTimeout;\n      try {\n        //如果是任务过期了 赶紧排队把过期的任务给执行了\n        if (didTimeout) {\n          // Flush all the expired callbacks without yielding.\n          while (\n            firstCallbackNode !== null &&\n            !(enableSchedulerDebugging && isSchedulerPaused)\n          ) {\n            // TODO Wrap in feature flag\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n            if (firstCallbackNode.expirationTime <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (\n                firstCallbackNode !== null &&\n                firstCallbackNode.expirationTime <= currentTime &&\n                !(enableSchedulerDebugging && isSchedulerPaused)\n              );\n              continue;\n            }\n            break;\n          }\n        } else {\n          //当前帧有富余时间，while的逻辑是只要有任务且当前帧没过期就去执行任务。\n          //执行队首任务，把队首任务从链表移除，并把第二个任务置为队首任务。执行任务可能产生新的任务，再把新任务插入到任务链表\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              if (enableSchedulerDebugging && isSchedulerPaused) {\n                break;\n              }\n              flushFirstCallback();\n              //shouldYieldToHost代表当前帧过期了，取反的话就是没过期。\n            } while (firstCallbackNode !== null && !shouldYieldToHost());\n          }\n        }\n      } finally {\n        isExecutingCallback = false;\n        currentDidTimeout = previousDidTimeout;\n        //最后，如果还有任务的话，再启动一轮新的任务执行调度\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled();\n        } else {\n          isHostCallbackScheduled = false;\n        }\n        // Before exiting, flush all the immediate work that was scheduled.\n         //最最后，如果还有任务且有最高优先级的任务，就都执行一遍。\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime;\n\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_next(eventHandler) {\n      var priorityLevel = void 0;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime;\n\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function() {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        var previousEventStartTime = currentEventStartTime;\n        currentPriorityLevel = parentPriorityLevel;\n        currentEventStartTime = exports.unstable_now();\n\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n          currentEventStartTime = previousEventStartTime;\n          flushImmediateWork();\n        }\n      };\n    }\n    //yideng 4.根据过期时间进行双向链表的排序\n    function unstable_scheduleCallback(callback, deprecated_options) {\n      var startTime =\n        currentEventStartTime !== -1\n          ? currentEventStartTime\n          : exports.unstable_now();\n\n      var expirationTime;\n      if (\n        typeof deprecated_options === \"object\" &&\n        deprecated_options !== null &&\n        typeof deprecated_options.timeout === \"number\"\n      ) {\n        // FIXME: Remove this branch once we lift expiration times out of React.\n        //如果没有传递过去时间的话直接按照默认的传递\n        expirationTime = startTime + deprecated_options.timeout;\n      } else {\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n          case UserBlockingPriority:\n            expirationTime = startTime + USER_BLOCKING_PRIORITY;\n            break;\n          case IdlePriority:\n            expirationTime = startTime + IDLE_PRIORITY;\n            break;\n          case LowPriority:\n            expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n            break;\n          case NormalPriority:\n          default:\n            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n        }\n      }\n      //yideng 双向的链表\n      var newNode = {\n        callback: callback, //任务具体的内容\n        priorityLevel: currentPriorityLevel, //任务优先级\n        expirationTime: expirationTime, //任务的过期时间\n        next: null, //下一个节点\n        previous: null //上一个节点\n      };\n\n      // Insert the new callback into the list, ordered first by expiration, then\n      // by insertion. So the new callback is inserted any other callback with\n      // equal expiration.\n      //yideng仿照之前的双向节点的例子 插入指定节点\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        //排完顺序之后按照指定的规则执行任务\n        //那么什么是合适的时间呢？也就是之前讨论过的每一帧绘制完成之后的空闲时间\n        //5.排完序了 然后如何执行呢？？？ensureHostCallbackIsScheduled\n        ensureHostCallbackIsScheduled();\n      } else {\n        // 一直查找链表, 直至某个节点的next === firtNode\n        var next = null;\n        var node = firstCallbackNode;\n        do {\n          // 对比过期时间\n          if (node.expirationTime > expirationTime) {\n            // 如果当前节点的过期时间 比 新来的callback 过期时间要晚 , 则将next指向当前的节点\n            // The new callback expires before this one.\n            next = node;\n            break;\n          }\n          node = node.next;\n        } while (node !== firstCallbackNode);\n        \n        // next === null 就表示始终未找到某个节点比新来的回调过期时间要晚, 这就表示他是最晚的, 他是链表的末尾, 所以把他的next指向首节点\n        if (next === null) {\n          // No callback with a later expiration was found, which means the new\n          // callback has the latest expiration in the list.\n          next = firstCallbackNode;\n\n          // next === firstCallbackNode 表示找到符合条件的节点， 但是该节点是首节点， 这就表示 新的回调 比 firtCallbackNode 的优先级还要高的话， 就将他作为\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest expiration in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled();\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n\n      return newNode;\n    }\n\n    function unstable_pauseExecution() {\n      isSchedulerPaused = true;\n    }\n\n    function unstable_continueExecution() {\n      isSchedulerPaused = false;\n      if (firstCallbackNode !== null) {\n        ensureHostCallbackIsScheduled();\n      }\n    }\n\n    function unstable_getFirstCallbackNode() {\n      return firstCallbackNode;\n    }\n\n    function unstable_cancelCallback(callbackNode) {\n      var next = callbackNode.next;\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      callbackNode.next = callbackNode.previous = null;\n    }\n\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n\n    function unstable_shouldYield() {\n      return (\n        !currentDidTimeout &&\n        ((firstCallbackNode !== null &&\n          firstCallbackNode.expirationTime < currentExpirationTime) ||\n          shouldYieldToHost())\n      );\n    }\n\n    // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n    var localDate = Date;\n\n    // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n    var localSetTimeout =\n      typeof setTimeout === \"function\" ? setTimeout : undefined;\n    var localClearTimeout =\n      typeof clearTimeout === \"function\" ? clearTimeout : undefined;\n\n    // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n    var localRequestAnimationFrame =\n      typeof requestAnimationFrame === \"function\"\n        ? requestAnimationFrame\n        : undefined;\n    var localCancelAnimationFrame =\n      typeof cancelAnimationFrame === \"function\"\n        ? cancelAnimationFrame\n        : undefined;\n\n    // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n    // ↑这句话表示，使用setTimeout 也是无奈之举， 之后会更优化， 当下是迫于浏览器不支持\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n    //yideng 如果tab不激活的话 使用SetTimeout进行处理 如果正常情况直接干掉timeout\n    //6.按照每一帧之后的空闲开始进行更新requestAnimationFrameWithTimeout\n    // \n    // 这里又使用了 setTimeout 又使用了RequestAnimationFrame 并且还互相清除， \n    // 是因为 RequestAnimationFrame 有一个落点， 就是当浏览器切到其他tab页的时候会暂停执行\n    var requestAnimationFrameWithTimeout = function(callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function(timestamp) {\n        //每一次系统执行的performance.now 默认间隔是16.7\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function() {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n      exports.unstable_now = function() {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function() {\n        return localDate.now();\n      };\n    }\n\n    var requestHostCallback;\n    var cancelHostCallback;\n    var shouldYieldToHost;\n\n    var globalValue = null;\n    if (typeof window !== \"undefined\") {\n      globalValue = window;\n    } else if (typeof global !== \"undefined\") {\n      globalValue = global;\n    }\n\n    if (globalValue && globalValue._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var globalImpl = globalValue._schedMock;\n      requestHostCallback = globalImpl[0];\n      cancelHostCallback = globalImpl[1];\n      shouldYieldToHost = globalImpl[2];\n      exports.unstable_now = globalImpl[3];\n    } else if (\n      // If Scheduler runs in a non-DOM environment, it falls back to a naive\n      // implementation using setTimeout.\n      typeof window === \"undefined\" ||\n      // Check if MessageChannel is supported, too.\n      typeof MessageChannel !== \"function\"\n    ) {\n      // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n      // fallback to a naive implementation.\n      var _callback = null;\n      var _flushCallback = function(didTimeout) {\n        if (_callback !== null) {\n          try {\n            _callback(didTimeout);\n          } finally {\n            _callback = null;\n          }\n        }\n      };\n      requestHostCallback = function(cb, ms) {\n        if (_callback !== null) {\n          // Protect against re-entrancy.\n          setTimeout(requestHostCallback, 0, cb);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, 0, false);\n        }\n      };\n      cancelHostCallback = function() {\n        _callback = null;\n      };\n      shouldYieldToHost = function() {\n        return false;\n      };\n    } else {\n      if (typeof console !== \"undefined\") {\n        // TODO: Remove fb.me link\n        if (typeof localRequestAnimationFrame !== \"function\") {\n          console.error(\n            \"This browser doesn't support requestAnimationFrame. \" +\n              \"Make sure that you load a \" +\n              \"polyfill in older browsers. https://fb.me/react-polyfills\"\n          );\n        }\n        if (typeof localCancelAnimationFrame !== \"function\") {\n          console.error(\n            \"This browser doesn't support cancelAnimationFrame. \" +\n              \"Make sure that you load a \" +\n              \"polyfill in older browsers. https://fb.me/react-polyfills\"\n          );\n        }\n      }\n\n      var scheduledHostCallback = null; //代表任务链表的执行器\n      var isMessageEventScheduled = false;\n      var timeoutTime = -1; //代表最高优先级任务firstCallbackNode的过期时间\n      var isAnimationFrameScheduled = false;\n      var isFlushingHostCallback = false;\n      var frameDeadline = 0; //代表一帧的过期时间，通过rAF回调入参t加上activeFrameTime来计算\n      // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n      var previousFrameTime = 33; // 一帧的渲染时间33ms，这里假设 1s 30帧\n      var activeFrameTime = 33;\n\n      shouldYieldToHost = function() {\n        return frameDeadline <= exports.unstable_now();\n      };\n\n      // We use the postMessage trick to defer idle work until after the repaint.\n      //如下是整个的执行流程，\n      //8.配合MessageChannel进行具体的调度任务\n      //8-1.在每一帧开始的rAF的回调里记录每一帧的开始时间，并计算每一帧的过期时间，\n      //8-2.通过messageChannel发送消息。在帧末messageChannel的回调里接收消息，\n      //8-3.根据当前帧的过期时间和当前时间进行比对来决定当前帧能否执行任务，\n      //8-4.如果能的话会依次从任务链表里拿出队首任务来执行\n      //8-5.执行尽可能多的任务后如果还有任务，下一帧再重新调度。\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      //下面的代码逻辑决定当前帧要不要执行任务\n      // 1、如果当前帧没过期，说明当前帧有富余时间，可以执行任务\n      // 2、如果当前帧过期了，说明当前帧没有时间了，这里再看一下当前任务firstCallbackNode\n      //是否过期，如果过期了也要执行任务；如果当前任务没过期，说明不着急，那就先不执行去\n      channel.port1.onmessage = function(event) {\n        isMessageEventScheduled = false;\n\n        var prevScheduledCallback = scheduledHostCallback;\n        var prevTimeoutTime = timeoutTime;\n        scheduledHostCallback = null;\n        timeoutTime = -1;\n\n        var currentTime = exports.unstable_now();\n\n        var didTimeout = false;\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            //任务过期\n            didTimeout = true;\n          } else {\n            // No timeout.\n            //当前帧由于浏览器渲染等原因过期了，那就去下一帧再处理\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            }\n            // Exit without invoking the callback.\n            scheduledHostCallback = prevScheduledCallback;\n            timeoutTime = prevTimeoutTime;\n            return;\n          }\n        }\n\n        if (prevScheduledCallback !== null) {\n          isFlushingHostCallback = true;\n          try {\n            prevScheduledCallback(didTimeout);\n          } finally {\n            isFlushingHostCallback = false;\n          }\n        }\n      };\n      //7.animationTick是线索 计算帧过期时间并压缩帧\n      var animationTick = function(rafTime) {\n        if (scheduledHostCallback !== null) {\n          //有任务再进行递归，没任务的话不需要工作\n          // Eagerly schedule the next animation callback at the beginning of the\n          // frame. If the scheduler queue is not empty at the end of the frame, it\n          // will continue flushing inside that callback. If the queue *is* empty,\n          // then it will exit immediately. Posting the callback at the start of the\n          // frame ensures it's fired within the earliest possible frame. If we\n          // waited until the end of the frame to post the callback, we risk the\n          // browser skipping a frame and not firing the callback until the frame\n          // after that.\n          requestAnimationFrameWithTimeout(animationTick);\n        } else {\n          // No pending work. Exit.\n          isAnimationFrameScheduled = false;\n          return;\n        }\n        // rafTime 就是 requestAnimationFrame 回调接收的时间\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n        //用连续的两次时间 被不断的压缩activeFrameTime\n        if (\n          nextFrameTime < activeFrameTime &&\n          previousFrameTime < activeFrameTime\n        ) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame time gets lower than 8, it is probably a bug.\n            nextFrameTime = 8;\n          }\n          // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n          activeFrameTime =\n            nextFrameTime < previousFrameTime\n              ? previousFrameTime\n              : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n        //计算当前帧的截止时间，用开始时间加上每一帧的渲染时间\n        frameDeadline = rafTime + activeFrameTime;\n        if (!isMessageEventScheduled) {\n          isMessageEventScheduled = true;\n          //port2 负责发送数据\n          //port2监听消息的回调来做任务调度的具体工作\n          port.postMessage(undefined);\n        }\n      };\n\n      // 接收两个参数， flushwork 和 过期时间\n      requestHostCallback = function(callback, absoluteTimeout) {\n        scheduledHostCallback = callback;\n        // 过期时间\n        timeoutTime = absoluteTimeout;\n        if (isFlushingHostCallback || absoluteTimeout < 0) {\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          port.postMessage(undefined);\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n\n      cancelHostCallback = function() {\n        scheduledHostCallback = null;\n        isMessageEventScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_next = unstable_next;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n```\n\n\n\n\n\n\n## 双向链表实现\n\n```Js\n// 1.双向链表是指每个节点有previous和next两个属性来分别指向前后两个节点。\n// 2.循环的意思是，最后一个节点的next指向第一个节点，\n// 下面假设有一群人需要按照年龄进行排队，小孩站前边，大人站后边。\n// 在一个过程内会不断有人过来，我们需要把他插到正确的位置。删除的话只考虑每次把排头的人给去掉。\n\n//person的类型定义\ninterface Person {\n  name: string; //姓名\n  age: number; //年龄，依赖这个属性排序\n  next: Person; //紧跟在后面的人,默认是null\n  previous: Person; //前面相邻的那个人,默认是null\n}\nvar firstNode = null; //一开始链表里没有节点\n\n//插入的逻辑\nfunction insertByAge(newPerson: Person) {\n  if ((firstNode = null)) {\n    //如果 firstNode为空，说明newPerson是第一个人，\n    //把它赋值给firstNode，并把next和previous属性指向自身，自成一个环。\n    firstNode = newPerson.next = newPerson.previous = newPerson;\n  } else {\n    //队伍里有人了，新来的人要找准自己的位置\n\n    var next = null; //记录newPerson插入到哪个人前边\n    var person = firstNode; // person 在下边的循环中会从第一个人开始往后找\n\n    do {\n      if (person.age > newPerson.age) {\n        //如果person的年龄比新来的人大，说明新来的人找到位置了，他恰好要排在person的前边，结束\n        next = person;\n        break;\n      }\n      //继续找后面的人\n      node = node.next;\n    } while (node !== firstNode); //这里的while是为了防止无限循环，毕竟是环形的结构\n\n    if (next === null) {\n      //找了一圈发现 没有person的age比newPerson大，说明newPerson应该放到队伍的最后,也就是说newPerson的后面应该是firstNode。\n      next = firstNode;\n    } else if (next === firstNode) {\n      //找第一个的时候就找到next了，说明newPerson要放到firstNode前面，这时候firstNode就要更新为newPerson\n      firstNode = newPerson;\n    }\n\n    //下面是newPerson的插入操作，给next及previous两个人的前后链接都关联到newPerson\n    var previous = next.previous;\n    previous.next = next.previous = newPerson;\n    newPerson.next = next;\n    newPerson.previous = previous;\n  }\n  //插入成功\n}\n\n//删除第一个节点\nfunction deleteFirstPerson() {\n  if (firstNode === null) return; //队伍里没有人，返回\n\n  var next = firstNode.next; //第二个人\n  if (firstNode === next) {\n    //这时候只有一个人\n    firstNode = null;\n    next = null;\n  } else {\n    var lastPerson = firstNode.previous; //找到最后一个人\n    firstNode = lastPerson.next = next; //更新新的第一人\n    next.previout = lastPerson; //并在新的第一人和最后一人之间建立连接\n  }\n}\n\n```\n\n\n\n","source":"_posts/【React】Fiber架构.md","raw":"---\ntitle: 【React】Fiber架构\ndate: 2019-06-30 01:06:56\ncategories: React\ntags: [React, Fiber]\n---\n## Fiber 是什么\n\nFiber 是一个名词， 在计算机科学中除了进程（Process） 和线程（Thread）的概念还有一个概念叫做Fiber, 英文含义就是“纤维”， 意指比Thread更细的线， 也就是比线程（Thread）控制得更精密的并发处理机制。Fiber可以提升复杂React应用的可响应性和性能。 Fiber 即是React 新的调度算法（ reconciliation algorithm） 现有React 中， 更新过程是同步的，当组件树比较庞大的时候， 浏览器主线程被React占用。用户此时输入Input 会造成页面卡顿。\n\nFiber使用协作式多任务处理任务。 将原来的整个Virtual Dom 的更新任务拆分成一个个小的任务。 每次做完一个小任务之后， 放弃一下自己的执行将线程空闲出来， 看看有没有其他的任务。如果有的话， 就暂停本次仍无， 执行其他的任务， 如果没有的话，就继续下一个任务。\n\n## React16与Fiber\n1. react16升级了reconcile 算法架构， 从stack升级为fiber 架构。每次组件的state更新都会出发reconcile的执行也是一个递归过程， 而且一开始知道递归完所有节点才停止， 因此称为stack算法。由于js是单线程的， 因此此时就可能会影响用户的输入或者Ui的渲染帧频造成卡顿， 降低用户体验。而fiber 架构则不一样， 底层是基于 requestdleCallback来调度diff算法的执行， 它的特点顾名思义就是利用空闲时间来完成任务。 注意这里的空闲时间就是相对于那些优先级更高的任务（比如用户输入、 Ui渲染）来说的。\n\n2. requestIdelCallback Polyfill 使用了一个33毫秒， 这个时间是React 认为的一个可以接收的最大值， 如果运行设备能做到大与30fps， 那么它会去调整这个值（通常情况下可以调整到16.6ms）。 调整策略是用当前每帧的总时间与实际每帧的时间进行比较， 当实际时间小于当前时间且稳定( 前后两次都小于当前时间 )， 那么就会认为这个值是有效的， 然后将没帧时间调整为该值（取前后两次中时间大的值）， 还有就是requestAnimationFrame 回调的第一个参数， 每一帧的起始时间， 最终借助requestAnimationFrame 让一批扁平任务恰好控制在一块一块的33ms这样的时间片内执行即可\n\n\n\n## Fiber的两个阶段\n由reconciler和 renderer两个概念引出的是Phase的概念， Phase指的是React组件渲染时的阶段。\n\n1. Reconcile 阶段。 此阶段中， 依序遍历组件， 通过diff算法， 判断组件是否需要更新， 给需要更新的组件加上tag， 遍历完之后， 将所有带有tag的组件加到一个数组中。 这个阶段的任务可以被打断。\n\n2. Commit 阶段。 根据Reconcile 阶段生成的数组， 遍历更新DOM， 这个阶段需要一次性执行完。（无法被打断）\n\n\n![2019-06-30-13-11-52](http://img.nixiaolei.com/2019-06-30-13-11-52.png)\n\n### 如何打断任务\nFiber的打断方式就是使用`cancelIdleCallback`方法取消掉回调\n\n## Fiber如何排列任务\n> 利用双向链表， 按照任务的优先级设定任务的过期时间，然后根据任务的过期时间，插入到双向链表中\n\n\n\nReact Fiber 把更新过程碎片化， 每执行完一段更新过程， 就把控制权交还给React 负责仍无协调的模块， 看看有没有其他紧急任务要做， 如果没有就继续去更新， 如果由紧急任务， 那就去做紧急任务。Fiber分为2个阶段， \n\n1. 第一阶段Reconciliation Phase( componentWillMount、componentWillReceiveProps、 shouldComponentUpdate、componentWillUpdate)  \n\n2. 第二阶段Commit Phase(componentDidMount、componentDidUpdate、componentWillUnmount )第一阶段可能会被打断， 也就意味着第一阶段中的生命周期函数在一次加载和更新过程中可能会被多次调用！\n\n***\ngetDerivedStateFromProps在处在Render Phase阶段， 每次的更新都要触发。这个生命周期是纯函数、静态方法为了隔离实例(禁止this.refs等)单纯且高效， getSnapshotBeforeUpdate到了commit 阶段，因此这个函数只会运行一次\n\n## 概述Fiber原理\nFiber 核心思想是渲染和js执行之间的调度,  为了在进行复杂的js代码时不阻碍到用户体验, 比如React 在执行某些代码时, input 的框没有办法在用户执行时及时的做出响应, 这就会让用户觉得这个网页卡死了!,  Fiber 就是为了解决这个问题而生的\n\nFiber 可以说是参考了操作系统管理进程的方式, 分时调度, 给每个进程一定的执行时间来回切换,   而Fiber 是让js任务与浏览器渲染之间来回切换, 以防止出现无响应的情况.\n\n那Fiber 会如何做呢:\n\n首先, Fiber 会模拟一个requestIdleCallback 方法, 是利用requestAnimationFrame 实现的polyfill 方法,  利用该方法回调中接收的参数来判定每一帧留下的空闲期,   然后给每一个任务都判定级别, 轻重缓急, 如下\n\n```js\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n```\n\n每个优先级都对应着不一样的 deadline(超时时间):\n\n```js\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\n// 250ms以后过期\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\n// 永不过期 - 为什么是12天， 因为v8整数上限\nvar IDLE_PRIORITY = maxSigned31BitInt;\n```\n\n规定好每个不同优先级任务的 超时时间后, 我们就可以对每个任务进行排队了, 那如何排队最灵活呢?  首先Fiber 会构建一个 `循环双向链` , 将每个任务都作为一个节点, 并根据超时时间作为排序的依据, 每当有新任务进入时, 从头挨个对比每个节点, 直至遇到超时时间大于该任务自身的节点, 将其插入到该位置, 如果整个链表中都没有找到超时时间大于该任务的节点, 那么就他就作为了链表的末尾节点, 并将 Next 指向链表的首节点. 又或者,如果首节点就符合条件, 那该节点就转而变成了首节点\n\nFiber对浏览器的帧率有个最低下限的取值, 也就是33 ( 根据每秒30帧得出 ),  但是这个值也并不是写死的, 它会去跑两次方法尝试计算, 如果两次计算所花费的时间小于这个值, 也就是用两次测试来判断浏览器性能, 如果浏览器性能超出预期, 那么就会使用着两次计算结果的最大值. 这是Fiber在进行动态的压帧. 根据性能提供最优的时间.\n\n\n优先次序排列好了, 执行间隔也确定了, 那剩下的事情就是执行了,  执行呢就是我们刚刚说的, 利用`requestAnimationFrame` 计算出每一帧的空档期,  这里需要注意, Fiber 还留有一手备用, 那就是 `setTimeout`. 为什么要使用`setTimeout` 呢, 这是因为, `requestAnimationFrame`有个致命的问题, 当用户切换浏览器tab页以后, `requestAnimationFrame` 就会停止执行, 所以Fiber就会转而切换至使用`setTimeout` 代替.  并且在 `requestAnimationFrame` 执行时打断了 `setTimeout` , 在`setTimeout` 执行时打断了`requestAnimationFrame`\n\n```js\nvar requestAnimationFrameWithTimeout = function(callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function(timestamp) {\n    //每一次系统执行的performance.now 默认间隔是16.7\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function() {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n```\n\nFiber在每一帧的具体执行期间,会尽可能多的执行任务, 也就是说一个任务执行完如果时间还没到还会再找下一个任务,  并使用`MessageChannel`来进行分配任务, 并且有时候会有浏览器渲染任务较重时,如重排, 导致了占用时间超时, 那么Fiber会强制执行以超时的那些任务, 因为这些任务实在不能再拖了, 再拖下去,整个程序就废了, 所以必须现在执行完毕,  执行完的任务就会退出链表, 当本次查找到的超时任务都执行完毕后, Fiber 又会再去遍历一遍链表看看还有没有新的超时任务, 如果有那就接着执行掉, 执行完了同理, 又去再查找一遍, 一直重复, 直至没有超时任务了, 然后让出线程让浏览器渲染.  \n\n到这里就是Fiber 调度的主要原理, 写的很糙, 可能直有我自己能看懂了\n\n## Fiber 源码 + 注释\n\n```Js\n/** @license React v0.13.6\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * 老袁解析react fiber\n * 1.获取当前系统的开始时间\n * 2.设置任务的优先级\n * 3.根据优先级别设置对应的过期时间\n * 4.根据过期时间进行双向链表的排序\n * 5.排完序了 然后如何执行呢？？？ensureHostCallbackIsScheduled\n * 6.按照每一帧之后的空闲开始进行更新 requestAnimationFrameWithTimeout\n * 7.animationTick是线索 计算帧过期时间并压缩帧\n * 8.配合MessageChannel进行具体的调度任务\n * 9.prevScheduledCallback == flushWork最终执行调度\n * 原则：有过期的执行全部过期 没过期尽可能多的执行\n * 剩下没执行完轮回到5 如果插入了高优先级的立即执行\n *  */\n\"use strict\";\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n\n    var enableSchedulerDebugging = false;\n\n    /* eslint-disable no-var */\n\n    // TODO: Use symbols?\n    //yideng 2.设置任务的优先级\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    // var ImmediatePriority = 1;  //最高优先级\n    // var UserBlockingPriority = 2; //用户阻塞型优先级\n    // var NormalPriority = 3; //普通优先级\n    // var LowPriority = 4; // 低优先级\n    // var IdlePriority = 5; // 空闲优先级\n    //==========接下来是对五种优先级别设置的五个过期时间=============\n    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n    //3.根据优先级别设置对应的过期时间\n    //32位系统V8引擎里最大的整数 据粗略计算这个时间大概是12.427天\n    //tab页开着12天才会过期\n    var maxSigned31BitInt = 1073741823;\n    // 立马过期 ==> ImmediatePriority\n    // Times out immediately\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n    // Eventually times out\n    // 250ms以后过期\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000;\n    // Never times out\n    // 永不过期 - 为什么是12天， 因为v8整数上限\n    var IDLE_PRIORITY = maxSigned31BitInt;\n    /*每个任务在添加到链表里的时候，都会通过 performance.now() + timeout\n    来得出这个任务的过期时间，随着时间的推移，当前时间会越来越接近这个过期时间，\n    所以过期时间越小的代表优先级越高。如果过期时间已经比当前时间小了，\n    说明这个任务已经过期了还没执行，需要立马去执行(asap)。*/\n    // Callbacks are stored as a circular, doubly linked list.\n\n    //第一个任务节点\n    var firstCallbackNode = null;\n\n    var currentDidTimeout = false;\n    // Pausing the scheduler is useful for debugging.\n    var isSchedulerPaused = false;\n\n    var currentPriorityLevel = NormalPriority;\n    var currentEventStartTime = -1;\n    var currentExpirationTime = -1;\n\n    // This is set when a callback is being executed, to prevent re-entrancy.\n    var isExecutingCallback = false;\n\n    var isHostCallbackScheduled = false;\n    //yideng 1.获取当前系统的开始时间-performance.now\n    var hasNativePerformanceNow =\n      typeof performance === \"object\" && typeof performance.now === \"function\";\n\n    function ensureHostCallbackIsScheduled() {\n      if (isExecutingCallback) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      }\n      // Schedule the host callback using the earliest expiration in the list.\n      var expirationTime = firstCallbackNode.expirationTime;\n      // 加锁\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelHostCallback();\n      }\n      requestHostCallback(flushWork, expirationTime);\n    }\n\n    function flushFirstCallback() {\n      var flushedNode = firstCallbackNode;\n\n      // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = firstCallbackNode.next;\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var lastCallbackNode = firstCallbackNode.previous;\n        firstCallbackNode = lastCallbackNode.next = next;\n        next.previous = lastCallbackNode;\n      }\n\n      flushedNode.next = flushedNode.previous = null;\n\n      // Now it's safe to call the callback.\n      var callback = flushedNode.callback;\n      var expirationTime = flushedNode.expirationTime;\n      var priorityLevel = flushedNode.priorityLevel;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousExpirationTime = currentExpirationTime;\n      currentPriorityLevel = priorityLevel;\n      currentExpirationTime = expirationTime;\n      var continuationCallback;\n      try {\n        continuationCallback = callback();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentExpirationTime = previousExpirationTime;\n      }\n\n      // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n      if (typeof continuationCallback === \"function\") {\n        var continuationNode = {\n          callback: continuationCallback,\n          priorityLevel: priorityLevel,\n          expirationTime: expirationTime,\n          next: null,\n          previous: null\n        };\n\n        // Insert the new callback into the list, sorted by its expiration. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal expiration instead\n        // of after.\n        if (firstCallbackNode === null) {\n          // This is the first callback in the list.\n          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n        } else {\n          var nextAfterContinuation = null;\n          var node = firstCallbackNode;\n          do {\n            if (node.expirationTime >= expirationTime) {\n              // This callback expires at or after the continuation. We will insert\n              // the continuation *before* this callback.\n              nextAfterContinuation = node;\n              break;\n            }\n            node = node.next;\n          } while (node !== firstCallbackNode);\n\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority callback was found, which means the new\n            // callback is the lowest priority callback in the list.\n            nextAfterContinuation = firstCallbackNode;\n          } else if (nextAfterContinuation === firstCallbackNode) {\n            // The new callback is the highest priority callback in the list.\n            firstCallbackNode = continuationNode;\n            ensureHostCallbackIsScheduled();\n          }\n\n          var previous = nextAfterContinuation.previous;\n          previous.next = nextAfterContinuation.previous = continuationNode;\n          continuationNode.next = nextAfterContinuation;\n          continuationNode.previous = previous;\n        }\n      }\n    }\n\n    function flushImmediateWork() {\n      if (\n        // Confirm we've exited the outer most event handler\n        currentEventStartTime === -1 &&\n        firstCallbackNode !== null &&\n        firstCallbackNode.priorityLevel === ImmediatePriority\n      ) {\n        isExecutingCallback = true;\n        try {\n          do {\n            flushFirstCallback();\n          } while (\n            // Keep flushing until there are no more immediate callbacks\n            firstCallbackNode !== null &&\n            firstCallbackNode.priorityLevel === ImmediatePriority\n          );\n        } finally {\n          isExecutingCallback = false;\n          if (firstCallbackNode !== null) {\n            // There's still work remaining. Request another callback.\n            ensureHostCallbackIsScheduled();\n          } else {\n            isHostCallbackScheduled = false;\n          }\n        }\n      }\n    }\n\n    function flushWork(didTimeout) {\n      // Exit right away if we're currently paused\n\n      if (enableSchedulerDebugging && isSchedulerPaused) {\n        return;\n      }\n\n      isExecutingCallback = true;\n      var previousDidTimeout = currentDidTimeout;\n      currentDidTimeout = didTimeout;\n      try {\n        //如果是任务过期了 赶紧排队把过期的任务给执行了\n        if (didTimeout) {\n          // Flush all the expired callbacks without yielding.\n          while (\n            firstCallbackNode !== null &&\n            !(enableSchedulerDebugging && isSchedulerPaused)\n          ) {\n            // TODO Wrap in feature flag\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n            if (firstCallbackNode.expirationTime <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (\n                firstCallbackNode !== null &&\n                firstCallbackNode.expirationTime <= currentTime &&\n                !(enableSchedulerDebugging && isSchedulerPaused)\n              );\n              continue;\n            }\n            break;\n          }\n        } else {\n          //当前帧有富余时间，while的逻辑是只要有任务且当前帧没过期就去执行任务。\n          //执行队首任务，把队首任务从链表移除，并把第二个任务置为队首任务。执行任务可能产生新的任务，再把新任务插入到任务链表\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              if (enableSchedulerDebugging && isSchedulerPaused) {\n                break;\n              }\n              flushFirstCallback();\n              //shouldYieldToHost代表当前帧过期了，取反的话就是没过期。\n            } while (firstCallbackNode !== null && !shouldYieldToHost());\n          }\n        }\n      } finally {\n        isExecutingCallback = false;\n        currentDidTimeout = previousDidTimeout;\n        //最后，如果还有任务的话，再启动一轮新的任务执行调度\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled();\n        } else {\n          isHostCallbackScheduled = false;\n        }\n        // Before exiting, flush all the immediate work that was scheduled.\n         //最最后，如果还有任务且有最高优先级的任务，就都执行一遍。\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime;\n\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_next(eventHandler) {\n      var priorityLevel = void 0;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime;\n\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function() {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        var previousEventStartTime = currentEventStartTime;\n        currentPriorityLevel = parentPriorityLevel;\n        currentEventStartTime = exports.unstable_now();\n\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n          currentEventStartTime = previousEventStartTime;\n          flushImmediateWork();\n        }\n      };\n    }\n    //yideng 4.根据过期时间进行双向链表的排序\n    function unstable_scheduleCallback(callback, deprecated_options) {\n      var startTime =\n        currentEventStartTime !== -1\n          ? currentEventStartTime\n          : exports.unstable_now();\n\n      var expirationTime;\n      if (\n        typeof deprecated_options === \"object\" &&\n        deprecated_options !== null &&\n        typeof deprecated_options.timeout === \"number\"\n      ) {\n        // FIXME: Remove this branch once we lift expiration times out of React.\n        //如果没有传递过去时间的话直接按照默认的传递\n        expirationTime = startTime + deprecated_options.timeout;\n      } else {\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n          case UserBlockingPriority:\n            expirationTime = startTime + USER_BLOCKING_PRIORITY;\n            break;\n          case IdlePriority:\n            expirationTime = startTime + IDLE_PRIORITY;\n            break;\n          case LowPriority:\n            expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n            break;\n          case NormalPriority:\n          default:\n            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n        }\n      }\n      //yideng 双向的链表\n      var newNode = {\n        callback: callback, //任务具体的内容\n        priorityLevel: currentPriorityLevel, //任务优先级\n        expirationTime: expirationTime, //任务的过期时间\n        next: null, //下一个节点\n        previous: null //上一个节点\n      };\n\n      // Insert the new callback into the list, ordered first by expiration, then\n      // by insertion. So the new callback is inserted any other callback with\n      // equal expiration.\n      //yideng仿照之前的双向节点的例子 插入指定节点\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        //排完顺序之后按照指定的规则执行任务\n        //那么什么是合适的时间呢？也就是之前讨论过的每一帧绘制完成之后的空闲时间\n        //5.排完序了 然后如何执行呢？？？ensureHostCallbackIsScheduled\n        ensureHostCallbackIsScheduled();\n      } else {\n        // 一直查找链表, 直至某个节点的next === firtNode\n        var next = null;\n        var node = firstCallbackNode;\n        do {\n          // 对比过期时间\n          if (node.expirationTime > expirationTime) {\n            // 如果当前节点的过期时间 比 新来的callback 过期时间要晚 , 则将next指向当前的节点\n            // The new callback expires before this one.\n            next = node;\n            break;\n          }\n          node = node.next;\n        } while (node !== firstCallbackNode);\n        \n        // next === null 就表示始终未找到某个节点比新来的回调过期时间要晚, 这就表示他是最晚的, 他是链表的末尾, 所以把他的next指向首节点\n        if (next === null) {\n          // No callback with a later expiration was found, which means the new\n          // callback has the latest expiration in the list.\n          next = firstCallbackNode;\n\n          // next === firstCallbackNode 表示找到符合条件的节点， 但是该节点是首节点， 这就表示 新的回调 比 firtCallbackNode 的优先级还要高的话， 就将他作为\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest expiration in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled();\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n\n      return newNode;\n    }\n\n    function unstable_pauseExecution() {\n      isSchedulerPaused = true;\n    }\n\n    function unstable_continueExecution() {\n      isSchedulerPaused = false;\n      if (firstCallbackNode !== null) {\n        ensureHostCallbackIsScheduled();\n      }\n    }\n\n    function unstable_getFirstCallbackNode() {\n      return firstCallbackNode;\n    }\n\n    function unstable_cancelCallback(callbackNode) {\n      var next = callbackNode.next;\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      callbackNode.next = callbackNode.previous = null;\n    }\n\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n\n    function unstable_shouldYield() {\n      return (\n        !currentDidTimeout &&\n        ((firstCallbackNode !== null &&\n          firstCallbackNode.expirationTime < currentExpirationTime) ||\n          shouldYieldToHost())\n      );\n    }\n\n    // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n    var localDate = Date;\n\n    // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n    var localSetTimeout =\n      typeof setTimeout === \"function\" ? setTimeout : undefined;\n    var localClearTimeout =\n      typeof clearTimeout === \"function\" ? clearTimeout : undefined;\n\n    // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n    var localRequestAnimationFrame =\n      typeof requestAnimationFrame === \"function\"\n        ? requestAnimationFrame\n        : undefined;\n    var localCancelAnimationFrame =\n      typeof cancelAnimationFrame === \"function\"\n        ? cancelAnimationFrame\n        : undefined;\n\n    // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n    // ↑这句话表示，使用setTimeout 也是无奈之举， 之后会更优化， 当下是迫于浏览器不支持\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n    //yideng 如果tab不激活的话 使用SetTimeout进行处理 如果正常情况直接干掉timeout\n    //6.按照每一帧之后的空闲开始进行更新requestAnimationFrameWithTimeout\n    // \n    // 这里又使用了 setTimeout 又使用了RequestAnimationFrame 并且还互相清除， \n    // 是因为 RequestAnimationFrame 有一个落点， 就是当浏览器切到其他tab页的时候会暂停执行\n    var requestAnimationFrameWithTimeout = function(callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function(timestamp) {\n        //每一次系统执行的performance.now 默认间隔是16.7\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function() {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n      exports.unstable_now = function() {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function() {\n        return localDate.now();\n      };\n    }\n\n    var requestHostCallback;\n    var cancelHostCallback;\n    var shouldYieldToHost;\n\n    var globalValue = null;\n    if (typeof window !== \"undefined\") {\n      globalValue = window;\n    } else if (typeof global !== \"undefined\") {\n      globalValue = global;\n    }\n\n    if (globalValue && globalValue._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var globalImpl = globalValue._schedMock;\n      requestHostCallback = globalImpl[0];\n      cancelHostCallback = globalImpl[1];\n      shouldYieldToHost = globalImpl[2];\n      exports.unstable_now = globalImpl[3];\n    } else if (\n      // If Scheduler runs in a non-DOM environment, it falls back to a naive\n      // implementation using setTimeout.\n      typeof window === \"undefined\" ||\n      // Check if MessageChannel is supported, too.\n      typeof MessageChannel !== \"function\"\n    ) {\n      // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n      // fallback to a naive implementation.\n      var _callback = null;\n      var _flushCallback = function(didTimeout) {\n        if (_callback !== null) {\n          try {\n            _callback(didTimeout);\n          } finally {\n            _callback = null;\n          }\n        }\n      };\n      requestHostCallback = function(cb, ms) {\n        if (_callback !== null) {\n          // Protect against re-entrancy.\n          setTimeout(requestHostCallback, 0, cb);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, 0, false);\n        }\n      };\n      cancelHostCallback = function() {\n        _callback = null;\n      };\n      shouldYieldToHost = function() {\n        return false;\n      };\n    } else {\n      if (typeof console !== \"undefined\") {\n        // TODO: Remove fb.me link\n        if (typeof localRequestAnimationFrame !== \"function\") {\n          console.error(\n            \"This browser doesn't support requestAnimationFrame. \" +\n              \"Make sure that you load a \" +\n              \"polyfill in older browsers. https://fb.me/react-polyfills\"\n          );\n        }\n        if (typeof localCancelAnimationFrame !== \"function\") {\n          console.error(\n            \"This browser doesn't support cancelAnimationFrame. \" +\n              \"Make sure that you load a \" +\n              \"polyfill in older browsers. https://fb.me/react-polyfills\"\n          );\n        }\n      }\n\n      var scheduledHostCallback = null; //代表任务链表的执行器\n      var isMessageEventScheduled = false;\n      var timeoutTime = -1; //代表最高优先级任务firstCallbackNode的过期时间\n      var isAnimationFrameScheduled = false;\n      var isFlushingHostCallback = false;\n      var frameDeadline = 0; //代表一帧的过期时间，通过rAF回调入参t加上activeFrameTime来计算\n      // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n      var previousFrameTime = 33; // 一帧的渲染时间33ms，这里假设 1s 30帧\n      var activeFrameTime = 33;\n\n      shouldYieldToHost = function() {\n        return frameDeadline <= exports.unstable_now();\n      };\n\n      // We use the postMessage trick to defer idle work until after the repaint.\n      //如下是整个的执行流程，\n      //8.配合MessageChannel进行具体的调度任务\n      //8-1.在每一帧开始的rAF的回调里记录每一帧的开始时间，并计算每一帧的过期时间，\n      //8-2.通过messageChannel发送消息。在帧末messageChannel的回调里接收消息，\n      //8-3.根据当前帧的过期时间和当前时间进行比对来决定当前帧能否执行任务，\n      //8-4.如果能的话会依次从任务链表里拿出队首任务来执行\n      //8-5.执行尽可能多的任务后如果还有任务，下一帧再重新调度。\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      //下面的代码逻辑决定当前帧要不要执行任务\n      // 1、如果当前帧没过期，说明当前帧有富余时间，可以执行任务\n      // 2、如果当前帧过期了，说明当前帧没有时间了，这里再看一下当前任务firstCallbackNode\n      //是否过期，如果过期了也要执行任务；如果当前任务没过期，说明不着急，那就先不执行去\n      channel.port1.onmessage = function(event) {\n        isMessageEventScheduled = false;\n\n        var prevScheduledCallback = scheduledHostCallback;\n        var prevTimeoutTime = timeoutTime;\n        scheduledHostCallback = null;\n        timeoutTime = -1;\n\n        var currentTime = exports.unstable_now();\n\n        var didTimeout = false;\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            //任务过期\n            didTimeout = true;\n          } else {\n            // No timeout.\n            //当前帧由于浏览器渲染等原因过期了，那就去下一帧再处理\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            }\n            // Exit without invoking the callback.\n            scheduledHostCallback = prevScheduledCallback;\n            timeoutTime = prevTimeoutTime;\n            return;\n          }\n        }\n\n        if (prevScheduledCallback !== null) {\n          isFlushingHostCallback = true;\n          try {\n            prevScheduledCallback(didTimeout);\n          } finally {\n            isFlushingHostCallback = false;\n          }\n        }\n      };\n      //7.animationTick是线索 计算帧过期时间并压缩帧\n      var animationTick = function(rafTime) {\n        if (scheduledHostCallback !== null) {\n          //有任务再进行递归，没任务的话不需要工作\n          // Eagerly schedule the next animation callback at the beginning of the\n          // frame. If the scheduler queue is not empty at the end of the frame, it\n          // will continue flushing inside that callback. If the queue *is* empty,\n          // then it will exit immediately. Posting the callback at the start of the\n          // frame ensures it's fired within the earliest possible frame. If we\n          // waited until the end of the frame to post the callback, we risk the\n          // browser skipping a frame and not firing the callback until the frame\n          // after that.\n          requestAnimationFrameWithTimeout(animationTick);\n        } else {\n          // No pending work. Exit.\n          isAnimationFrameScheduled = false;\n          return;\n        }\n        // rafTime 就是 requestAnimationFrame 回调接收的时间\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n        //用连续的两次时间 被不断的压缩activeFrameTime\n        if (\n          nextFrameTime < activeFrameTime &&\n          previousFrameTime < activeFrameTime\n        ) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame time gets lower than 8, it is probably a bug.\n            nextFrameTime = 8;\n          }\n          // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n          activeFrameTime =\n            nextFrameTime < previousFrameTime\n              ? previousFrameTime\n              : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n        //计算当前帧的截止时间，用开始时间加上每一帧的渲染时间\n        frameDeadline = rafTime + activeFrameTime;\n        if (!isMessageEventScheduled) {\n          isMessageEventScheduled = true;\n          //port2 负责发送数据\n          //port2监听消息的回调来做任务调度的具体工作\n          port.postMessage(undefined);\n        }\n      };\n\n      // 接收两个参数， flushwork 和 过期时间\n      requestHostCallback = function(callback, absoluteTimeout) {\n        scheduledHostCallback = callback;\n        // 过期时间\n        timeoutTime = absoluteTimeout;\n        if (isFlushingHostCallback || absoluteTimeout < 0) {\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          port.postMessage(undefined);\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n\n      cancelHostCallback = function() {\n        scheduledHostCallback = null;\n        isMessageEventScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_next = unstable_next;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n```\n\n\n\n\n\n\n## 双向链表实现\n\n```Js\n// 1.双向链表是指每个节点有previous和next两个属性来分别指向前后两个节点。\n// 2.循环的意思是，最后一个节点的next指向第一个节点，\n// 下面假设有一群人需要按照年龄进行排队，小孩站前边，大人站后边。\n// 在一个过程内会不断有人过来，我们需要把他插到正确的位置。删除的话只考虑每次把排头的人给去掉。\n\n//person的类型定义\ninterface Person {\n  name: string; //姓名\n  age: number; //年龄，依赖这个属性排序\n  next: Person; //紧跟在后面的人,默认是null\n  previous: Person; //前面相邻的那个人,默认是null\n}\nvar firstNode = null; //一开始链表里没有节点\n\n//插入的逻辑\nfunction insertByAge(newPerson: Person) {\n  if ((firstNode = null)) {\n    //如果 firstNode为空，说明newPerson是第一个人，\n    //把它赋值给firstNode，并把next和previous属性指向自身，自成一个环。\n    firstNode = newPerson.next = newPerson.previous = newPerson;\n  } else {\n    //队伍里有人了，新来的人要找准自己的位置\n\n    var next = null; //记录newPerson插入到哪个人前边\n    var person = firstNode; // person 在下边的循环中会从第一个人开始往后找\n\n    do {\n      if (person.age > newPerson.age) {\n        //如果person的年龄比新来的人大，说明新来的人找到位置了，他恰好要排在person的前边，结束\n        next = person;\n        break;\n      }\n      //继续找后面的人\n      node = node.next;\n    } while (node !== firstNode); //这里的while是为了防止无限循环，毕竟是环形的结构\n\n    if (next === null) {\n      //找了一圈发现 没有person的age比newPerson大，说明newPerson应该放到队伍的最后,也就是说newPerson的后面应该是firstNode。\n      next = firstNode;\n    } else if (next === firstNode) {\n      //找第一个的时候就找到next了，说明newPerson要放到firstNode前面，这时候firstNode就要更新为newPerson\n      firstNode = newPerson;\n    }\n\n    //下面是newPerson的插入操作，给next及previous两个人的前后链接都关联到newPerson\n    var previous = next.previous;\n    previous.next = next.previous = newPerson;\n    newPerson.next = next;\n    newPerson.previous = previous;\n  }\n  //插入成功\n}\n\n//删除第一个节点\nfunction deleteFirstPerson() {\n  if (firstNode === null) return; //队伍里没有人，返回\n\n  var next = firstNode.next; //第二个人\n  if (firstNode === next) {\n    //这时候只有一个人\n    firstNode = null;\n    next = null;\n  } else {\n    var lastPerson = firstNode.previous; //找到最后一个人\n    firstNode = lastPerson.next = next; //更新新的第一人\n    next.previout = lastPerson; //并在新的第一人和最后一人之间建立连接\n  }\n}\n\n```\n\n\n\n","slug":"【React】Fiber架构","published":1,"updated":"2019-09-09T16:57:46.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0ksf52000hcaas6lusoddxn"}],"PostAsset":[],"PostCategory":[{"post_id":"ck0ksf4rt0002aas6ddsw20fg","category_id":"ck0ksf4ry0004aas60mpqfh19","_id":"ck0ksf4s4000daas6yea7slpz"},{"post_id":"ck0ksf4rw0003aas6mruvsvmz","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4s8000jaas6e0ylwnsw"},{"post_id":"ck0ksf4rz0006aas6wnut34hb","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4sa000oaas69smciym7"},{"post_id":"ck0ksf4s00007aas6iwvwnf0i","category_id":"ck0ksf4s8000iaas6akpbet8q","_id":"ck0ksf4sd000waas6c2f7v17s"},{"post_id":"ck0ksf4sb000saas61s4lj2up","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4sf0011aas6pyojooh5"},{"post_id":"ck0ksf4s10008aas61n3oqry5","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4sg0016aas6ihkzfez4"},{"post_id":"ck0ksf4sc000uaas6huzvimqb","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4sh0019aas6l1q0qwb7"},{"post_id":"ck0ksf4s2000baas68tawhxbj","category_id":"ck0ksf4sd000vaas6he2ob4vt","_id":"ck0ksf4si001caas6sbqck9qq"},{"post_id":"ck0ksf4sh0018aas6n9i0iuab","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4sk001jaas65sr5s6dy"},{"post_id":"ck0ksf4s3000caas6ydookfif","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4sm001oaas6flgb4uc7"},{"post_id":"ck0ksf4sh001baas6851gy5dh","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4sn001raas6ago0m1me"},{"post_id":"ck0ksf4si001gaas62x4cuqop","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4sp001waas64qbrtqcn"},{"post_id":"ck0ksf4s6000gaas6j2dcog4k","category_id":"ck0ksf4si001daas6zsrdcnxt","_id":"ck0ksf4sq001zaas6jgmhqfci"},{"post_id":"ck0ksf4sj001iaas60t6424dg","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4sr0024aas6qio3giwe"},{"post_id":"ck0ksf4sl001naas6mimk3kkn","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4ss0027aas6bj361pn1"},{"post_id":"ck0ksf4s7000haas6g99q9ywe","category_id":"ck0ksf4si001daas6zsrdcnxt","_id":"ck0ksf4st002caas6dkln2juj"},{"post_id":"ck0ksf4sn001qaas6ml33s9dg","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4sv002eaas6e5tt0x5v"},{"post_id":"ck0ksf4s9000laas6s8scbm05","category_id":"ck0ksf4si001daas6zsrdcnxt","_id":"ck0ksf4sw002haas6z971nt93"},{"post_id":"ck0ksf4s9000naas6f32vivyf","category_id":"ck0ksf4sq0020aas6bv0on24n","_id":"ck0ksf4sx002laas6rtbha4lf"},{"post_id":"ck0ksf4sd000yaas61lhfyy8t","category_id":"ck0ksf4ss0028aas6ynfoashn","_id":"ck0ksf4sz002paas60jpu2znj"},{"post_id":"ck0ksf4su002daas6y98ngzgg","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4t0002taas6xcdvq33p"},{"post_id":"ck0ksf4sf0010aas6upya3h1d","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4t1002xaas6gq6p6qzd"},{"post_id":"ck0ksf4sg0015aas6h295emh7","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4t20031aas6vc5ulmpm"},{"post_id":"ck0ksf4so001vaas6mtn3oi95","category_id":"ck0ksf4t0002vaas6iit7fuot","_id":"ck0ksf4t50039aas6ynlypbuu"},{"post_id":"ck0ksf4sq001yaas6oasfnd9e","category_id":"ck0ksf4t0002vaas6iit7fuot","_id":"ck0ksf4t8003faas6dpjk7h6o"},{"post_id":"ck0ksf4sr0023aas6q8fj32ze","category_id":"ck0ksf4t50038aas6l9rzv4dm","_id":"ck0ksf4ta003maas6p3qywq9h"},{"post_id":"ck0ksf4ss0026aas6ivro5fc5","category_id":"ck0ksf4t50038aas6l9rzv4dm","_id":"ck0ksf4td003raas6vev5smdh"},{"post_id":"ck0ksf4st002baas6ns1zj87k","category_id":"ck0ksf4t50038aas6l9rzv4dm","_id":"ck0ksf4tg003waas6e4eyyxui"},{"post_id":"ck0ksf4sv002gaas64hc6o073","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4ti0043aas6j1jd1aus"},{"post_id":"ck0ksf4sx002kaas6p3ykl5gz","category_id":"ck0ksf4tg003xaas6txy9k12f","_id":"ck0ksf4tl004baas6gfuudm0d"},{"post_id":"ck0ksf4sy002oaas67xv6izcz","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4tq004iaas6an1n2cjn"},{"post_id":"ck0ksf4sz002saas6dwbbzhfb","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4tt004naas6b1d0lnu7"},{"post_id":"ck0ksf4t0002waas6nma7fj1c","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4tv004uaas651jae8xi"},{"post_id":"ck0ksf4tt004paas6oqi1vgb2","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4u0004xaas6gwsp4fwi"},{"post_id":"ck0ksf4t10030aas6ycyglkjx","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4u10051aas6b5h20cth"},{"post_id":"ck0ksf4tv004vaas68e7g35vv","category_id":"ck0ksf4sd000vaas6he2ob4vt","_id":"ck0ksf4u20054aas6epeo0jej"},{"post_id":"ck0ksf4t20032aas6yvve7d90","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4u30059aas6bficto3t"},{"post_id":"ck0ksf4t40035aas6cdvg674b","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4u5005eaas679k46w1m"},{"post_id":"ck0ksf4u20053aas6n82w4d4g","category_id":"ck0ksf4sd000vaas6he2ob4vt","_id":"ck0ksf4u6005iaas6fdhqw1f0"},{"post_id":"ck0ksf4t40037aas6cv1a7n20","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4u7005laas6919ulg8z"},{"post_id":"ck0ksf4u4005baas623gvmjnc","category_id":"ck0ksf4sd000vaas6he2ob4vt","_id":"ck0ksf4u8005oaas6xhpv4ed7"},{"post_id":"ck0ksf4t6003caas6rygmb2yr","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4u8005raas625v7tkzg"},{"post_id":"ck0ksf4t7003eaas6167org9g","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4ua005xaas6qp841eew"},{"post_id":"ck0ksf4t9003iaas6uyv39x01","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4uc0064aas65o0t5z18"},{"post_id":"ck0ksf4ta003kaas6ch88mkce","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4ud006aaas6o5za5fne"},{"post_id":"ck0ksf4tb003oaas6u1gan6jf","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4uf006faas6a070g6y8"},{"post_id":"ck0ksf4tc003paas67yq3p472","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf4ug006kaas6syo6zq2n"},{"post_id":"ck0ksf4td003saas6s00h0c63","category_id":"ck0ksf4uf006eaas682aplvb3","_id":"ck0ksf4ui006saas6i3tvsmfq"},{"post_id":"ck0ksf4te003vaas6sx4y1bmr","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4uk0070aas6o525er8i"},{"post_id":"ck0ksf4tg003zaas6ihgpqghl","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4un0075aas69h49tpjr"},{"post_id":"ck0ksf4th0041aas6fas4kawz","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4up007aaas6z4vx2u59"},{"post_id":"ck0ksf4ti0045aas6w82snmc7","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4ur007haas6a3904snh"},{"post_id":"ck0ksf4tk0048aas60stvkzgi","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4ut007maas6bsqt6qz3"},{"post_id":"ck0ksf4tm004caas6gpjjh4t9","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4uv007taas6ti6wxx1x"},{"post_id":"ck0ksf4tn004faas6x30sp4ar","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4ux007yaas6q19ci885"},{"post_id":"ck0ksf4uw007uaas69142vovg","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4uz0084aas61ittrbjf"},{"post_id":"ck0ksf4tq004jaas6hev0fztx","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4v00088aas6mm58zeje"},{"post_id":"ck0ksf4uw007waas6k5wif71m","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4v1008caas6f3t85fq4"},{"post_id":"ck0ksf4ux0080aas65ca5yof2","category_id":"ck0ksf4s10009aas6sf4bxfqb","_id":"ck0ksf4v2008gaas6u27omumy"},{"post_id":"ck0ksf4tr004kaas6d0fzuyai","category_id":"ck0ksf4ux007xaas6rshpf35s","_id":"ck0ksf4v3008kaas6ye8oa9vo"},{"post_id":"ck0ksf4tu004raas65nql53rn","category_id":"ck0ksf4v00086aas6mxnwtfa0","_id":"ck0ksf4v5008oaas69q11fexc"},{"post_id":"ck0ksf4v1008baas6kh8opj74","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4v6008saas6huzbik3l"},{"post_id":"ck0ksf4u10050aas6m1ufc2ij","category_id":"ck0ksf4v00086aas6mxnwtfa0","_id":"ck0ksf4v7008vaas6vxf8f3aa"},{"post_id":"ck0ksf4v3008jaas6vfjadeqv","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4v8008yaas68adz990k"},{"post_id":"ck0ksf4v4008naas6ig9h8log","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4v90092aas6fi3eh5wd"},{"post_id":"ck0ksf4u30058aas6cyq06c0p","category_id":"ck0ksf4v4008maas6lksy06kr","_id":"ck0ksf4va0096aas6qsfvms5v"},{"post_id":"ck0ksf4u5005gaas6qey7129b","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4vb009aaas61igwoc7m"},{"post_id":"ck0ksf4v90095aas6s81hq6g7","category_id":"ck0ksf4sq0020aas6bv0on24n","_id":"ck0ksf4vc009daas6yezfcqba"},{"post_id":"ck0ksf4u6005jaas67e4b92te","category_id":"ck0ksf4v4008maas6lksy06kr","_id":"ck0ksf4vc009gaas6i1kkuabi"},{"post_id":"ck0ksf4u7005maas6613s4d35","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4vd009kaas6cdnsgpg8"},{"post_id":"ck0ksf4u8005paas650hrm8go","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4ve009oaas6hbse1tq9"},{"post_id":"ck0ksf4u9005saas6jjy6lo1i","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4vf009saas6sg1unjz0"},{"post_id":"ck0ksf4u9005uaas6nco4j6l4","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4vg009waas66s7yy4c9"},{"post_id":"ck0ksf4ua005yaas60oyvaav0","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4vg00a0aas67kk9nl1p"},{"post_id":"ck0ksf4ub0061aas6ju96sxme","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4vh00a4aas6t0jstof4"},{"post_id":"ck0ksf4uc0065aas65dbziali","category_id":"ck0ksf4v4008maas6lksy06kr","_id":"ck0ksf4vi00a7aas6x5t6pvtu"},{"post_id":"ck0ksf4ud0068aas6uslvswul","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4vi00aaaas6c2ck7pd3"},{"post_id":"ck0ksf4ud006baas6hepva46l","category_id":"ck0ksf4v7008waas6t4969wxj","_id":"ck0ksf4vi00aeaas6u2jt1qak"},{"post_id":"ck0ksf4ue006daas6sw27cq9h","category_id":"ck0ksf4vi00a9aas6qsqf9roh","_id":"ck0ksf4vj00ajaas6vyblfi2z"},{"post_id":"ck0ksf4uf006gaas603mmcarl","category_id":"ck0ksf4vi00a9aas6qsqf9roh","_id":"ck0ksf4vk00aoaas6n3kik17t"},{"post_id":"ck0ksf4uf006iaas6rnpmsklo","category_id":"ck0ksf4vi00a9aas6qsqf9roh","_id":"ck0ksf4vk00araas6mbqjee5t"},{"post_id":"ck0ksf4ug006laas67te39zbr","category_id":"ck0ksf4v4008maas6lksy06kr","_id":"ck0ksf4vl00awaas67xosykal"},{"post_id":"ck0ksf4uh006oaas6gvb46viy","category_id":"ck0ksf4vi00a9aas6qsqf9roh","_id":"ck0ksf4vm00azaas6lrmpy8lr"},{"post_id":"ck0ksf4ui006raas6ufx9xe0t","category_id":"ck0ksf4vi00a9aas6qsqf9roh","_id":"ck0ksf4vm00b3aas6d6trgdup"},{"post_id":"ck0ksf4ui006vaas6m31pdq8p","category_id":"ck0ksf4vm00ayaas6y07l5lm2","_id":"ck0ksf4vn00b6aas62l8uv7wj"},{"post_id":"ck0ksf4uj006xaas6a56x5jen","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vn00bcaas6i8xdm9fe"},{"post_id":"ck0ksf4ul0071aas61jljp47l","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vo00bgaas6jp9mi5ke"},{"post_id":"ck0ksf4un0073aas6w8qqfvfv","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vp00bkaas6e3bzlsoe"},{"post_id":"ck0ksf4un0076aas6r5tbgrgk","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vp00boaas6y9vsk3tc"},{"post_id":"ck0ksf4uo0078aas6es2mbd6c","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vq00bsaas69hw06hv2"},{"post_id":"ck0ksf4up007caas65dgd6ppq","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vq00bvaas6547452hg"},{"post_id":"ck0ksf4uq007faas608ezxey3","category_id":"ck0ksf4vq00braas6oidpkeqw","_id":"ck0ksf4vr00c0aas61whyjgxs"},{"post_id":"ck0ksf4us007iaas6dolddlkx","category_id":"ck0ksf4vq00braas6oidpkeqw","_id":"ck0ksf4vs00c4aas6vfpi2k63"},{"post_id":"ck0ksf4us007kaas6rkbfhtu6","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vt00c9aas6u3gt0jxc"},{"post_id":"ck0ksf4uu007oaas60jebvur8","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vt00cbaas6mjwt469a"},{"post_id":"ck0ksf4uy0083aas6hqjryxqu","category_id":"ck0ksf4vs00c8aas6wy3drk0y","_id":"ck0ksf4vt00cfaas6gomohjju"},{"post_id":"ck0ksf4v00087aas67spm0ve5","category_id":"ck0ksf4vm00b4aas61eqq98tw","_id":"ck0ksf4vu00ckaas65akyzbk9"},{"post_id":"ck0ksf4v2008faas6542d3u7g","category_id":"ck0ksf4vi00a9aas6qsqf9roh","_id":"ck0ksf4vu00coaas6c9op9joj"},{"post_id":"ck0ksf4v6008raas6shjzvyr8","category_id":"ck0ksf4vu00cjaas6l327plt4","_id":"ck0ksf4vv00cvaas65vl5bdo7"},{"post_id":"ck0ksf4v7008uaas67s21usea","category_id":"ck0ksf4vq00braas6oidpkeqw","_id":"ck0ksf4vw00d0aas66s0ux5cb"},{"post_id":"ck0ksf4v7008xaas6sjxpmqwf","category_id":"ck0ksf4vq00braas6oidpkeqw","_id":"ck0ksf4vw00d4aas610egp3pm"},{"post_id":"ck0ksf4v90091aas6mg4jkx4r","category_id":"ck0ksf4vw00czaas6482kh5jx","_id":"ck0ksf4vx00d7aas6e4kno8zt"},{"post_id":"ck0ksf4va0098aas658fdspzf","category_id":"ck0ksf4vw00d5aas6e81zx2te","_id":"ck0ksf4vy00dbaas6k0upddox"},{"post_id":"ck0ksf4wy00g5aas62jobfnfk","category_id":"ck0ksf4sf0013aas6yi8l4tft","_id":"ck0ksf4x100geaas611bfyezy"},{"post_id":"ck0ksf4x100gdaas6r6i12ide","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4x400gmaas66kdksfs5"},{"post_id":"ck0ksf4x200gfaas6yokz6f26","category_id":"ck0ksf4uh006maas6ps8z9tzn","_id":"ck0ksf4x500goaas6kgmnt44x"},{"post_id":"ck0ksf4wz00g7aas6h3yo5pn2","category_id":"ck0ksf4x100gbaas6n7d9fh3b","_id":"ck0ksf4x600gsaas6q7knxuju"},{"post_id":"ck0ksf4x400glaas6qi3d5h58","category_id":"ck0ksf4sq0020aas6bv0on24n","_id":"ck0ksf4x600guaas61t78a2u0"},{"post_id":"ck0ksf4x000gaaas6xvlhthpm","category_id":"ck0ksf4x100gbaas6n7d9fh3b","_id":"ck0ksf4x600gxaas6lxfiuscw"},{"post_id":"ck0ksf4x300ghaas6hlv3p4ks","category_id":"ck0ksf4x500gpaas6i3jjby31","_id":"ck0ksf4x600gzaas6rw7tkqac"},{"post_id":"ck0ksf50y00h9aas6sj2ll0dm","category_id":"ck0ksf4si001daas6zsrdcnxt","_id":"ck0ksf50z00hbaas6wyvml39n"},{"post_id":"ck0ksf52000hcaas6lusoddxn","category_id":"ck0ksf4td003qaas6czdemsr3","_id":"ck0ksf52100heaas68oxeyhis"}],"PostTag":[{"post_id":"ck0ksf4rt0002aas6ddsw20fg","tag_id":"ck0ksf4rz0005aas69rwj5tpi","_id":"ck0ksf4s9000maas60y10ljeq"},{"post_id":"ck0ksf4rt0002aas6ddsw20fg","tag_id":"ck0ksf4s1000aaas6fo40dknf","_id":"ck0ksf4sa000paas6vyq7u5k8"},{"post_id":"ck0ksf4rt0002aas6ddsw20fg","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4sb000taas672iyoz8i"},{"post_id":"ck0ksf4rw0003aas6mruvsvmz","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4se000zaas6q9urst4g"},{"post_id":"ck0ksf4rw0003aas6mruvsvmz","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4sf0012aas69z1t2ozr"},{"post_id":"ck0ksf4sf0010aas6upya3h1d","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4sg0017aas6etb8w8i1"},{"post_id":"ck0ksf4sg0015aas6h295emh7","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4sh001aaas64fakvvpm"},{"post_id":"ck0ksf4sh0018aas6n9i0iuab","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4si001faas6e97duxxm"},{"post_id":"ck0ksf4rz0006aas6wnut34hb","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4sj001haas6e89ygyej"},{"post_id":"ck0ksf4rz0006aas6wnut34hb","tag_id":"ck0ksf4sf0014aas6ybxa533m","_id":"ck0ksf4sl001maas6gq5tu4iy"},{"post_id":"ck0ksf4si001gaas62x4cuqop","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4sm001paas6lgvjwc1o"},{"post_id":"ck0ksf4s00007aas6iwvwnf0i","tag_id":"ck0ksf4si001eaas6dm0ikyyi","_id":"ck0ksf4so001uaas6oc1jr6h6"},{"post_id":"ck0ksf4sj001iaas60t6424dg","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4sp001xaas6ek5k8bjv"},{"post_id":"ck0ksf4sl001naas6mimk3kkn","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4sr0022aas64uxhco9f"},{"post_id":"ck0ksf4s10008aas61n3oqry5","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4ss0025aas6klegdkn4"},{"post_id":"ck0ksf4s10008aas61n3oqry5","tag_id":"ck0ksf4so001taas663vn10g8","_id":"ck0ksf4st0029aas6vvnjv7np"},{"post_id":"ck0ksf4su002daas6y98ngzgg","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4sw002jaas6mjc60sj1"},{"post_id":"ck0ksf4su002daas6y98ngzgg","tag_id":"ck0ksf4so001taas663vn10g8","_id":"ck0ksf4sy002maas6qffklw7v"},{"post_id":"ck0ksf4s2000baas68tawhxbj","tag_id":"ck0ksf4sr0021aas6kauew9g8","_id":"ck0ksf4sz002raas65qmioz9f"},{"post_id":"ck0ksf4s2000baas68tawhxbj","tag_id":"ck0ksf4st002aaas68xnixkll","_id":"ck0ksf4t0002uaas6vsy00ulv"},{"post_id":"ck0ksf4s3000caas6ydookfif","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4t1002zaas6rltyvlc4"},{"post_id":"ck0ksf4s6000gaas6j2dcog4k","tag_id":"ck0ksf4sz002qaas62s9ccbix","_id":"ck0ksf4t40036aas6fh6z9fqs"},{"post_id":"ck0ksf4s6000gaas6j2dcog4k","tag_id":"ck0ksf4t1002yaas6mtlsldxz","_id":"ck0ksf4t5003aaas6h51o4e0f"},{"post_id":"ck0ksf4s7000haas6g99q9ywe","tag_id":"ck0ksf4t1002yaas6mtlsldxz","_id":"ck0ksf4t7003daas6kiyjedmz"},{"post_id":"ck0ksf4s9000laas6s8scbm05","tag_id":"ck0ksf4t1002yaas6mtlsldxz","_id":"ck0ksf4t9003jaas6loqval0y"},{"post_id":"ck0ksf4s9000naas6f32vivyf","tag_id":"ck0ksf4t8003haas6lvypad80","_id":"ck0ksf4te003uaas63p3qctgw"},{"post_id":"ck0ksf4s9000naas6f32vivyf","tag_id":"ck0ksf4tb003naas6thdpjhlv","_id":"ck0ksf4tg003yaas64iidi9vc"},{"post_id":"ck0ksf4sb000saas61s4lj2up","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4ti0042aas6304dcsnx"},{"post_id":"ck0ksf4sb000saas61s4lj2up","tag_id":"ck0ksf4te003taas6rm27q44a","_id":"ck0ksf4tj0046aas69cmcvvqg"},{"post_id":"ck0ksf4sc000uaas6huzvimqb","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4tl0049aas6r3p1hmf1"},{"post_id":"ck0ksf4sc000uaas6huzvimqb","tag_id":"ck0ksf4th0040aas6n8cr1eh0","_id":"ck0ksf4tn004daas65x9s5ku5"},{"post_id":"ck0ksf4sd000yaas61lhfyy8t","tag_id":"ck0ksf4tk0047aas69mubvv6x","_id":"ck0ksf4tp004gaas6uh1j8cuv"},{"post_id":"ck0ksf4sh001baas6851gy5dh","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4tt004oaas6jzls9ztj"},{"post_id":"ck0ksf4sh001baas6851gy5dh","tag_id":"ck0ksf4tn004eaas6zabrlawp","_id":"ck0ksf4tu004qaas62ouufi0v"},{"post_id":"ck0ksf4sn001qaas6ml33s9dg","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4u10052aas68gn3pyew"},{"post_id":"ck0ksf4sn001qaas6ml33s9dg","tag_id":"ck0ksf4ts004laas60gnt32vb","_id":"ck0ksf4u20055aas6ziyabbbx"},{"post_id":"ck0ksf4sn001qaas6ml33s9dg","tag_id":"ck0ksf4tu004saas6wjv071gk","_id":"ck0ksf4u4005aaas6mhs0x0k5"},{"post_id":"ck0ksf4so001vaas6mtn3oi95","tag_id":"ck0ksf4u0004yaas6zcmrrpp4","_id":"ck0ksf4u4005caas668nj5rs1"},{"post_id":"ck0ksf4sq001yaas6oasfnd9e","tag_id":"ck0ksf4u0004yaas6zcmrrpp4","_id":"ck0ksf4u6005haas6tswup2jr"},{"post_id":"ck0ksf4sr0023aas6q8fj32ze","tag_id":"ck0ksf4u5005faas6wz0w7gfr","_id":"ck0ksf4ua005vaas64jdnrn2m"},{"post_id":"ck0ksf4sr0023aas6q8fj32ze","tag_id":"ck0ksf4u7005naas6ji1nznsq","_id":"ck0ksf4ub005zaas6reyms67w"},{"post_id":"ck0ksf4ss0026aas6ivro5fc5","tag_id":"ck0ksf4u5005faas6wz0w7gfr","_id":"ck0ksf4uc0062aas6w92o0h1f"},{"post_id":"ck0ksf4ss0026aas6ivro5fc5","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4ud0066aas6fy9ar0rj"},{"post_id":"ck0ksf4st002baas6ns1zj87k","tag_id":"ck0ksf4u5005faas6wz0w7gfr","_id":"ck0ksf4ug006jaas6b71h26iv"},{"post_id":"ck0ksf4st002baas6ns1zj87k","tag_id":"ck0ksf4ud0067aas6hh9wkn1a","_id":"ck0ksf4uh006naas6k9m0ao2j"},{"post_id":"ck0ksf4st002baas6ns1zj87k","tag_id":"ck0ksf4ue006caas67f4zz2f8","_id":"ck0ksf4uh006qaas6lddl5rio"},{"post_id":"ck0ksf4sv002gaas64hc6o073","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4ui006uaas6wo322ypx"},{"post_id":"ck0ksf4sx002kaas6p3ykl5gz","tag_id":"ck0ksf4uh006paas67fg9q7xn","_id":"ck0ksf4uk006yaas6j1q7i7gp"},{"post_id":"ck0ksf4sy002oaas67xv6izcz","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4up007baas6omm4zx5w"},{"post_id":"ck0ksf4sy002oaas67xv6izcz","tag_id":"ck0ksf4um0072aas657fb7mqa","_id":"ck0ksf4uq007daas65x1ugdtf"},{"post_id":"ck0ksf4sz002saas6dwbbzhfb","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4ut007naas6uo67zmfg"},{"post_id":"ck0ksf4sz002saas6dwbbzhfb","tag_id":"ck0ksf4um0072aas657fb7mqa","_id":"ck0ksf4uu007paas65cvv7dr7"},{"post_id":"ck0ksf4t0002waas6nma7fj1c","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4ux007zaas65qavs8f1"},{"post_id":"ck0ksf4t0002waas6nma7fj1c","tag_id":"ck0ksf4um0072aas657fb7mqa","_id":"ck0ksf4uy0081aas6fckk496w"},{"post_id":"ck0ksf4uw007uaas69142vovg","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4v00085aas61i5dnssx"},{"post_id":"ck0ksf4uw007waas6k5wif71m","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4v10089aas6574b2oxh"},{"post_id":"ck0ksf4t10030aas6ycyglkjx","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4v2008daas6tyfi5hmb"},{"post_id":"ck0ksf4ux0080aas65ca5yof2","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4v2008haas68xfhx4q6"},{"post_id":"ck0ksf4t20032aas6yvve7d90","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4v4008laas6skkvjadw"},{"post_id":"ck0ksf4t20032aas6yvve7d90","tag_id":"ck0ksf4v1008aaas6u6rs2de7","_id":"ck0ksf4v6008paas67p90piqr"},{"post_id":"ck0ksf4v4008naas6ig9h8log","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4v7008taas6sgg4lvpt"},{"post_id":"ck0ksf4t40035aas6cdvg674b","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4v80090aas635y2d9n9"},{"post_id":"ck0ksf4t40035aas6cdvg674b","tag_id":"ck0ksf4v6008qaas6zlf1y8f6","_id":"ck0ksf4v90094aas625w8hsph"},{"post_id":"ck0ksf4t40037aas6cv1a7n20","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4vc009caas6803yu2x5"},{"post_id":"ck0ksf4t40037aas6cv1a7n20","tag_id":"ck0ksf4um0072aas657fb7mqa","_id":"ck0ksf4vc009faas6xmzoqqth"},{"post_id":"ck0ksf4t6003caas6rygmb2yr","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4vd009iaas6r42dg71i"},{"post_id":"ck0ksf4t7003eaas6167org9g","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4ve009maas6p1b9xazp"},{"post_id":"ck0ksf4t9003iaas6uyv39x01","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4vf009qaas65wyelizl"},{"post_id":"ck0ksf4ta003kaas6ch88mkce","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4vf009uaas6ger2ya7k"},{"post_id":"ck0ksf4tb003oaas6u1gan6jf","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4vg009yaas6acn80ziq"},{"post_id":"ck0ksf4tc003paas67yq3p472","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf4vh00a2aas60isu309e"},{"post_id":"ck0ksf4td003saas6s00h0c63","tag_id":"ck0ksf4vh00a1aas6qcpnxizv","_id":"ck0ksf4vi00abaas62qrj5pxr"},{"post_id":"ck0ksf4td003saas6s00h0c63","tag_id":"ck0ksf4vh00a5aas6vuennnaq","_id":"ck0ksf4vi00acaas6c4kpa7cl"},{"post_id":"ck0ksf4td003saas6s00h0c63","tag_id":"ck0ksf4t1002yaas6mtlsldxz","_id":"ck0ksf4vi00afaas6goz92v0r"},{"post_id":"ck0ksf4te003vaas6sx4y1bmr","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4vj00akaas61adjfi0d"},{"post_id":"ck0ksf4te003vaas6sx4y1bmr","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4vj00alaas6s4oo59n2"},{"post_id":"ck0ksf4tg003zaas6ihgpqghl","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4vl00asaas6caoaxxg5"},{"post_id":"ck0ksf4tg003zaas6ihgpqghl","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4vl00ataas6x17loyxm"},{"post_id":"ck0ksf4th0041aas6fas4kawz","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4vm00b0aas6u82a9ivx"},{"post_id":"ck0ksf4th0041aas6fas4kawz","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4vm00b1aas68wg9089l"},{"post_id":"ck0ksf4ti0045aas6w82snmc7","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4vn00b7aas6rcod3au5"},{"post_id":"ck0ksf4ti0045aas6w82snmc7","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4vn00b9aas6g3s5juab"},{"post_id":"ck0ksf4tk0048aas60stvkzgi","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4vo00beaas6nsx99snc"},{"post_id":"ck0ksf4tk0048aas60stvkzgi","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4vo00bhaas6yh66z9rm"},{"post_id":"ck0ksf4tm004caas6gpjjh4t9","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4vp00bmaas63wgjcs2w"},{"post_id":"ck0ksf4tm004caas6gpjjh4t9","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4vq00bpaas6w74qg9dk"},{"post_id":"ck0ksf4tn004faas6x30sp4ar","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4vq00buaas6zmia4b8f"},{"post_id":"ck0ksf4tn004faas6x30sp4ar","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4vr00bxaas6rodt2l36"},{"post_id":"ck0ksf4tq004jaas6hev0fztx","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4vs00c2aas67hzn4ree"},{"post_id":"ck0ksf4tq004jaas6hev0fztx","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4vs00c5aas6xrfp04ih"},{"post_id":"ck0ksf4tr004kaas6d0fzuyai","tag_id":"ck0ksf4vr00c1aas6isfl4udk","_id":"ck0ksf4vs00c7aas6qo1u3h0l"},{"post_id":"ck0ksf4tt004paas6oqi1vgb2","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4vt00cgaas6celz35ru"},{"post_id":"ck0ksf4tt004paas6oqi1vgb2","tag_id":"ck0ksf4vs00c6aas69oxnfj4f","_id":"ck0ksf4vu00chaas64rim5o5c"},{"post_id":"ck0ksf4tt004paas6oqi1vgb2","tag_id":"ck0ksf4vt00caaas6i9n9fpim","_id":"ck0ksf4vu00claas6vjs0p9j7"},{"post_id":"ck0ksf4tu004raas65nql53rn","tag_id":"ck0ksf4vt00cdaas6l9zxhpqa","_id":"ck0ksf4vu00cmaas6pjawnq2i"},{"post_id":"ck0ksf4tu004raas65nql53rn","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4vv00cpaas6dnc2suuy"},{"post_id":"ck0ksf4tv004vaas68e7g35vv","tag_id":"ck0ksf4vu00ciaas60i4cnwjn","_id":"ck0ksf4vv00craas6xgyyjdbp"},{"post_id":"ck0ksf4tv004vaas68e7g35vv","tag_id":"ck0ksf4st002aaas68xnixkll","_id":"ck0ksf4vv00ctaas65jd2mf76"},{"post_id":"ck0ksf4u10050aas6m1ufc2ij","tag_id":"ck0ksf4vt00cdaas6l9zxhpqa","_id":"ck0ksf4vw00cwaas6ov8yxw6o"},{"post_id":"ck0ksf4u10050aas6m1ufc2ij","tag_id":"ck0ksf4s4000faas6gvd8he92","_id":"ck0ksf4vw00cyaas69b2fg2xh"},{"post_id":"ck0ksf4u20053aas6n82w4d4g","tag_id":"ck0ksf4vu00ciaas60i4cnwjn","_id":"ck0ksf4vw00d1aas6gndmxd3m"},{"post_id":"ck0ksf4u20053aas6n82w4d4g","tag_id":"ck0ksf4st002aaas68xnixkll","_id":"ck0ksf4vw00d3aas64xeh7i1a"},{"post_id":"ck0ksf4u30058aas6cyq06c0p","tag_id":"ck0ksf4vw00cxaas66ok75uah","_id":"ck0ksf4vx00d8aas6mge2h4mp"},{"post_id":"ck0ksf4u30058aas6cyq06c0p","tag_id":"ck0ksf4vw00d2aas6rwfykyz9","_id":"ck0ksf4vx00d9aas6rucr467i"},{"post_id":"ck0ksf4u4005baas623gvmjnc","tag_id":"ck0ksf4vu00ciaas60i4cnwjn","_id":"ck0ksf4vy00dcaas660zmjl3l"},{"post_id":"ck0ksf4u4005baas623gvmjnc","tag_id":"ck0ksf4st002aaas68xnixkll","_id":"ck0ksf4vy00ddaas6qs54aozh"},{"post_id":"ck0ksf4u5005gaas6qey7129b","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4vy00dfaas6vw9sj80m"},{"post_id":"ck0ksf4u6005jaas67e4b92te","tag_id":"ck0ksf4vy00deaas6gpdb4ea3","_id":"ck0ksf4vz00djaas63avrc10f"},{"post_id":"ck0ksf4u6005jaas67e4b92te","tag_id":"ck0ksf4vw00d2aas6rwfykyz9","_id":"ck0ksf4vz00dkaas61aonjwuw"},{"post_id":"ck0ksf4u6005jaas67e4b92te","tag_id":"ck0ksf4vy00dhaas6wb5zld58","_id":"ck0ksf4vz00dmaas6ua55zzyt"},{"post_id":"ck0ksf4u7005maas6613s4d35","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4vz00dnaas6iktp0p69"},{"post_id":"ck0ksf4u8005paas650hrm8go","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4w000dpaas6h7hmc2db"},{"post_id":"ck0ksf4u9005saas6jjy6lo1i","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4w000draas6sfmpuayh"},{"post_id":"ck0ksf4u9005uaas6nco4j6l4","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4w100dtaas6bhrbi3in"},{"post_id":"ck0ksf4ua005yaas60oyvaav0","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4w100dvaas6dzldgqjs"},{"post_id":"ck0ksf4ub0061aas6ju96sxme","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4w100dxaas6pdvtxiyo"},{"post_id":"ck0ksf4uc0065aas65dbziali","tag_id":"ck0ksf4vw00cxaas66ok75uah","_id":"ck0ksf4w200e0aas65fvujuo5"},{"post_id":"ck0ksf4uc0065aas65dbziali","tag_id":"ck0ksf4vw00d2aas6rwfykyz9","_id":"ck0ksf4w200e1aas6t1mcv47a"},{"post_id":"ck0ksf4ud0068aas6uslvswul","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4w200e3aas61zfq452s"},{"post_id":"ck0ksf4ud006baas6hepva46l","tag_id":"ck0ksf4vx00daaas6o03n8jy9","_id":"ck0ksf4w300e5aas6qgo8lno1"},{"post_id":"ck0ksf4ue006daas6sw27cq9h","tag_id":"ck0ksf4w200e4aas6gi02amfc","_id":"ck0ksf4w300e7aas6nimgo75u"},{"post_id":"ck0ksf4uf006gaas603mmcarl","tag_id":"ck0ksf4w200e4aas6gi02amfc","_id":"ck0ksf4w300e9aas62m316nkk"},{"post_id":"ck0ksf4uf006iaas6rnpmsklo","tag_id":"ck0ksf4w200e4aas6gi02amfc","_id":"ck0ksf4w400ebaas63nnidxms"},{"post_id":"ck0ksf4ug006laas67te39zbr","tag_id":"ck0ksf4vw00cxaas66ok75uah","_id":"ck0ksf4w500efaas6jkp07f2a"},{"post_id":"ck0ksf4ug006laas67te39zbr","tag_id":"ck0ksf4vw00d2aas6rwfykyz9","_id":"ck0ksf4w500egaas69ebo33se"},{"post_id":"ck0ksf4ug006laas67te39zbr","tag_id":"ck0ksf4vy00dhaas6wb5zld58","_id":"ck0ksf4w500eiaas60fn4f3ff"},{"post_id":"ck0ksf4uh006oaas6gvb46viy","tag_id":"ck0ksf4w400eeaas6r0fjmekn","_id":"ck0ksf4w500ejaas6clop3zmv"},{"post_id":"ck0ksf4ui006raas6ufx9xe0t","tag_id":"ck0ksf4w200e4aas6gi02amfc","_id":"ck0ksf4w500elaas6juxojesv"},{"post_id":"ck0ksf4ui006vaas6m31pdq8p","tag_id":"ck0ksf4w500ekaas6zookvy3o","_id":"ck0ksf4w600enaas6uzrdurbm"},{"post_id":"ck0ksf4uj006xaas6a56x5jen","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4w600epaas6tw1nugfr"},{"post_id":"ck0ksf4ul0071aas61jljp47l","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4w600eraas6b7ieu7l7"},{"post_id":"ck0ksf4un0073aas6w8qqfvfv","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4w700etaas6s91psvvv"},{"post_id":"ck0ksf4un0076aas6r5tbgrgk","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4w700evaas6h88hpv19"},{"post_id":"ck0ksf4uo0078aas6es2mbd6c","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4w700exaas6o6crfyux"},{"post_id":"ck0ksf4up007caas65dgd6ppq","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4w800ezaas60lay6oxu"},{"post_id":"ck0ksf4uq007faas608ezxey3","tag_id":"ck0ksf4w700eyaas63o5fy9nx","_id":"ck0ksf4wa00f2aas60fyfjz2l"},{"post_id":"ck0ksf4uq007faas608ezxey3","tag_id":"ck0ksf4w800f0aas605hh334q","_id":"ck0ksf4wa00f3aas62vquh6ak"},{"post_id":"ck0ksf4us007iaas6dolddlkx","tag_id":"ck0ksf4w700eyaas63o5fy9nx","_id":"ck0ksf4wb00f6aas6dky9mcpn"},{"post_id":"ck0ksf4us007iaas6dolddlkx","tag_id":"ck0ksf4wa00f4aas62ur8m2j4","_id":"ck0ksf4wb00f7aas6ev602t0u"},{"post_id":"ck0ksf4us007kaas6rkbfhtu6","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4wb00f9aas6jbx5h9ub"},{"post_id":"ck0ksf4uu007oaas60jebvur8","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4wd00fbaas62bf1y2i3"},{"post_id":"ck0ksf4uy0083aas6hqjryxqu","tag_id":"ck0ksf4wd00faaas64ui3s8gk","_id":"ck0ksf4we00fdaas67900ipnn"},{"post_id":"ck0ksf4v00087aas67spm0ve5","tag_id":"ck0ksf4w500emaas6yajxk8jv","_id":"ck0ksf4we00ffaas6wre7zuln"},{"post_id":"ck0ksf4v1008baas6kh8opj74","tag_id":"ck0ksf4we00feaas6bx8l017l","_id":"ck0ksf4we00fhaas6xvu9p06s"},{"post_id":"ck0ksf4v2008faas6542d3u7g","tag_id":"ck0ksf4w200e4aas6gi02amfc","_id":"ck0ksf4wf00fjaas62m68z9dt"},{"post_id":"ck0ksf4v3008jaas6vfjadeqv","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4wg00flaas60odoa51h"},{"post_id":"ck0ksf4v6008raas6shjzvyr8","tag_id":"ck0ksf4wg00fkaas6pj5akyjy","_id":"ck0ksf4wg00foaas6cqh0qguj"},{"post_id":"ck0ksf4v6008raas6shjzvyr8","tag_id":"ck0ksf4wg00fmaas6oabg5pir","_id":"ck0ksf4wg00fpaas62tdfkq3y"},{"post_id":"ck0ksf4v7008uaas67s21usea","tag_id":"ck0ksf4w700eyaas63o5fy9nx","_id":"ck0ksf4wh00fsaas6wyg4z70f"},{"post_id":"ck0ksf4v7008uaas67s21usea","tag_id":"ck0ksf4wg00fqaas6l6z8pmvo","_id":"ck0ksf4wh00ftaas6r3nt1x1x"},{"post_id":"ck0ksf4v7008xaas6sjxpmqwf","tag_id":"ck0ksf4w700eyaas63o5fy9nx","_id":"ck0ksf4wh00fvaas6wbgkvyv3"},{"post_id":"ck0ksf4v90091aas6mg4jkx4r","tag_id":"ck0ksf4wh00fuaas61rurzj8l","_id":"ck0ksf4wh00fxaas6rlw46qvu"},{"post_id":"ck0ksf4v90095aas6s81hq6g7","tag_id":"ck0ksf4wh00fwaas6zzayvt46","_id":"ck0ksf4wi00g1aas6yd6vg40h"},{"post_id":"ck0ksf4v90095aas6s81hq6g7","tag_id":"ck0ksf4wh00fyaas626trlbqb","_id":"ck0ksf4wi00g2aas6gwgy5nf9"},{"post_id":"ck0ksf4v90095aas6s81hq6g7","tag_id":"ck0ksf4wi00fzaas6dpadqjft","_id":"ck0ksf4wi00g3aas6cpxab318"},{"post_id":"ck0ksf4va0098aas658fdspzf","tag_id":"ck0ksf4wi00g0aas64y31oxhz","_id":"ck0ksf4wi00g4aas6ty76tdit"},{"post_id":"ck0ksf4wy00g5aas62jobfnfk","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4wz00g9aas6ssmvocxc"},{"post_id":"ck0ksf4x100gdaas6r6i12ide","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4x300ggaas6nlfvw0yc"},{"post_id":"ck0ksf4x100gdaas6r6i12ide","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4x400gkaas6jgd5ew4s"},{"post_id":"ck0ksf4x200gfaas6yokz6f26","tag_id":"ck0ksf4vi00a8aas6xqtuj0u1","_id":"ck0ksf4x500gnaas6yfew9py8"},{"post_id":"ck0ksf4x200gfaas6yokz6f26","tag_id":"ck0ksf4vi00adaas6g8bc3kul","_id":"ck0ksf4x500graas66utooeal"},{"post_id":"ck0ksf4wz00g7aas6h3yo5pn2","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4x600gtaas6qd50olkr"},{"post_id":"ck0ksf4wz00g7aas6h3yo5pn2","tag_id":"ck0ksf4x100gcaas6wr8qftfx","_id":"ck0ksf4x600gwaas6qy1sz773"},{"post_id":"ck0ksf4x400glaas6qi3d5h58","tag_id":"ck0ksf4wh00fwaas6zzayvt46","_id":"ck0ksf4x600gyaas6lm98knl0"},{"post_id":"ck0ksf4x400glaas6qi3d5h58","tag_id":"ck0ksf4wi00fzaas6dpadqjft","_id":"ck0ksf4x600h1aas65gbe330d"},{"post_id":"ck0ksf4x000gaaas6xvlhthpm","tag_id":"ck0ksf4s8000kaas6tjjnhy6f","_id":"ck0ksf4x600h2aas62ujeual8"},{"post_id":"ck0ksf4x000gaaas6xvlhthpm","tag_id":"ck0ksf4x100gcaas6wr8qftfx","_id":"ck0ksf4x600h3aas6pt53l7mi"},{"post_id":"ck0ksf4x300ghaas6hlv3p4ks","tag_id":"ck0ksf4x500gqaas6yl0iuub6","_id":"ck0ksf4x700h5aas6ll0wdfsc"},{"post_id":"ck0ksf4x300ghaas6hlv3p4ks","tag_id":"ck0ksf4x600gvaas6yluvbrky","_id":"ck0ksf4x700h6aas6qsv9sizb"},{"post_id":"ck0ksf4x300ghaas6hlv3p4ks","tag_id":"ck0ksf4x600h0aas6obdfvl9z","_id":"ck0ksf4x700h7aas6g6wbrflk"},{"post_id":"ck0ksf4x300ghaas6hlv3p4ks","tag_id":"ck0ksf4x600h4aas62jm0iiib","_id":"ck0ksf4x700h8aas66ldx3tk2"},{"post_id":"ck0ksf50y00h9aas6sj2ll0dm","tag_id":"ck0ksf4t1002yaas6mtlsldxz","_id":"ck0ksf50z00haaas6lhxrf4gn"},{"post_id":"ck0ksf52000hcaas6lusoddxn","tag_id":"ck0ksf4uf006haas6klx6079r","_id":"ck0ksf52200hfaas6uyeti7ji"},{"post_id":"ck0ksf52000hcaas6lusoddxn","tag_id":"ck0ksf52100hdaas6geqo8453","_id":"ck0ksf52200hgaas6tnozx3h1"}],"Tag":[{"name":"学习技巧","_id":"ck0ksf4rz0005aas69rwj5tpi"},{"name":"学习渠道","_id":"ck0ksf4s1000aaas6fo40dknf"},{"name":"css","_id":"ck0ksf4s4000faas6gvd8he92"},{"name":"JavaScript","_id":"ck0ksf4s8000kaas6tjjnhy6f"},{"name":"命名规范","_id":"ck0ksf4sf0014aas6ybxa533m"},{"name":"hexo","_id":"ck0ksf4si001eaas6dm0ikyyi"},{"name":"PostCss","_id":"ck0ksf4so001taas663vn10g8"},{"name":"Kubernetes","_id":"ck0ksf4sr0021aas6kauew9g8"},{"name":"容器技术","_id":"ck0ksf4st002aaas68xnixkll"},{"name":"适配","_id":"ck0ksf4sz002qaas62s9ccbix"},{"name":"Vue","_id":"ck0ksf4t1002yaas6mtlsldxz"},{"name":"AOP","_id":"ck0ksf4t8003haas6lvypad80"},{"name":"编程范式","_id":"ck0ksf4tb003naas6thdpjhlv"},{"name":"3D","_id":"ck0ksf4te003taas6rm27q44a"},{"name":"矩阵","_id":"ck0ksf4th0040aas6n8cr1eh0"},{"name":"C语言","_id":"ck0ksf4tk0047aas69mubvv6x"},{"name":"js执行机制","_id":"ck0ksf4tn004eaas6zabrlawp"},{"name":"尾递归","_id":"ck0ksf4ts004laas60gnt32vb"},{"name":"尾调用","_id":"ck0ksf4tu004saas6wjv071gk"},{"name":"Linux","_id":"ck0ksf4u0004yaas6zcmrrpp4"},{"name":"NodeJs","_id":"ck0ksf4u5005faas6wz0w7gfr"},{"name":"MongoDB","_id":"ck0ksf4u7005naas6ji1nznsq"},{"name":"Koa","_id":"ck0ksf4ud0067aas6hh9wkn1a"},{"name":"源码","_id":"ck0ksf4ue006caas67f4zz2f8"},{"name":"React","_id":"ck0ksf4uf006haas6klx6079r"},{"name":"immutable","_id":"ck0ksf4uh006paas67fg9q7xn"},{"name":"性能优化","_id":"ck0ksf4um0072aas657fb7mqa"},{"name":"错误处理","_id":"ck0ksf4v1008aaas6u6rs2de7"},{"name":"Redux","_id":"ck0ksf4v6008qaas6zlf1y8f6"},{"name":"SSR","_id":"ck0ksf4vh00a1aas6qcpnxizv"},{"name":"SEO","_id":"ck0ksf4vh00a5aas6vuennnaq"},{"name":"图形学","_id":"ck0ksf4vi00a8aas6xqtuj0u1"},{"name":"ThreeJs","_id":"ck0ksf4vi00adaas6g8bc3kul"},{"name":"Canvas","_id":"ck0ksf4vr00c1aas6isfl4udk"},{"name":"web-component","_id":"ck0ksf4vs00c6aas69oxnfj4f"},{"name":"特效","_id":"ck0ksf4vt00caaas6i9n9fpim"},{"name":"HTML","_id":"ck0ksf4vt00cdaas6l9zxhpqa"},{"name":"Docker","_id":"ck0ksf4vu00ciaas60i4cnwjn"},{"name":"webpack","_id":"ck0ksf4vw00cxaas66ok75uah"},{"name":"工程化","_id":"ck0ksf4vw00d2aas6rwfykyz9"},{"name":"数据结构","_id":"ck0ksf4vx00daaas6o03n8jy9"},{"name":"babel","_id":"ck0ksf4vy00deaas6gpdb4ea3"},{"name":"Ast","_id":"ck0ksf4vy00dhaas6wb5zld58"},{"name":"算法","_id":"ck0ksf4w200e4aas6gi02amfc"},{"name":"DomDiff","_id":"ck0ksf4w400eeaas6r0fjmekn"},{"name":"英语语法","_id":"ck0ksf4w500ekaas6zookvy3o"},{"name":"记录","_id":"ck0ksf4w500emaas6yajxk8jv"},{"name":"计算机基础","_id":"ck0ksf4w700eyaas63o5fy9nx"},{"name":"汇编","_id":"ck0ksf4w800f0aas605hh334q"},{"name":"CPU","_id":"ck0ksf4wa00f4aas62ur8m2j4"},{"name":"目录","_id":"ck0ksf4wd00faaas64ui3s8gk"},{"name":"Angular","_id":"ck0ksf4we00feaas6bx8l017l"},{"name":"架构","_id":"ck0ksf4wg00fkaas6pj5akyjy"},{"name":"微服务","_id":"ck0ksf4wg00fmaas6oabg5pir"},{"name":"破解","_id":"ck0ksf4wg00fqaas6l6z8pmvo"},{"name":"面试","_id":"ck0ksf4wh00fuaas61rurzj8l"},{"name":"oop","_id":"ck0ksf4wh00fwaas6zzayvt46"},{"name":"IOC","_id":"ck0ksf4wh00fyaas626trlbqb"},{"name":"编程原则","_id":"ck0ksf4wi00fzaas6dpadqjft"},{"name":"专业术语","_id":"ck0ksf4wi00g0aas64y31oxhz"},{"name":"TypeScript","_id":"ck0ksf4x100gcaas6wr8qftfx"},{"name":"CI","_id":"ck0ksf4x500gqaas6yl0iuub6"},{"name":"Jenkins","_id":"ck0ksf4x600gvaas6yluvbrky"},{"name":"Centos","_id":"ck0ksf4x600h0aas6obdfvl9z"},{"name":"前端持续集成","_id":"ck0ksf4x600h4aas62jm0iiib"},{"name":"Fiber","_id":"ck0ksf52100hdaas6geqo8453"}]}}