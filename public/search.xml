<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Linux】命令手册]]></title>
    <url>%2F2019%2F04%2F02%2F%E3%80%90Linux%E3%80%91%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[linux 只有区的概念 终端快捷键 命令 功能 ctrl + c 结束正在运行的程序 【 ping 、 teInet等】 ctrl + d 结束输入或退出shell ctrl + s 暂停屏幕输出 ctrl + q 恢复屏幕输出 ctrl + l 清屏， 等同于Clear ctrl + a / ctrl + e 快速移动光标到行首 / 行尾 身份命令 命令 功能 sudo 暂时以root 用户身份运行命令 su 切换用户身份, root身份切换不需要密码 exit 退出当前身份或退出连接 w 查看正在登录用户 路径知识 Linux下文件前带.表示隐藏文件 一个.代表当前目录, 两个..代表上级目录 资源目录相关命令 a是显示隐藏文件, l是显示长列表格 命令 说明 ls 或 dir 查看当前目录内容 ls -l 显示长格式目录, 有创建时间,修改信息, 文件大小 ls -a 显示隐藏文件 ls -al 查看目录所有对应的权限( ) pwd 宣誓当前目录的全部路径 cd ~ 进入到当前分配home目录下的用户区域, 比如/home/nxl cd / 进入系统的根目录 文件命令 [old] 表示旧文件 [new] 表示操作后的文件 [target] 目标文件 [targetDir] 目标目录 命令 说明 mkdir 创建文件夹 rmdir 删除文件 touch [new] 创建文件 rm [target] 删除文件 rm -r [targetDir] 删除文件夹 rm -rf * 删除所有内容(r递归, f强制) cp [old] [test/new] 复制文件 cp [old] -R [test/new] 复制目录 ln -s old new 建立软链 界面切换命令 init [number] 命令 说明 0 关机 1 单用户 2 多用户状态没有网络服务 3 多用户状态有网络服务(就是平时的小黑窗) 4 系统未使用保留给用户 5 图形界面 6 系统重启 服务 / 进程管理命令 命令 说明 systemctl 查看进程 ststemctl [ status , start , stop , restart ] nginx 如对 nginx 执行相关命令 top 进程资源实时状态 ps [aux] 进程快照 kill [-9] pid 杀死进程 pkill [name] 根据进程名杀死进程 网络管理命令 命令 说明 ifconfig 查看网络接口（ interface） ip 网络配置工具箱 route 诊断网络 ipdown eth0 关闭eth0网卡 ipup eth0 开启eth0网卡 ss -anp , grep :22 查找占用端口情况 netstat -anp , grep :22 查找占用端口情况 命令行下载命令 命令 说明 curl 查看网络接口（ interface） wget 网络配置工具箱 wget -c 断点续传 vi / vim 行编辑器 vim是vi的增强版 命令 说明 vi [target] 编辑目标文件 cat [target] 查看文件内容 i (insert) 在当前光标所在字符的前面，转为编辑模式； a (append) 在当前光标所在字符的后面，转为编辑模式； o 在当前光标所在行的下方，新建一行，并转为输入模式； I 在当前光标所在行的行首，转换为输入模式 A 在当前光标所在行的行尾，转换为输入模式 O 在当前光标所在行的上方，新建一行，并转为输入模式； esc 退出编辑, ubuntu 需要 esc + : :q 退出编辑 :q! 强制退出 :wq 退出并保存 系统操作命令 命令 说明 ！ 强制执行命令 shutdown -h now 立刻关机 shutdown -r now /reboot 立刻重启计算机 su - root 先用普通账户登录再切换 sudo临时已管理员操作 logout 用户注销 帮助命令 命令 说明 –help 查看命令帮助 man xxx 查看详细手册 辅助命令 命令 说明 0 关机]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现一个bind]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind%2F</url>
    <content type="text"><![CDATA[bind方法用来保留JavaScript的this指向， 和apply、call这两个方法不同的是，bind不会立即执行 如何模拟实现一个bind方法 初始函数，我们将对整个函数修改this指向12345function fn( name ) &#123; this.name = name&#125;var obj = &#123; age: 18 &#125; 最普通的实现创建一个函数1234567function mybind(func ,context, ...args) &#123; return () =&gt; &#123; return func.apply(context, args ) &#125;&#125;var bindFn = mybind(fn, obj, '小明') 原型实现创建一个函数12345678Function.prototype.mybind = function(context, ...args) &#123; const _this = this return (...args2) =&gt; &#123; return _this.apply( context, [ ...args, ...args2] ) &#125; &#125;var bindFn = fn.mybind(obj, '小明' ) 实现很简单， 但是还差一步，就是bind后的函数， 拿来作为构造函数new时， this指向会出问题 处理new 的指向123456789Function.prototype.mybind = function(context, ...args) &#123; const _this = this function cbFn (...tempArgs) &#123; return this instanceof cbFn ? _this.apply(this, [ ...args, ...tempArgs]) : _this.apply( context, [ ...args, ...tempArgs] ) &#125; return cbFn&#125;var BindFn = fn.mybind(obj, '小明' )var bfn = new BindFn() 参考文献 https://github.com/mqyqingfeng/Blog/issues/13]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this的软绑定和硬绑定]]></title>
    <url>%2F2019%2F03%2F30%2Fthis%E7%9A%84%E8%BD%AF%E7%BB%91%E5%AE%9A%E5%92%8C%E7%A1%AC%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[被调用的函数示例1234function fn() &#123; // 如果严格模式， "use strict"加在此处 console.log(this)&#125; 软绑定1fn() // window “use strict” 严格模式的软绑定 1fn() // undefined 硬绑定1fn.apply(&#123;&#125;,['a']) // &#123;&#125; 忽略硬绑定， 使用软绑定1fn.apply(null,['a']) // window “use strict” 严格模式12fn.apply(&#123;&#125;,['a']) // &#123;&#125;fn.apply(null,['a']) // null]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件机制]]></title>
    <url>%2F2019%2F03%2F26%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[首先我们都知道JavaScript是单线程的， 当然现在浏览器中 HTML5 为我们提供了Web-Worker, 但JavaScript本质上还是一门单线程的语言， 这也是为了保持JavaScript 的简单易学，并且这也和DOM有关，因为如果 JavaScript 是多线程的， 一个县城增加了 DOM，一个删除了DOM， 那该听哪个线程的 所以JavaScript 放弃了多线程 事件机制单线程当遇到比较费事的操作带来的后果就是浏览器卡死， 那怎么办？为了应对这些问题， JavaScript将事件分为了 同步任务 异步任务 所有的事件任务都被加入到栈内, 栈的特点是先入后出， 如下图 看图中， 最开始调用的函数被压在了最下面， 直到最后才出栈 当我们递归书写不规范时， 就会撑爆函数的执行栈， 也就是爆栈 微任务与宏任务的区别我们可以把事件处理机制想象成银行柜台的柜员， 柜员每次只能处理接待一个客户， 就和JS一样是单线程的， 每一次的事件循环就是一个来办理业务的客户， 这个客户就是宏任务， 当前的客户结束之后， 柜员叫号，继续接待下一个客户， 也就是开始下一个宏任务 能进入任务队列的都是已完成的异步操作， 当你注册了异步事件，但还未完成， 就好比你取了排队的票子， 但是人离开了，有可能先去吃饭，有可能先去逛街， 于是当轮到你的号码时， 银行柜员会先跳过你， 当你回来时， 你依旧需要重新排队 在宏任务期间， 可以追加微任务的， 或者说微任务是可以插队的， 就像在柜台办理业务中， 一位大爷在办完自己的本来的业务后， 柜员通常都会问还有什么需要办理的业务， 这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。 所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。 所以在当前的微任务没有执行完成时，是不会执行下一个宏任务的 优先级不管是微任务还是宏任务， 都是异步任务， 当他们的事件处理完成后， 最终都是要归回到同步事件队列处理的， 也就是主进程， 既然是主进程，主进程又要负责浏览器的渲染， 那这三者之间的优先级是什么呢 因为微任务实际上是宏任务的其中一个步骤， 也就是下一次的宏任务到来之前必然得先执行完当前的宏任务的微任务, 所以可以这么看: 浏览器渲染 &gt; 微任务 &gt; 宏任务 微任务会插队， 插入每一次的执行栈末尾， 宏任务比较可怜， 只要存在微任务，就会被插队，顺序就会往后 看下图， 我们可以理解微任务和微任务分别维护着一个队列， 微任务的箭头指向靠前， 表示微任务会优先于宏任务加入事件队列， 宏任务会延迟加入 理论上UI渲染的优先级是比较高的， 但实际上如果你的微任务或宏任务之内， 出现了死循环或大量计算的情况， UI渲染就会被阻塞住， 无法进行，也就是页面卡死状态， 毕竟js单线程 EventLoop每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。（检查还有没有微任务需要处理）而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。（结束本次宏任务、检查还有没有宏任务需要处理）这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。(这是个非常简易的描述了，实际上会复杂很多) 而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑： 宏任务例子 API 浏览器 Node I/O ✅ ✅ setTimeout ✅ ✅ setInterval ✅ ✅ setImmediate ❌ ✅ requestAnimationFrame ✅ ❌ I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。 有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了HTML规范文档以后，发现这很显然是和微任务平行的一个操作步骤 requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行 微任务例子 API 浏览器 Node process.nextTick ❌ ✅ MutationObserver ✅ ❌ Promise.then catch finally ✅ ✅ MessageChannel 消息队列 浏览器中的情况在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤） I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。 假设有这样的一些DOM结构：123456789101112131415&lt;style&gt; #outer &#123; padding: 20px; background: #616161; &#125; #inner &#123; width: 100px; height: 100px; background: #757575; &#125;&lt;/style&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223const $inner = document.querySelector('#inner')const $outer = document.querySelector('#outer')function handler () &#123; console.log('click') // 直接输出 Promise.resolve().then(_ =&gt; console.log('promise')) // 注册微任务 setTimeout(_ =&gt; console.log('timeout')) // 注册宏任务 requestAnimationFrame(_ =&gt; console.log('animationFrame')) // 注册宏任务 $outer.setAttribute('data-random', Math.random()) // DOM属性修改，触发微任务&#125;new MutationObserver(_ =&gt; &#123; console.log('observer')&#125;).observe($outer, &#123; attributes: true&#125;)$inner.addEventListener('click', handler)$outer.addEventListener('click', handler) 如果点击#inner，其执行顺序一定是：click -&gt; promise -&gt; observer -&gt; click -&gt; promise -&gt; observer -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。 因为一次I/O创建了一个宏任务，也就是说在这次任务中会去触发handler。按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了Promise和MutationObserver两个微任务，遂执行之。因为click事件会冒泡，所以对应的这次I/O会触发两次handler函数(一次在inner、一次在outer)，所以会优先执行冒泡的事件(早于其他的宏任务)，也就是说会重复上述的逻辑。在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。需要注意的一点是，因为我们触发了setAttribute，实际上修改了DOM的属性，这会导致页面的重绘，而这个set的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。 Node Js中的情况Node也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，这里是Node官方文档的地址。 就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。 几个特殊的API SetTimeout和SetInterval 线程池不参与 process.nextTick() 实现类似SetTimeout(function(){},0);每次调用放入队列中，在下一轮循环中取出。 setImmediate();比process.nextTick()优先级低 来看看这段代码 1234567891011121314151617181920setTimeout(() =&gt; &#123; console.log(1)&#125;, 0)setImmediate(() =&gt; &#123; console.log(2)&#125;)process.nextTick(() =&gt; &#123; console.log(3)&#125;)new Promise((resolve, reject) =&gt; &#123; console.log(4) resolve(4)&#125;).then(() =&gt; &#123; console.log(5)&#125;)console.log(6) 这道题目的答案是 463512 这里有几个注意点， 第一就是 nextTick ，它的优先级比 promise.then 要高， 如下图， 它加入队列的方式属于插队行为, 它直接加入到了当前执行栈（同步队列）与 下一次的等待执行栈之间 我们都知道 then 比 setTimeout 优先级高 然后就是 setTimeout 和 setImmediate 的问题了， setImmediate与setTimeout的区别，在官方文档中的定义，setImmediate为一次Event Loop执行完毕后调用。 setTimeout则是通过计算一个延迟时间后进行执行。 但是在实际使用中， 当setTimeout 设置为0时， 他们都是放在队列最后, 所以执行顺序就是谁先写就先执行谁了， 但当setTimeout 设置的时间大于0 时（最低延迟会被忽略）， 情况就不一样了， setTmmediate 会先被执行 参考文献(原文写的不错， 所以我大部分是复制，方便之后自己回顾理解) https://segmentfault.com/a/1190000016022069]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NodeJs】异步IO与EventLoop]]></title>
    <url>%2F2019%2F03%2F26%2F%E3%80%90NodeJs%E3%80%91%E5%BC%82%E6%AD%A5IO%E4%B8%8EEventLoop%2F</url>
    <content type="text"><![CDATA[IO密集型就是需要频繁请求的程序，高访问量， CPU密集型就是需要进行大量计算的 异步IO的好处 前端通过异步IO可以消除UI堵塞。 假设请求资源A的时间为M,请求资源B的时间为N.那么同步的请求耗时为M+N.如果采用异步方式占用时间为Max(M,N)。 随着业务的复杂，会引入分布式系统，时间会线性的增加，M+N+…和Max(M,N…)，这会放大同步和异步之间的差异。 I/O是昂贵的，分布式I/O是更昂贵的。 分布式因为你读取到了这个值， 但并没有在你这台机器上， 远程的机器想要读取到那就必须要走网络， 这个过程就变长了 NodeJS 适用于IO密集型不适用CPU密集型 Node对异步IO的实现 完美的异步IO应该是应该是应用程序发起非阻塞调用，无需通过遍历或者事件幻想等方式轮询。 Node.js 的事件循环和在浏览器中的实现不太一样， 在Node.js 中事件循环交给了Libuv托管， Libuv 和 v8 是分别独立的线程， 辅助Node.js 进行事件轮询 Node.js 依靠v8运行javascript, 并且绑定了底层的操作系统 当V8接收到用户的请求进入， 通过绑定系统接口，将事件交给Libuv处理， Libuv 将事件加入事件队列( event queue)， EventLoop 不行的旋转并执行同步事件，当遇到异步事件时，将其交给 worker Threads 线程， 比如操作文件就是交给工作线程去同步完成， 当文件操作完毕后， 根据文件描述符去获取数据， 然后将结果作为参数返回给事件队列中等候的回调函数 常用的Node控制异步技术手段 Promise 是一个语法， 规范， js只是实现了这个规范， Promise 是一个高级接口， 创建一次，不容易修改， then就是 低级接口， 可以一直then ,处理逻辑 Step、wind（提供等待的异步库）、Bigpipe、Q.js Async、Await Promise/Defferred 是一种先执行异步调用，延迟传递的处理方式。Promise是高级接口，事件是低级接口。低级接口可以构建更多复杂的场景，高级接口一旦定义，不太容易变化，不再有低级接口的灵活性，但对于解决问题非常有效 由于Node基于V8的原因，目前还不支持协程。协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。 底层的知识 CPU时钟周期：1/cpu主频 -&gt; 1s/3.1 GHz 操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理。应用程序如果需要进行IO需要打开文件描述符，在进行文件和数据的读写。异步IO不带数据直接返回，要获取数据还需要通过文件描述符再次读取。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript语法]]></title>
    <url>%2F2019%2F03%2F24%2FTypeScript%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[初始化配置文件 tsc –init修改outDir 定义数组 1 1var arr:number[] = [1,2,3,4] 2 1var arr:Array&lt;number&gt; = [3,4,56,7,8,9] 3 1var arr:any[] = [1,'5515', false] 定义元组 元组表示一个已知元素数量和类型的数组，各元素的类型不必相同。1 1let arr:[number, string] = [123, 'this is ts'] 定义枚举 用于处理非数值的数据 1234enum Flag &#123; success=1, error=2 &#125;;let s:Flag=Flag.successconsole.log(s) // 1 never 类型: never类型表示的是那些永不存在的值的类型, 如null, undefind, error 12var a:undefineda = undefined 定义 symbol类型 symbol类型的值是通过Symbol构造函数创建的。 1let sym1 = Symbol(); 容许多个类型1234var num:number | undefined;num = 123;console.log(num) 有返回值类型 函数声明 123function run():string &#123; return '32132132'&#125; 函数表达式 123var fun2 = function():number &#123; return 132&#125; 无返回值类型123function run():void&#123; console.log('run')&#125; 可选参数、 默认参数 、剩余参数 默认必传, 带‘?’可传可不传， 必须配置到参数的最后面 123function getInfo(name:string, age?:number):string &#123; return `$&#123;name&#125; ---- $&#123;age&#125;`&#125; 默认参数写了默认参数就不再需要 ‘?’ 标记 123function getInfo(name:string, age:number=250):string &#123; return `$&#123;name&#125; ---- $&#123;age&#125;`&#125; 剩余参数12 json 属性约束12345// json属性约束function jsonCon(label) &#123; console.log(label.labelJson);&#125;jsonCon(&#123; labelJson: '你好评' &#125;); 重载 因为需要遵循js ， 所以无法像java一样实现重载， 实现的只能是变体， 自己判断typeof 123456789101112131415function getInfo(name:string):string;function getInfo(name:string, age:number):string;function getInfo(name:string, age?:any):string &#123; // 判断类型用 typeof if(age) &#123; return `姓名:$&#123;name&#125;, 年龄$&#123;age&#125;` &#125;else &#123; return `姓名:$&#123;name&#125;` &#125;&#125;console.log(getInfo('吴大龙')) 创建类123456789101112131415161718class Person&#123; name:string; // 属性 ,前面省略了Public 关键词 constructor(name:string)&#123; // 构造函数 实例化类的时候 触发的方法 this.name = name; &#125; getName():string&#123; return this.name &#125; setName(name:string):void&#123; this.name=name; &#125;&#125; var aa = new Person('栗色')console.log(aa.getName())aa.setName('吴大龙')console.log(aa.getName()) 使用类的 get 和 set 123456789101112131415class Person&#123; private _name:string; constructor(name:string, age:number)&#123; this._name = name; &#125; get name():string&#123; return this._name &#125; set name(name:string)&#123; this._name = name; &#125;&#125;const p = new Person('吴大龙', 112)p.name = '吴强' // 赋值console.log(p.name) // 取值 实现继承 继承自上方类 12345678class Web extends Person &#123; constructor(name:string)&#123; super(name); &#125;&#125;var w=new Web('往');console.log(w.run()) 类修饰符 不加修饰符默认就是 Public , ==外部的意思就是指不被内部函数里被调用, 而是被外部人为调用==public: 共有, 在类的里面, 子类, 类外部都可以访问 protected: 保护类型, 在类里面, 子类里面可以访问, 类外部无法访问 private: 私有, 在类里可以访问, 子类, 类外部都没法访问 静态属性和静态方法 static 静态方法, 在没有 new 出实例前都可以调用==但是没法直接调用类里面的属性== 123456789class Person &#123; public nickname:string= '吴大龙'; static speak():void&#123; console.log(`用户姓名:$&#123;this.nickname&#125;`) &#125;&#125;Person.speak() // 用户姓名:undefined 多态 父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现也是继承的一种表现, 子类实现或重写父类中的已有的方法， 这叫多态 123456789101112131415161718192021222324252627282930313233343536// 多态class Animal &#123; name:string; constructor(name:string)&#123; this.name = name; &#125; eat():void&#123; console.log(`$&#123;this.name&#125;， 在吃屎`) &#125;&#125;class Dog extends Animal &#123; constructor(name:string)&#123; super(name) &#125; // 子类重新定义 eat方法 eat():void &#123; console.log(this.name+'吃肉') &#125;&#125;const wuxiaohong = new Dog('吴晓红')wuxiaohong.eat()// 子类重新定义 eat方法class Cat extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat():void&#123; console.log(this.name+ '吃粮食') &#125;&#125;var cc = new Cat('吴强')cc.eat() 抽象类 用abstract关键字定义抽象类和抽象方法， 是提供其他类继承的基类==抽象方法只能放在抽象类里==从抽象类继承的方法必须被子类重写, 重新实现 1234567891011121314151617181920abstract class Animal&#123; public name:string; constructor(name:string)&#123; this.name=name; &#125; abstract eat():any;&#125;class Dog extends Animal&#123; constructor(name:any)&#123; super(name) &#125; eat()&#123; console.log(this.name + '吃粮食') &#125;&#125;var d = new Dog('小狗')d.eat() 接口 也是一种定义标准. 类似抽象类, 抽象类只能规定方法， 接口可以规定属性， 函数， 索引和类 批量属性接口， 可定义可选参数 123456789// 属性接口interface FullName&#123; firstName: string; //封号结束 secondName: string;&#125;function printName (name: FullName) : void&#123; console.log(name.firstName +'====&gt;' + name.secondName);&#125;printName(&#123;firstName: '吴', secondName: '大龙'&#125;) // 吴====&gt;大龙 数组类型接口123456interface StringArray &#123; [index:number]:string&#125;var myArray:StringArray;myArray = ["iwen", "ime"]alert(myArray[1]) 函数类型接口, 对方法传入的参数， 以及返回值进行约束 123456789// 比如建一个md5加密的接口 的接口interface encrypt&#123; (key:string, value:string):string;&#125;var md5:encrypt = function(key:string, value:string):string &#123; return key + value;&#125;console.log(md5('name', '吴大龙')) 接口扩展， 接口可以继承接口 1234567891011121314151617181920212223interface Animal&#123; eat():void;&#125;// 继承上方接口interface Person extends Animal &#123; work():void;&#125;// 有个类 实现 这个接口class Web implements Person &#123; public name:string; constructor(name:string)&#123; this.name=name &#125; eat()&#123; console.log(this.name + '喜欢吃馒头') &#125; work()&#123; console.log(this.name + '写代码') &#125;&#125;var w = new Web('小林')w.work() // 小林写代码 接口多继承 &amp;&amp; ==创建一个接口对象==123456789101112131415161718// 多继承 并 创建一个接口对象interface Shape &#123; color:string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength:number;&#125;// 创建接口对象不需要 new 而是这样的语法var s = &lt;Square&gt;&#123;&#125;;s.color = "blue"s.penWidth = 10s.sideLength = 10 泛型 用于创建可重用的组件， 让一个组件支持多种数据类型 ==泛型就是解决类 接口 方法的复用性、 以及对不特定数据类型的支持== 基本使用 12345// 泛型 : 可以支持不特定的数据类型 要求： 传入的参数和返回的参数一致function getData&lt;T&gt;(value:T):T&#123; // T表示泛型 return value&#125;console.log(getData&lt;string&gt;('我是泛型')) 多个泛型参数 12345678910class HelloNumber&lt;T, S&gt;&#123; Ten:T; add:(x:T, y:T) =&gt; S;&#125;var myHelloNumber = new HelloNumber&lt;number, string&gt;()myHelloNumber.Ten = 10;myHelloNumber.add = function(x, y) &#123; return x+y+''&#125;console.log(myHelloNumber.add(1, 2)); lamb 表达式 12345678function Hello&lt;T&gt;(arg:T):T&#123; return arg;&#125;// lamb 表达式只是表达具体 参数和返回类型, 需要重新赋值上真函数var myHello:&lt;K&gt;(arg:K)=&gt; K = &lt;K&gt;(arg:K):K =&gt; &#123; return arg&#125;alert(myHello('hello')) 另一种写法， 对象形式 12345function Hello&lt;T&gt;(arg:T)&#123; return arg&#125;var myHello:&#123;&lt;T&gt;(arg:T):T&#125; = Hello;alert(myHello(" Hello")) 泛型接口 12345678// 泛型接口interface ConfigFn&#123; &lt;T&gt;(value:T):T;&#125;var getData:ConfigFn = function&lt;T&gt;(value:T):T&#123; return value&#125;console.log( getData&lt;string&gt;('你好') ) 泛型小实战 ==需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现== 12345678910111213141516171819202122// 泛型类: 比如有个最小堆算法， 需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现class MinClass&lt;T&gt;&#123; list:T[]=[] add(value:T):void&#123; this.list.push(value) &#125; min():T&#123; var minNum = this.list[0] for(var i=0;i&lt;this.list.length;i++)&#123; if(minNum &gt; this.list[i])&#123; minNum=this.list[i] &#125; &#125; return minNum; &#125;&#125;var m1 = new MinClass&lt;string&gt;();m1.add('1')m1.add('you')m1.add('love')console.log(m1.min()) 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在伪元素中使用Iconfont]]></title>
    <url>%2F2019%2F03%2F24%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%AD%E4%BD%BF%E7%94%A8Iconfont%2F</url>
    <content type="text"><![CDATA[把iconfont 中的样式拷到 伪元素上1234567.iconfont&#123; font-family:"iconfont" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; 砍掉unicode 前面的字符如下 即可123456789&amp;::after&#123; content: '\e60e'; font-family:"iconfont" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuecli3脚手架环境变量]]></title>
    <url>%2F2019%2F03%2F24%2Fvuecli3%E8%84%9A%E6%89%8B%E6%9E%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[环境变量 环境变量, 在开发和生产环境中会经常使用到 举一个例子 在开发过程中我们使用一个本地的接口但是在我们打包上线的时候, 我们会使用线上的接口这时候我们就可以通过环境变量来配置 如何创建环境变量 进入脚手架根目录 , 新建一个 .env 文件 , 这就是一个环境变量文件 .env 优先级最低的配置文件, 两种环境都可以用.env.development 开发环境, 时优先使用的环境变量.env.production 生产环节, 打包时使用的环境变量 环境变量语法 VUE_APP_衔接上一个名字=’你的变量’ 如: VUE_APP_URL=’https://baidu.com&#39; 如何在组件中获取环境变量 process.env.VUE_APP_URL然后挂载到当前组件的data 上 ,如下 12345data()&#123; return &#123; url: process.env.VUE_APP_URL &#125;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的add命令与npm的小区别]]></title>
    <url>%2F2019%2F03%2F24%2Fvue%E7%9A%84add%E5%91%BD%E4%BB%A4%E4%B8%8Enpm%E7%9A%84%E5%B0%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[add如果你下载的库, 特别是 Ui 库, 希望对脚手架结构产生影响, 那就选择 vue add xxx npm如果不希望对脚手架结构产生影响, 只是单纯的使用, 比如 axios 这个插件那就选择 npm install xxx 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3脚手架配置px2rem适配方案]]></title>
    <url>%2F2019%2F03%2F24%2Fvue-cli3%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AEpx2rem%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[安装12npm i lib-flexible --savenpm install px2rem-loader 引入 main.js 1import &apos;lib-flexible/flexible&apos; index.html 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 根目录新建 vue.config.js 文件 复制如下代码， 重启， 搞定 123456789101112131415// vue.config.jsmodule.exports = &#123; chainWebpack: config =&gt; &#123; config.module .rule(&apos;css&apos;) .test(/\.css$/) .oneOf(&apos;vue&apos;) .resourceQuery(/\?vue/) .use(&apos;px2rem&apos;) .loader(&apos;px2rem-loader&apos;) .options(&#123; remUnit: 75 &#125;) &#125;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>适配</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AOP】面向切面编程]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%90AOP%E3%80%91%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Aspect Oriented Programming 面向切面编程（aop）是对面向对象编程（oop）的补充 面向切面编程在软件业， AOP为 Aspect Oriented Programming 的缩写， 意为: 面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续， 是软件开发中的一个热点， 也是Spring 框架中的一个重要内容， 是函数式编程的一种衍生范式。 利用AOP可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低， 提高程序的可重用性， 同时提高了开发效率。 基础概念AOP 完善Spring 的依赖注入(DI) 面向对象编程将程序分解成各个层次的对象， 面向切面编程将程序运行过程分解成各个切面。 FilterFilter(过滤器) 也是一种AOPA， 他利用一种称为“横切”的技术， 刨解开封装的对象内部， 并将那些影响了多个类的公共行为封装到一个可重用的模块， 并将其命名为”Aspect”， 即切面。 所谓“切面”。 优点AOP的好处就是你只需要干你的正事， 其他事情别人帮你干。 在你访问数据库之前， 自动帮你开启事务， 当你访问数据库结束之后， 自动帮你提交/回滚事务！ 就像函数的before和 after 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则之IOC控制反转]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BIOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[IOC （控制反转） Inversion of Control IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚。 什么是控制反转控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注⼊到对象中。 DI是IOC的一种表现形式 两种方式依赖查找容器提供回调接口和上下文条件给组件。 依赖注入组件不做定位查询， 需提供普通的方法让容器去决定依赖关系。 IOC概念图在未使用IOC的时候 各个 Object 之间的耦合度很高， 谁也离不开谁 在使用 IOC 后， 各个 Object 之间通过 IOC容器 整个第三方角色来调度， 变成了可任意组装的模式， 谁需要的时候注入谁， 降低了耦合度 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>IOC</tag>
        <tag>编程原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则之S.O.L.I.D]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BSOLID%2F</url>
    <content type="text"><![CDATA[作为一名优秀的工程师，最重要的不是招式， 而是内功， 像武侠小说里的高手， 一旦有了几十年的内功， 学什么武功都能快人一步 那编程里如何提升内功， 主要就是体现在编程思想上了， 逐层提升你编程思想比如从一开始的最传统的面向对象 到 面向切面 面向对象 -&gt; 工厂模式 -&gt; 面向切面 从 “oop 的静态抽象” 演变为 “aop的动态抽象” SOLID原则的基本概念让我们来看下 SOLID 的概念 程序设计领域， SOLID (单一一功能、开闭原则、⾥里里⽒氏替换、接⼝口隔离以及依赖反转)是由罗伯特·C·⻢马丁在21世纪早期 引⼊入的记忆术⾸首字⺟母缩略略字，指代了了⾯面向对象编程和⾯面向对象设计的五个基本原则。当这些原则被一一起应⽤用时，它们使得一一个程序员开发一一个容易易进⾏行行软件维护和扩展的系统变得更更加可能SOLID被典型的应⽤用在测试驱动开发上，并且是敏敏捷开发以及⾃自适应软件开发的基本原则的重要组成部分。 SOLID这几个字母代表什么意义？S (单一一功能原则) Single Responsibility Principle 单一一功能原则 ：单一一功能原则 认为对象应该仅具有一一种单一一功能的概念。换句句话说就是让一一个类只做一一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。在所有的SOLID原则中，这是⼤大多数开发⼈人员感到最能完全理理解的一一条。严格来说，这也可能是违反最频繁的一一条原则了了。单一一责任原则可以看作是低耦合、⾼内聚在面向对象原则上的引申，将责任定义为引起变化的原因，以提高内聚性来减少引起变化的原因。责任过多，可能引起它变化的原因就越多，这将导致责任依赖，相互之间就产⽣生影响，从⽽而极⼤大的损伤其内聚性和耦合度。单一一责任，通常意味着单一一的功能，因此不不要为一一个模块实 现过多的功能点，以保证实体只有一一个引起它变化的原因。 缩减一下就是: 让每个函数和每个类都只做一件小事，职责单一，解耦和 O (开闭原则) Open Close Principle 开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。软件实体应该是可扩展，而不不可修改的。也就是说，对扩展是开放的，而对修改是封闭的（“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不不应该被修改。也就是说你可以新增功能但不能去修改源码。）。这个原则是诸多面向对象编程原则中最抽象、最难理理解的一个。 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独⽴立完成其⼯工作，⽽而不要对类进⾏行行任何修改。可以使用变化和不变来说明：封装不变部分，开放变化部分，一般使用接口继承实现⽅方式来实现“开放”应对变化。 说大白话就是：你不不是要变化吗？，那么我就让你继承实现一个对象，用一个接口来抽象你的职责，你变化越多，继承实现的子类就越多。 让我们来看下一个简单的 Ts demo 糟糕的实现1234567891011121314class Animal &#123; constructor(name: any) &#123; super(name) this.name = name &#125; eat() &#123; if(this.name == '小猫') &#123; console.log(this.name + '吃猫粮') &#125; else if( this.name == "小狗") &#123; console.log(this.name + '吃狗粮') &#125; &#125;&#125; 这种糟糕的实现不但使程序的可扩展性降低， 而且每次新增一种动物都需要修改之前的代码， 容易造成隐患， 这和编程思想极大的违背 利用 OCP 思想1234567891011121314151617181920// Animal 抽象类abstract class Animal &#123; public name: string; constructor(name: string) &#123; this.name = name; &#125; abstract eat(): any;&#125;// 实现Animal抽象类class Dog extends Animal &#123; constructor(name: any) &#123; super(name) &#125; eat() &#123; console.log(this.name + '吃狗粮') &#125;&#125;var d = new Dog('小狗')d.eat() 上面的代码中， 首先使用abstract 定义抽象类和抽象方法，提供其他类继承的基类我们定义只要是Animal就必须要有eat方法 于是， 我们创建了一个Dog 继承Animal ,这个Dog就不一般了， 它规定了必须重新实现 eat 方法， 并且可以扩展自己的方法 当我们将来如果需要一只 Cat我们一样只需要让他继承Animal抽象类， 然后实现一个自己的eat方法 L (里⽒氏替换原则) Liskov Substitution Principle 里氏替换原则: 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下提前被它的子类所替换的”的概念。 子类必须能够替换他们的基类。即： 子类应该可以替换任何基类能够出现的地方， 并且经过替换以后， 代码还能正常工作。 另外， 不应该在代码中出现if/else之类对子类类型进行判断的条件。 里氏替换原则LSP使使代码符合开闭原则的一个重要保证。 正是由于子类的替换性才使得父类型的模块在无需修改的情况下就可以扩展。在很多情况下， 在设计初期我们类之间的关系不是很明确， LSP则给了我们一个判断和设计类之间关系的基准: 需不需要继承， 以及怎样设计继承关系。 当一个子类的实例应该能够替换任何其超类的实例时， 它们之间才具有is-A关系。 继承对于OCP， 就相当于多态性对于里氏替换原则。子类可以代替基类， 客户使用基类， 他们不需要知道派生类所做的事情。这是一个针对行为职责可替代的原则， 如果S是T的子类型， 那么S对象就应该在不改变任何抽象属性情况下替换所有T对象。 缩减一下就是: 老爸能干的事， 儿子必须都能干， 并且还要干的能多， 只要有儿子在， 老爸不在现场都没关系 I (接⼝隔离原则) Interface Segregation Principle 接口隔离原则: 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。 不能强迫用户去依赖那些他们不能使用的接口。 换句话说， 使用多个专门的接口比使用单一的总接口总要好(JavaScript几乎没有接口的概念， 所以使用ts)。 注意： 在代码中应用 ISP 并不一定意味着服务就是绝对安全的。 仍然需要采用良好的编码实践， 以确保正确的验证与授权。 这个原则起源于施乐公司， 他们需要建立了一个新的打印机系统， 可以执行诸如装订的印刷品一套，传真多种任务。此系统软件创建从底层开始编制， 并实现了这些任务功能， 但是不断增长的软件功能却使软件本身越来越难适应变化和维护。 每一次改变，即使是最小的变化， 有人可能需要近一个小时的重新编译和重新部署。这几乎不可能再继续发展， 所以他们聘请罗伯特(Robert)帮助他们。他们首先设计了一个主要类Job,几乎能够用于实现所有任务功能。 只要调用Job类的一个方法就可以实现一个功能， Job类就变动非常大， 是一个胖模型啊， 对于客户端如果只需要一个打印功能， 但是其他无关打印的方法功能也和其耦合， ISP原则建议在客户端和Job类之间增加一个接口层， 对于不同功能有不同的接口， 比如打印功能就是Print接口， 然后将大的Job类切分为继承不同接口的子类， 这样有一个Print Job类 等等。 缩减一下就是: 每一个业务都要准备一个接口， 每个不同功能的接口再继承自公共的基础接口 D (依赖反转原则) Dependency Inversion Principle 依赖倒置原则（Dependency Inversion Principle， DIP）规定： 代码应当取决于抽象概念， 而不是具体实现。 高层模块不应该依赖于底层模块， 二者都应该依赖于抽象抽象不应该依赖于细节， 细节应该依赖于抽象(总结解耦) 类可能依赖于其他类来执行其工作， 但是， 他们不应当依赖于该类的特定具体实现， 而应当是它的抽象。 这个原则实在是太重要了， 社会的分工化， 标准化都是这个设计原则的体现。显然， 这一概念会大大提高系统的灵活性。 如果类只是关心他们支持特定锲约而不是特定类型的组件， 就可以快速而轻松地修改这些低级服务的功能， 同时最大限度地降低对系统其余部分地影响。 举个例子: 你家里需要洗衣机， 不可能把整个洗衣机的生产流程都给实现了， 搬到自己家里， 当然时去超市商场购买一台洗衣机。 你需要电饭煲，也不可能把电饭煲地生产工艺实现了， 也是去商场买现成地。 此时商场就是一个容器， 商场帮我们去各个工厂采购这些商品， 当我们需要某件物品时就可以去商场购买现成地商品 依赖反转原则依赖注入 当某个⻆角⾊色要另一个角色协助时，通常由调用者来创建被调用者的实例。现在创建实例由容器来完成然后注⼊调用者。 注⼊入过程 如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注⼊ 依赖反转有两种方式 设值注入（在类上方设置字段） 构造注入 （在constructor中接收需要地参数） DI（依赖注⼊入） 依赖注⼊入（Dependency Injection） 为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注⼊是该原则的一种实现⽅方式。 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>编程原则</tag>
        <tag>SOLID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】理解权限命令-chown]]></title>
    <url>%2F2019%2F03%2F22%2F%E3%80%90Linux%E3%80%91%E7%90%86%E8%A7%A3chown%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021# 更改文件属组chgrp [-R] 属组名 文件名# 更改文件属主 或 属组chown [-R] 属主名 文件名chown [-R] 属主名：属组名 文件名# 修改文件权限 9 个属性# 有两种设置方式， 一种是数字 一种是符号# 基本身份 owner/group/others 的各自三种权限# read(r 4)/write(w 2)/execute(x 1): -rwxr-xr-- = [4+2+1][4+0+1][4+0+0]=754chmod [-R] xyz 文件或目录# 符号修改权限chmod u(user) +(加入) r 文件或目录 g(group) -(减去) w o(others) =(设定) x a(all 全部身份) chmod u=rwx,g=rx, o=r 文件名chmod a-x test1 图解]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题集合]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[事件机制Promise题目一:123456789101112131415setTimeout(() =&gt; &#123; console.log(4)&#125;, 0)new Promise(resolve =&gt; &#123; console.log(1) setTimeout(() =&gt; &#123; resolve("done") console.log(6) &#125;, 0) resolve(5)&#125;).then((res) =&gt; &#123; // 微任务 console.log(res)&#125;)console.log(2) 答案: 1 , 2 , 5 , 4, 6 注意， 没有done！ 分析:Promise 的resolve只会触发一次， 因为Promise的状态已经被修改为resolve 所以第二次的resolve 不会触发 题目二:1234567891011121314151617181920setTimeout(() =&gt; &#123; console.log(4)&#125;, 0)new Promise(resolve =&gt; &#123; console.log(1) new Promise(resolve =&gt; &#123; console.log(7) setTimeout(() =&gt; &#123; resolve("done") console.log("aa") &#125;, 0) resolve(8) &#125;).then((res) =&gt; &#123; console.log(res) &#125;) resolve(5)&#125;).then((res) =&gt; &#123; console.log(res)&#125;)console.log(2) 答案: 1, 7, 2, 8 , 5 , 4 , aa 分析:Promise的完成先后还得看谁先挂载了 then， 并不是谁先new就是谁 ES6系列async await:题目一: async 什么原理 ?例子:1234async function test () &#123; let result = await 10 &#125;test() 经过 Babel 转换12345678910111213while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return 10; case 2: result = _context.sent; case 3: case "end": return _context.stop(); &#125; 分析我们可以看到，经过babel 转换过的 async await 代码中关键的这句， while循环， 并且是一个死循环， babel 就是这样来模拟 async await的， 当await返回结果时， _context.stop抛出异常退出死循环 , babel这样做也是为了更好的捕获异常 题目二: 请问result输出几 ?12345678var a = 0async function test () &#123; let result = a + await 10 console.log(result)&#125;test()a = a + 1test() 答案: 10 , 11 分析: await 后如果是一个常量, 将作为 Promise.resolve的结果返回 因为 async await 是 generator的语法糖， 当执行 test 方法时， 变量a的值会被锁住 所以第一个结果是10， 第二个结果是 11]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript手册]]></title>
    <url>%2F2019%2F03%2F18%2FTypeScript%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[TypeScript是JavaScript的超集 开发环境搭建 我的环境: window10 + vscode 全局安装Ts npm i -g typescript 生成并配置tsconfig.json tsc –init 配置文件， 下面的配置中ts应存放在src 目录下， 并且会自动编译到dist文件夹下1234567891011121314151617181920212223242526272829303132333435&#123; "compilerOptions": &#123; "target": "es2017", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' "module": "commonjs", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' "moduleResolution": "node", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) "emitDecoratorMetadata": true, // 为装饰器提供元数据的支持 "experimentalDecorators": true, // 启用装饰器 "allowSyntheticDefaultImports": true, // 允许从没有设置默认导出的模块中默认导入。 "strict": true, // 启用所有严格类型检查选项 "noImplicitAny": true, // 在表达式和声明上有隐含的 any类型时报错 "alwaysStrict": true, // 以严格模式检查没个模块，并在没个文件里加入 'use strict' "sourceMap": true, "noEmit": false, // 不生成输出文件 "removeComments": true, // 删除编译后的所有的注释 "importHelpers": true, // 从 tslib 导入辅助工具函数 "strictNullChecks": true, // 启用严格的 null 检查 "lib": ["es2017"], // 指定要包含在编译中的库文件 "typeRoots": ["node_modules/@types"], "types": [ "node", ], "outDir": "./dist", // 编译后文件产出目录 "rootDir": "./src" // 你的ts文件目录 &#125;, "include": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 "./src/*.ts", "./src/**/*.ts" ], "exclude": [ "node_modules", "dist", "**/*.test.ts", "public" ]&#125; 快速生成package.json npm init -y 运行命令， 开始监听 tsc -w 是否有效呢？ 让我们来试一下 进入src目录新建一个 hello.ts，记得是.ts， 不要写习惯了打成.js😅 随便写点东西， 比如定义一个字符串类型:1var a:string = "hello world" 如果你配置没有问题的话， 我们就会看到他监听文件修改并编译 这是ts文件与 编译后的js文件 并且在他运行过程中， 我们可以按F5进行调试 基本数据类型 Boolean Number String Array Enum Any Void 简单的几种数据的定义123456// 定义一个Booleanvar a:boolean = true// 定义一个Numbervar a:number = 13// 定义一个 String var a:string = "13" 基本的数据结构定义1var list:number[] = [1,2,3] 接口 interfaces 基础接口没有接口时我们如何规范参数类型12345function fn(dog:&#123;name:string&#125;) &#123; console.log(dog.name)&#125;var myObj = &#123; name: "Hello" &#125;fn(myObj) 有了接口， 我们就可以把参数规定与函数分离 如何创建接口 通过 interface 关键字来声明 1234567891011interface dogValue &#123; name:string;&#125;// 指定参数`dog`是接口类型function fn(dog: dogValue) &#123; console.log(dog.name)&#125;var myObj = &#123; name: "Hello" &#125;fn(myObj) // 编译通过 接口的可选属性接口定义的参数不一定每一个都会被用到 泛型什么是泛型? 泛型: 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 一句话理解就是： 参数化类型（把类型当作是参数一样传递） 使用泛型的好处: 代码更加简洁【不用强制转换】 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】 可读性和稳定性【在编写集合的时候，就限定了类型】 指定一个最简单的泛型123function Hello&lt;T&gt;(arg:T):T &#123; return arg;&#125; Module 模块Module 模式是常见的JavaScript模式之一， 在ES6的模块话实现之前， 人们通常通过 IFEE 来实现Module Module 的好处 模块化 可重用 封装变量和函数 来看看在ES6之前是如何书写的123(function() &#123; // do somtiong&#125;()); 让我们来看一个例子， 使用 TS 的 Module 来防止调用多种 interface 时的麻烦 使用Module之前1234567891011121314151617interface StringValidator &#123; // 接口定义的方法 isAcceptable(s:string):boolean;&#125;var lettersRegexp = /^[A-Za-z]+$]/;var numberRegexp = /^[0-9]+$/;// 实现接口的方法class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return lettersRegexp.test(s) &#125;&#125; class ZipCodeValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s) &#125;&#125; 使用了Module 的书写方式后 1234567891011121314151617181920module Validation &#123; // 需要使用 export 来表示对外暴露 export interface StringValidator &#123; isAcceptable(s:string): boolean; &#125; var lettersRegexp = /^[A-Za-z]+$]/; var numberRegexp = /^[0-9]+$/; export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s:string) &#123; return lettersRegexp.test(s) &#125; &#125; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s) &#125; &#125;&#125; Module 与 类相结合使用12345678910111213141516171819module Person &#123; export class Student &#123; name: string; constructor(name:string) &#123; this.name = name; &#125; study() &#123; console.log(this.name + '在学习') &#125; speak() &#123; console.log(this.name + '在说话') &#125; &#125;&#125;// ----------- 使用时 -------------const xiaoming = new Person.Student('小明')xiaoming.study() NamespacesNamespaces 的和Module 的用法相同， 在Ts 的1.5 版本后， 用 Namespaces 取代了 Module 查看一下官方的示例 123456789namespace Shapes &#123; export namespace Polygons &#123; export class Triangle &#123; &#125; export class Square &#123; &#125; &#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()' 装饰器 &lt; Decorators &gt;如何定义一个装饰器 其实装饰器就是一个普通的函数， 他接收一个参数target ，这个参数就是被装饰对象， 看下面的例子， sealed 装饰了Dog类， 并且在sealed 中打印了 target ， 让我们看看 target到底是什么？123456789101112function sealed(target:any) &#123; // do something with 'target' ... console.log(target) return target&#125;// 被装饰的对象 foo@sealedclass Dog &#123;&#125; 打印结果 我们可以看到， 得到的正是 Dog这个类 装饰器工厂&lt; Decorator Factories &gt; 如果希望自定义如何将装饰器应用于声明，可以编写装饰器工厂。装饰器工厂只是一个函数，它返回将在运行时由装饰器调用的表达式。 装饰器工厂和普通装饰器相比的好处就是更加的自定义了， 可以根据不同情况自定义效果 如何定义一个装饰器工厂 123456789101112function dec(value:string) &#123; return function (target:any) &#123; console.log(value) console.log(target) &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; &#125; 让我们来看看运行的结果 可以看到，我们传入的test字符串和 Cat类都被打印出来了， 多装饰器的执行顺序使用多个装饰器时如何书写呢? 当我们使用多个装饰器时有两种写法 写成一行 1@f @g x 垂直书写 123@f@gx 多个装饰器的执行顺序是如何的呢？ 套用官网的说明 对每个装饰器的表达式进行自上而下的计算。 然后将结果作为自下而上的函数调用。 其实真实的运行原理是1f(g(x)) 访问器修饰器访问器修饰器的接收的参数和方法修饰器接收的参数一样 123456789101112131415161718192021function dec(value:string) &#123; return function (target:any, propertyKey: string, descriptor: PropertyDescriptor) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; this._x = x this._y = y &#125; // 访问器修饰器 @dec(true) get x() &#123; return this._x &#125; @dec(false) get y() &#123; return this._y &#125;&#125; 属性修饰器属性修饰器只有前两个参数123456789101112131415161718function dec(value:string) &#123; return function (target:any, propertyKey: string) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; // 属性修饰器 @dec(false) this._x = x this._y = y &#125;&#125; 参数修饰器参数修饰器也是三个参数， 但不同的是第三个参数接收 参数装饰器只能确认一个方法的参数是否被传入 前两个和其他的修饰器都相同， target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象 propertyKey 成员的名称 参数在所处函数的参数列表中的索引， 说人话就是告诉你他是第几个参数 1234567891011function require(value:boolean) &#123; return function (target:any, propertyKey: string, index: number) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; run(@require(true) name:string) &#123; &#125;&#125; 装饰器参数 类装饰器 类装饰器的参数只接收一个， 那就是target 也就是这个类本身 就和上面演示的那些例子一样 方法装饰器 一般会传入三个参数 target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象 propertyKey 成员的名称 descriptor 成员属性的描述符 我们来验证下方法装饰器的参数 让我们看看这段例子会输出什么123456789101112function f(value:string) &#123; return function (target:any, propertyKey: string, descriptor: PropertyDescriptor) &#123; console.log(arguments) console.log(target) &#125;&#125;class Tiger &#123; @f('tiger run') run() &#123; &#125;&#125; 输入结果: 在控制台输出， 我们看到了，第一个参数是 tiger 的实例对象（因为run是实例成员） 第二个参数是成员名称， 也就是被装饰的run 第三个参数是 run 的属性描述符 Mixins 混入除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。 Mixins 其实可以拆分为两个单词 Mix : 混合 ins : 是进入 所以合在一起就是叫 混入 的意思的单词 它想要表达的是一个对象中混入另一个对象的方法 让我们来实现一下Mixins 代码里首先定义两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。 12345678910111213141516171819// Disposable Mixinclass Disposable &#123; isDisposed: boolean; dispose() &#123; this.isDisposed = true; &#125;&#125;// Activatable Mixinclass Activatable &#123; isActive: boolean; activate() &#123; this.isActive = true; &#125; deactivate() &#123; this.isActive = false; &#125;&#125; 创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：12class SmartObject implements Disposable, Activatable &#123; &#125; 这里我们没有使用extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的。 我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。 也就是这样 1234567891011121314151617class SmartObject implements Disposable, Activatable &#123; constructor() &#123; setInterval(() =&gt; console.log(this.isActive + " : " + this.isDisposed), 500); &#125; interact() &#123; this.activate(); &#125; // Disposable isDisposed: boolean = false; dispose: () =&gt; void; // Activatable isActive: boolean = false; activate: () =&gt; void; deactivate: () =&gt; void;&#125; 最后，把mixins混入定义的类，完成全部实现部分。1applyMixins(SmartObject, [Disposable, Activatable]); 我们同时也需要创建这个帮助函数， 帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。1234567function applyMixins(derivedCtor: any, baseCtors: any[]) &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;) &#125;);&#125; 参考文献 https://segmentfault.com/a/1190000016305647 ————————-待完善—————————-]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Css矩阵]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90CSS%E7%9F%A9%E9%98%B5%E3%80%91%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Css%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[矩阵 matrix(a,b,c,d,e,f); a c e 分别和 X, Y, 1 相乘得出线性方程 b d f 分别和 X, Y, 1 相乘得出线性方程 这是很清楚的计算公式 rotateZ矩阵推理推理过程 参考同学的笔记同学写的很不错👍]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS全景】淘宝造物节H5原理]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90CSS%E5%85%A8%E6%99%AF%E3%80%91%E6%B7%98%E5%AE%9D%E9%80%A0%E7%89%A9%E8%8A%82H5%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[2016年的淘宝造物节邀请函， 太牛了， 不过，我们这回先不研究他的入场特效，先研究下它的全景是如何实现的 一、 载入图片, 定位至统一位置 因为20张图片被定位到统一地方, 所以所有图片都叠在一起了 此时效果 二、依照Y轴旋转图片 先说下为什么要依照y轴: 我们需要把图片围绕成一个环形, 类似于 木桶的每一块木板, 图片就是木板, 按图片的顺序旋转自各自的角度, 目前也是原地旋转, 所以图片依旧叠加在一起 素材有20张图片, 那每张的旋转角度就是 360 / 20 = 18度, 每张旋转的度数在前一张的基础上累加 18 度, 这里注意注意注意: 因为是按图片中心的Y轴旋转, 所以同一个度数会有两张图片, 比如: 0度的图片, 头在0度, 尾在90度, 然后当轮到头在90度的图片时, 他的尾在 0 度, 所以会有同一个度数两张图片的现象 此时效果 为了方便理解, 切换成上帝视角, , 所有图片围绕中心点旋转 三、将图片沿着各自Z轴向外推 现在木板(也就是每一张图片)是穿插在一起的, 我们需要让他们远离中心点, 拉开距离, 让他,们边缘连接而不是这样交叉在一起, 才能形成一个圆 先了解每一块木板怎么推 简单的画了个前后的效果图, 用的是上帝视角, 也就是你低头看一个木桶的视角 如何计算该推多少距离 做一道三角函数数学题 画的角度不太对别介意 设一共12条线, 每条长200px(此时的长就对应图片的宽) , 求将橙线移动到图中最终位置的距离 “黑线”,12345678910// 先求旋转度数// 然后取度数的一半360 / 12 / 2 = 15 度// 得知直角底边长度200 / 2 = 100px// 根据度数得知 tan, 顺便说下, tan是对边比邻边tan15°= 0.26794// 求出黑线100PX / 黑线 = 0.26794黑线约等于 373.2px js计算时注意 Math.tan 接收的是弧度单位 Math.PI 表示的是一个 Π 360度 = 2Π 计算出每张图片之间的形成的弧度 12345678 // 假设图片数量是 8 张// 因为 360 = 2Π// 1度 = Π / 180// 每份的角度是const deg = 360 / 8 // 此时为 45// 一份的弧度就是 每份弧度 * 旋转角度的一半// 最后结果就等于 Π / 图片数量( Math.PI / 180 ) * ( 45 / 2 ) ==&gt; Math.PI / 8 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vue】源码解析]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90Vue%E3%80%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[现在三大框架风起云涌， JQuery老大哥的光辉不再， 使前端成为了各路诸侯的兵家必争之地， 当然作为一名优质的前端，光跟风学框架是肯定不行的， 要知其然而知其所以然 要了解MVVM的本质原理， virtual Dom和 Diff算法解决的问题 拒绝盲目跟风 🍎diffDom优劣现在很多人都说 Vue, React 多牛， Diff算法快，不用操作Dom。 只能无语。 Diff算法不是不需要操作Dom, 而是不需要开发者去操作Dom了， Diff算法其实不快， 就算使用了virtual Dom, 还得花实现把真实Dom 转换为 virtual Dom 再去比对， 这远远没有js直接 getElementById直达目标来的快 那Diff算法不快为什么还要用呢? Diff算法其实是给那些比较随意的新手开发者准备的 看这个例子 123456&lt;!-- 原本的dom --&gt;&lt;ul id="ul"&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt; 12345678// 拿到结果不管三七二十一把旧dom全替换了$.get('/api', (res) =&gt; &#123; var _HTML = "" for(var i=0; i&lt; res.length; i++)&#123; _HTML = "&lt;li&gt;" + res[i] +"&lt;/li&gt;" &#125; $("#ul").html(_HTML)&#125;) 如果是原始的Dom操作， 有很多小白会像这个例子一样， 不管Dom需不需要更新， 他都把ajax返回的请求全部跑一边，生成HTML模板， 然后把原本的所有li都删了， 再把新的模板放进去， Dom少还看不出来， 如果Dom多了呢， 上千的Dom， 这顿操作一下就玩炸了。 况且网站优化原则就是尽量减小Dom操作， 如果是有经验的开发者， 会选择找到有变化的位置，使用append插入 📄Vue架构目录去Vue官网下载Vue源码看看， 打开里面会有一个 src目录， 里面就是整个的Vue源码 目前有6个目录， 作用分别如下 Vue.js 的组成是由 core + 对应的 ‘平台’ 补充代码构成（独立构建和运行时构建只是 platforms 下 web 平台的两种选择） Vue的核心原理就在core文件夹中， 让我们进入 core 文件夹看看 了解了目录，接下来我们就来研究Vue的双向绑定 🔗双向绑定（响应式原理） 所涉及到的技术 ✅ Obejct.defineProperty 【提供getter 和 setter】 ✅ Observer 【提供getter 和 setter】 ✅ watcher 【提供getter 和 setter】 ✅ Dep 【负责收集watcher】 ✅ Directive 【处理Vue模板指令】 Obejct.definePropertyObejct.defineProperty 是整个Vue的灵魂， 来看一下Obejct.defineProperty 如何使用1234567891011121314151617var obj = &#123;&#125;var c;Object.defineProperty(obj, 'a', &#123; get() &#123; console.log('getter') return a &#125;, set(newVal) &#123; console.log('setter') c = newVal this.a = newVal &#125;&#125;)obj.a = '234'console.log(c) // 234console.log(obj.a) // 234 它帮助Vue实现了双向绑定, 但也因为这个， Vue也只能舍弃了对低版本浏览器的支持。 它只能兼容到IE9 ， 并且市面上的polyfill实现的也并不是很好 那低版本如何代替Obejct.defineProperty ， 难道真没了它就不行吗？ 当然有： 👆 &gt; IE 7 实际上在IE7的时候就已经有暴露了 __defineGetter__ 方法， 具体用法如下1234567var random = &#123;&#125;;random.__defineGetter__('ten', function() &#123; return Math.floor(Math.random()*10); &#125;);random.__defineGetter__('hundred', function() &#123; return Math.floor(Math.random()*100); &#125;);random.ten // 随机的一个值 👇 &lt; IE 7 早年间的IE 是支持VBScript, VBScript 就可以直接写类， 并且也支持get，set方法 12345678class Test &#123; get name () &#123; &#125; set name() &#123; &#125;&#125; 🐶霸道的IE说了这么多IE的坏， 这里也带一嘴IE的好， IE能够调用EXE程序, 比如JS无法设置打印机的宽高，就可以利用ActiveObjectX来做到, 甚至可以修改word格式等等 , 所以办公类的项目离不开IE 😕MVVM 双向数据绑定流程MVVM: Model–view–viewmodel 那怎么区分这些层呢 🚀Model: Observer ✈️view : directive 🚚viewmodel: Watcher &amp;&amp; Dep 【用于连接 Model 和 view】 先看Directive, 这就是我们平时写的vue指令， 如上面举例得的v-text=&quot;times&quot;, 这就是一个指令， 一个Directive会分配一个Watcher Observer观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。订阅者模式涉及三个对象：发布者、主题对象、订阅者，三个对象间的是一对多的关系，每当主题对象状态发生改变时，其相关依赖对象都会得到通知，并被自动更新。 简单的描述就是: 你想买漫画， 但是问了报刊亭的大爷， 大爷说现在没有， 还没到货， 然后你回去了， 第二天你又去问， 大爷还是说没有， 如果你每天这样问， 大爷估计会嫌你烦。 如果这时候你把你的电话给大爷， 大爷记录到他的本子上, 当大爷的漫画到货的时候电话通知你。 这时你就是订阅者, 大爷就是发布者, 你们就存在一个发布订阅者的关系 Vue 中的Observer Observer会观察两种类型的数据，Object 与 Array对于Array类型的数据，由于 JavaScript 的限制， Vue 不能检测变化,会先重写操作数组的原型方法，重写后能达到两个目的， 当数组发生变化时，触发 notify 如果是 push，unshift，splice 这些添加新元素的操作，则会使用observer观察新添加的数据重写完原型方法后，遍历拿到数组中的每个数据 使用observer观察它而对于Object类型的数据，则遍历它的每个key，使用 defineProperty 设置 getter 和 setter，当触发getter的时候，observer则开始收集依赖，而触发setter的时候，observer则触发notify。 对 Object 的处理Observer 对象的标志就是__ob__ 这个属性，这个属性保存了 Observer 对象自己本身。对象在转化为 Observer 对象的过程中是一个递归的过程，对象的子元素如果是对象或数组的话，也会转化为 Observer 对象 对数组的处理其实 observeArray 方法就是对数组进行遍历，递归调用 observe 方法，最终都会走入 walk 方监控单个元素。而 walk 方法就是遍历对象，结合 defineReactive 方法递归将属性转化为 getter 和 setter WatcherWatcher 是将模板和 Observer 对象结合在一起的纽带。Watcher 是订阅者模式中的订阅者。Watcher 的两个参数： expOrFn 最终会被转换为 getter 函数， cb 是更新时执行的回调。依赖收集的入口就是get函数。 getter 函数是用来连接监控属性与 Watcher 的关键 只有通过watcher 触发的getter 会收集依赖，而所谓的被收集的依赖就是当前watcher.初始化时传入的参数 expOrFn 中涉及到的每一项数据，然后触发该数据项的 getter 函数；getter 函数中就是通过判断 Dep.target的有无来判断是 Watcher 初始化时调用的还是普通数据读取，如果有则进行依赖收集 Dep这个方法是在响应式的过程中调用的，用户修改数据触发 setter 函数，函数的最后一行就是调用 dep.notify 去通知订阅者更新视图。 Directive 关于编译这块vue分了两种类型，一种是文本节点，一种是元素节点 vue内置了这么多的指令，这些指令都会抛出两个接口bind 和 update，这两个接口的作用是，编译的最后一步是执行所有用到的指令的bind方法，而 update 方法则是当watcher 触发 update 时，Directive会触发指令的update方法 observe -&gt; 触发setter -&gt; watcher -&gt; 触发update -&gt; Directive -&gt; 触发update -&gt; 指令 💥源码分析Vue的完全版源码有很多判断以及其他的逻辑， 对于观看源码的人，会造成极大的困难， 因此准备了这版仿照Vue流程实现的 实现了双向绑定的简版Vue, 方便学习理解 通过这版对Vue源码的简易翻版， 我们来快速理解Vue原理 ✨ new Vue首先看一下，我们的 new Vue, 这是所有操作的入口 1234567new Vue(&#123; data: &#123; nickname: '张三', email: "123123@qq.com" &#125;, el: '#app'&#125;) 相信使用过Vue的小伙伴都明白， 这里定义了一个data， 用于存放变量， el是目标dom的选择器 🔥 new Vue 执行时做了什么1234567891011function Vue(option) &#123; var data = option.data this.data = data // 挂载 getter 和 setter observe(data, this) var id = option.el // 编译 模板 var dom = new Compile(document.querySelector(id), this) // 把编译好的模板挂载到 #app 上 document.querySelector(id).appendChild(dom)&#125; 我们可以看到， Vue其实是一个构造函数， 它接收了一个参数option， 这个option就是我们new Vue传入的那个对象因此我们可以通过option 拿到data和el两个变量， 当然这是js基础哈， 我就不再说了 拿到data后， 我们可以看到它调用了一个 observe方法, 将data和this传入( 此时this时Vue实例 ) 接下来又根据el来获取dom， 同样的将获取到的dom和this传入了 Compile中， 并且还接收了一个返回值， 然后又将这个返回值挂到了 #app上 是不是感觉， 什么鬼？, 这顿操作是啥 首先看一下疑惑的 observe， 传入了 data， this, 然后就没动静了， 既然如此， 我们就进入observe看看 找到Observe的构造函数12345function observe(obj, vm) &#123; Object.keys(obj).forEach(key =&gt; &#123; defineReactive(vm, key, obj[key]) &#125;)&#125; 可以看到，它接收一个obj和 vm， 哦， 这里就一一对应上了， 就是我们刚才传入的 data和this 来看看它做了什么， 它把obj枚举了一遍， 并将每一次的 vm, key,value 都传入一个叫 defineReactive的方法 好，那就让来看defineReactive做了什么 1234567891011121314151617181920function defineReactive(vm, key, val) &#123; // 为每个变量分配一个 dep实例 var dep = new Dep() // 配置getter和setter并且挂载到vm上 Object.defineProperty(vm, key, &#123; get() &#123; if ( Dep.target ) &#123; // JS的浏览器单线程特性， 保证整个全局变量在同一时间内， 只有一个监听器使用 dep.addSub(Dep.target) &#125; return val &#125;, set(newVal) &#123; if ( newVal == val ) return; val = newVal; // 作为发布者发出通知 dep.notify() &#125; &#125;)&#125; 我们看到， 它new了一个Dep， 这个Dep就是报刊亭大爷的电话本， 用来收集所有想买报纸或杂志的人的电话， 等到到货时就好挨个通知 然后我们看到了灵魂函数 Object.defineProperty, 嗷那我们应该就明白了， 这里的一顿操作就是为了给data里的每个属性都挂载上 getter，setter, 并且将这些属性直接转移到了vm上（Vue实例） 那既然如此， 🤪让我们看看 getter方法做了什么， 首先它判断了一下Dep.target， 如果Dep.target为true , 就调用dep的addSub方法， 这里Dep.target是啥我们先不管， 留个印象即可 然后它直接return了val 😵再来看看setter方法 setter方法接收一个新值， 首先就是判断了新值和原本的值是否相等， 如果相等就不做处理了， 如果不相等， 它将新值赋给val 然后调用dep实例上的notify方法， notify 看着名字也知道是通知， 也就是大爷挨个打电话的一个操作 好, 这一块我们理顺了， 是为了挂上getter和setter， 但又遇到了新问题dep， dep到底在干什么， 为什么被getter，setter都使用了 找到Dep的构造函数1234567891011121314151617function Dep() &#123; // 存放watcher this.subs = []&#125;Dep.prototype = &#123; // 添加watcher, 也就是添加订阅 addSub(sub) &#123; this.subs.push(sub) &#125;, // 通知所有watcher notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125; 我们可以看到， Dep构造函数中维护了一个 subs数组， 并且下面的在prototype上定义了几个方法， addSub 和notify，这不就是刚刚observe里调用的两个方法吗，哦，明白了， addSub原来是将getter中传入的 Dep.target追加到每个Dep实例都单独维护的一个subs数组中呀， notify就是遍历整个数组，挨个调用update方法（先不管update的具体实现） 好， 解决了observe方法，那我们就回到最初的Vue构造函数中, 继续往下走, 攻克剩余的绿色区域 我们可以看到，它通过el 获取到了dom, 并在new Compile 将dom 传入 那我们就找到Compile的构造函数一探究竟123456function Compile(node, vm) &#123; if(node) &#123; this.$frag = this.nodeToFragment(node, vm) return this.$frag &#125;&#125; 可以看到， 它接收了一个node， 和一个vm , 并且判断了一下node是否存在， 并将node和vm，传入了this.nodeToFragment方法， 又将其的返回结果return出去， 也就是new Compile之后返回的值 ，如下 那this.nodeToFragment这个方法做了什么， 让我们找到他1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Compile.prototype = &#123; nodeToFragment(node, vm) &#123; var _this = this // 创建文档片段 var frag = document.createDocumentFragment() var child; while ( child = node.firstChild ) &#123; // 替换变量 _this.compileElement(child, vm) // 剪贴子元素 frag.append(child) &#125; return frag &#125;, compileElement(node, vm) &#123; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // 节点类型为元素, 根据nodeType来判断 if ( node.nodeType === 1 ) &#123; // 获取自定义属性 var attr = node.attributes for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == "v-model") &#123; // 获取v-model 绑定的属性名 var name = attr[i].nodeValue // 双向绑定 node.addEventListener('input', function(e) &#123; // 给相应的data属性赋值， 进而触发该属性的set方法 // 再批处理渲染元素 vm[name] = e.target.value &#125;) // 把this ，节点， 还有v-model绑定的变量交给watcher new Watcher(vm, node, name, "value") &#125; &#125; &#125; // 节点类型为text if ( node.nodeType === 3 ) &#123; if ( reg.test(node.nodeValue) ) &#123; var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim() // 把this ，节点， 还有&#123;&#123; xxx &#125;&#125;中使用的变量交给watcher new Watcher(vm, node, name, 'nodeValue') &#125; &#125; &#125;&#125; 我们看到它在Compile原型上挂了nodeToFragment, compileElement两个方法， nodeToFragment方法接收 node, vm参数 先保存了一下this指向, 然后使用document.createDocumentFragment()方法创建了一个文档片段， 并将在while循环中传入的node节点的第一个元素赋值给 child变量，然后使用compileElement(child, vm) 将child和vm 传入, 然后将child 追加给创建好的文档片段frag, 你肯定会觉得这是个死循环, 其实不是的， 这个append对dom有剪切的效果，所以他会一直抽离node的第一个节点，直至node空了， 吸干他 完成了这顿操作后， 再将frag文档片段返回 然后我们来看看它在while中调用的compileElement方法做了什么 它同样接收node和vm , 首先就是定义一个正则， 这是用来匹配双括号的， 也就是我们平时的变量写法 然后它判断了一下这个 node的节点类型, 如果nodeType == 1, 那就说明是元素， 如果nodeType == 3 那就说明节点类型是text 如果节点类型是元素， 就利用attributes 方法，获取到该元素身上的属性, 查看是否存在v-model这样一个属性， 如果有，就获取到v-model填写的变量，交给变量name,然后监听该元素的input事件， 所以每当改元素发生input时间时，就将元素上的value根据v-model上获取到的name作为vm的key去修改vm实例上的对应的值， 因为vm上的变量已经被挂载此来触发vm 最后还创建了一个Watcher实例, 传入vm, node ,name, &quot;value&quot;这几个参数， Watcher的具体实现我们待会去看 接下来就是判断node.nodeType == 3， 也就是text类型的节点， 如果是此类节点， 就先用正则去匹配一下语法， 看看有没有使用到某个变量，如果匹配到了， 则通过RegExp.$1获取到被匹配到的值， 然后去除左右的空格， 交给变量name最后，同样的创建了一个Watcher实例, 传入vm, node ,name, &quot;value&quot;这几个参数， 出现两次Watcher， 什么情况， 到底干了啥那， 现在就来让我们看看神秘的Watcher构造函数 找到Watcher的构造函数1234567891011121314151617181920let uid = 0;function Watcher(vm, node, name, type) &#123; // 单例， 使用原因未知 Dep.target = this // 姓名 this.name = name; // 呵呵哒 uid this.id = ++uid; // 与变量相关的Node节点 this.node = node; // vm 实例 this.vm = vm; // 变量类型 nodeValue || value this.type = type; // 触发自己原型上的update方法 this.update() // Watcher 实例创建结束就把单例置空 Dep.target = null&#125; 此时我们发现了一个关键的东西Dep.target ， 这个鬼东西原来在这里， 它被赋值为了Watcher的实例， 然后在Watcher实例上挂载了name，也就是用到的变量， 还使用了一个uid， 不过这uid也是呵呵了，用数字作为uid, Vue的真实源码就这么干的， 为每个Watcher都配分一个uid， 这会造成数组空间的不连续， 引发内存泄漏 接着说， 然后他将传入的node节点， vm实例， 还有type( ‘nodeValue’ 和 ‘value’ ), 都挂到了实例上面， 并且还在调用了update方法后， 将Dep.target设为null 那我们来看下update做了啥 123456789101112131415Watcher.prototype = &#123; update() &#123; this.get() if(!batcher) &#123; // bastcher 单例 batcher = new Batcher() &#125; // 加入队列 batcher.push(this) &#125;, // 获取新值挂到自己的实例上 get() &#123; this.value = this.vm[this.name] // 触发getter &#125;&#125; 看到update方法， 首先调用了一下get方法， 这个get呢就是根据this.name从 vm实例上取一次值， 并挂到Watcher实例上的value属性上, 并且他还会触发一次getter方法，将自己加入到dep中， 也就是加入到报刊亭大爷的电话本中， 便于之后的通知 然后判断了一下window.batcher是否存在， 如果不存在就创建一个， 保证其是一个单例模式,如果存在， 就将自己(watcher实例)，通过push方法传入 看到这里，又晕了， 什么时候又冒出来一个Batcher 我们又找到Batcher的构造函数好好分析下，12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 批处理构造函数function Batcher() &#123; // 重置 has queue waiting this.reset()&#125;Batcher.prototype.reset = function () &#123; this.has = &#123;&#125; this.queue = [] this.waiting = false&#125; // 将watcher 添加到队列中Batcher.prototype.push = function (job) &#123; let id = job.id // 先根据 对象的key 看看是否已经有了这个watcher if (!this.has[id]) &#123; // console.log(batcher) this.queue.push(job) // 将watcher 的key的设为true this.has[id] = true // 延迟执行 if (!this.waiting ) &#123; this.waiting = true if ( "Promise" in window ) &#123; Promise.resolve().then(() =&gt; &#123; this.flush() &#125;) &#125; else &#123; setTimeout(() =&gt; &#123; this.flush() &#125;, 0) &#125; &#125; &#125;&#125;// 执行并情况事件队列Batcher.prototype.flush = function() &#123; this.queue.forEach(job =&gt; &#123; job.cb() &#125;) this.reset()&#125; Batcher的构造函数很简单， 就调用了一下自己的reset方法， 但好像事情远没有这么简单，我们不是在 Watcher的update方法中调用了batcher.push吗， 我也可以在这原型上找的这个方法， 首先它接收一个job参数， 也就是Watcher实例， 获取到该watcher的id, 然后使用这个id,去has这个对象上访问一下， 看看是否存在，如果不存在，在证明之前没有添加进来过， 然后将该watcher实例加到queue队列中，并将has对象中id对应的值设为true, 以防止重复加入队列 并且判断一下waiting，得知当前是否处于等待状态， 如果不是， 就将waiting改为true, 然后就是判断当前浏览器的支持情况， 将处理的任务扔到异步队列中 它这里这么做是为了，只批处理一次， 你一瞬间加入多个watcher, 很容易造成重复执行， 利用Watcher的id来过滤， 并且利用异步， 等你要加的watcher都加完了， 我再给你统一的去执行所有Watcher 也就是异步任务结束后调用的flush方法， 它在内部会遍历queue队列， 挨个的调用Watcher的cb方法在这一切都执行完成之后， 又调用了一次reset方法， 将bascher的三个属性重置为初始状态 此时关注点又回到了Watcher身上， 它的cb方法又做了什么12345678910Watcher.prototype = &#123; // ...省略其他方法 // 给dom赋值 cb() &#123; // 最终实际虚拟dom 处理结果， 只处理一次 // 虚拟dom -&gt; diff( 虚拟dom ) -&gt; 局部更新 -&gt; createElement(vNode) -&gt; render this.node[this.type] = this.value &#125;,&#125; 可以看到cb方法做的事情很简单那， 就是根据元素的值类型去修改元素对象的值， 而这个this.value早在之前调用 Watcher的get方法时就被赋上了 到这里，整个流程就走完了， 相信你还是一头雾水， 我们把整个流程来串一下 new Vue 将data中的值挂上 getter和setter 的相应方法， 然后暂且搁置，因为此时还无人调用getter和setter 通过 Compile解析模板， 挨个递归#app下的dom, 判断元素类型， 如果是元素，并且使用了v-model， 就绑定一个input事件, 如果是文本类型节点,就去匹配是使用了语法， 最后为他们都创建了一个watcher 每个watcher 用来保存相关的元素对象， vm实例，使用的变量 以及元素值类型, 并将自己的实例交给， Dep.target， 并触发自己的update方法，update方法又会调用get方法， get方法又会触发该变量的getter， 这也就使得getter中可以将该watcher放入dep实例中， 最后将自己也放入Bacher中，用以批处理以及将Dep.target置空 Batcher是个单例， 根据Watcher的id, 它用来过滤重复传入的Watcher, 保证一个Watcher只触发一次, 并将更新事件丢入异步，等当前的连续操作执行完成后去调用Watcher的cb方法更新dom 之后用户修改了变量, setter又会调用dep这个发布者来发出通知， 相关的Watcher的update方法再次被调用， 又会加入batcher , batcher等待异步完成后又调用Watcher的cb方法更新dom 到这里就整个串完了，但是感觉废话还是有点多， 再简化一点流程: new Vue –&gt; Observe 挂载 setter 和 getter –&gt; Compile 编译模板 –&gt; 为每个指令分配一个watcher –&gt; 创建时会调用一次watcher.update 将自己加入到batcher的队列 –&gt;并且此时会触发 getter 将watcher加入dep –&gt; batcher 统一来处理watcher后初始化自己 –&gt; 当用户修改某个变量时 –&gt; dep通知watcher –&gt; watcher又被加入batcher处理 –&gt; watcher 更新dom Vue的batcher还是实现的不是很好， 缺少调度机制， 这点上还是React Fiber更优秀点，Fiber如果遇上了长时间的任务会选择放弃， 避免阻塞进程。 😕好了， 神秘的Vue源码已被揭开面纱， 但这仅仅是简易版的实现， 真实的Vue非常庞大， 还有更多的内容， 这里只是让大家明白MVVM的核心原理 项目源码: https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue 优质文献: 汤姆大叔的观察者模式]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具目录]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%B7%A5%E5%85%B7%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这里存放各种可能用到的用不到的东西， 真用到时方便查找😄 当然平日里经常用到的， 耳熟能详的， 我就不放进来了， 主要是起个备忘录的作用 CSS兼容查询 https://caniuse.com/ https://cssdb.org/ 动画 贝塞尔: http://cubic-bezier.com/#.17,.67,.83,.67 可生成matrix的网站 名称 网址 matrix3d http://ds-overdesign.com/transform/matrix3d.html CSS-Matrix3d https://github.com/Zhangdroid/CSS-Matrix3d matrix http://meyerweb.com/eric/tools/matrix/ tools http://www.f2e.name/case/css3/tools.html 高逼格 web component CSS: https://css-doodle.com/ PostCss 值得收藏的插件 功能 插件名 运行时变量 POSTCSS-CUSTOM-PROPERTIES 与SCSS一致的变量实现 POSTCSS-SIMPLE-VARS 实现类似SASS的@MIXIN的功能 POSTCSS-MIXINS 实现类似SASS的继承功能 POSTCSS-EXTEND 实现类似SASS的IMPORT POSTCSS-IMPORT 面向未来 CSSNext 修复过去（兼容IE，zomm、一像素留白等） CSS Grace Node框架 功能 插件名 周边生态 帮助实现DI的库 Awilix awilix-koa 实现控制反转&amp;构造注入的框架 InversifyJS inversify-koa-utils webpack4功能性能类 功能 插件名 自动插入html及静态文件 HtmlWebpackPlugin【配置自动注入loading（监测资源）】 抽离css文件 MiniCssExtractPlugin 清空指定目录 CleanWebpackPlugin js 深度 tree sharking 基于ES6模块 webpack-deep-scope-plugin css tree sharking PurifyCSSPlugin 多核打包件 [需要babel] uglifyjs-webpack-plugin[官方], happypack 前端缓存负载【自动生成缓存文件】 Webpack Manifest Plugin js 压缩 以及 es压缩 多核压缩 webpack-parallel-uglify-plugin, happypack hint css 多核压缩css css-nano, optimize-css-assets-webpack-plugin js 转 ast静态语法分析树 acorn , acorn-walk 能对html进行hint 以及 fix 的插件 html-minifier, html-minifier-lint 搬运静态文件 copy-webpack-plugin 优化体验类 功能 插件名 监测 webpack 打包速度 speed-measure-webpack-plugin 打包成功通知 webpack-build-notifier 显示打包进度 progress-bar-webpack-plugin 信息面板优化 webpack-dashboard[需要配置Pagejson]， webpack-jarvis[网页中浏览] 修改cmd 标题 node-bash-title[ github ][cmder 无效] loader 功能 插件名 缓存Loader结果 cache-loader TypeScript运行工具 功能 插件名 周边生态 在node中不用编译就运行 ts-node ts-node-dev 热重启 Linuxvim 快速学习vim的网站: https://vim-adventures.com/ 算法学习帮助 算法过程可视化: https://algorithm-visualizer.org/branch-and-bound/binary-search]]></content>
      <categories>
        <category>目录</category>
      </categories>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css分层&命名规范]]></title>
    <url>%2F2019%2F03%2F16%2Fcss%E5%88%86%E5%B1%82-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[为什么要分层? CSS有语义化的命名约定和CSS层的分离， 将有助于它的可扩展性， 性能的提高和代码的组织管理。 避免大量的样式、 覆盖、 权重和很多！important, 分好层可以让团队命名统一规范， 方便维护。 有责任感地去命名你的选择器 有哪些分层理论? SMACSS BEM SUIT ACSS ITCSS BEMBEM和SMACCS非常类似， 主要用来如何给项目命名。一个简单命名更容易让别人一起工作。 比如选项卡导航是一个块(Block)， 这个块里的元素是其中标签之一（Element）, 而当前选项卡是一个修饰状态( Modifier ) block - 代表了更高级别的抽象或组件 block__element - 代表.block的后代， 用于形成一个完整的.block的整体。 block–modifier - 代表.block 的不同状态或不同版本。 修饰符使用的是_, 子模块使用的是__符号。 ( 不同一个-的原因是因为CSS单词连接 ) 12345678&lt;!-- container 是大容器 --&gt;&lt;div class="container"&gt; &lt;div class="menu"&gt; &lt;div class="menu--item menu--item__active"&gt;首页&lt;/div&gt; &lt;div class="menu--item"&gt;新闻&lt;/div&gt; &lt;div class="menu--item"&gt;消息&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【css-doodle】 css web-component入门]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90css-doodle%E3%80%91css-web-component%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[首先祭出 css-doodle的官网， 真的老厉害了， 使用它能够轻松的实现各种炫酷特效 https://css-doodle.com/ &lt;css-doodle /&gt;基于 Shadow DOM v1和 Custom Elements v1。您可以立即在最新的Chrome，Safari和Firefox上使用它，而无需使用polyfill。该组件将根据其中的规则（纯CSS）生成div网格。您可以使用CSS轻松操作这些单元格，以获得图形模式或动画图形。限制是CSS本身的限制。 既然它这么牛逼， 那怎么用呢？ 我们一起来搭几个demo css-doodle入门 此处用到的语法或api有不了解的 请看页面下方的“释义” 区域 动手过程中需要注意， 不要在css-doodle内部写注释， 会导致样式无效 首先搭建好运行css-doodle的环境12345678&lt;!-- 引入CDN --&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.5.1/css-doodle.min.js"&gt;&lt;/script&gt;&lt;!-- 页面上加入 css-doodle --&gt;&lt;css-doodle&gt;&lt;!-- 我们将在这里写代码 --&gt;&lt;/css-doodle&gt; 此时如果我们打开页面， 你会发现是空空如也的， 因为这个元素既没有宽高也没有背景颜色， 我们当然看不到。 现在我们给他加点料。 12345&lt;css-doodle&gt; width: 100px; height: 100px; background: red;&lt;/css-doodle&gt; 此时我们再看看页面， 就出现了一个100 x 100的红色小方块， 好，这个相当于hello world 级别的练习就完成了， 我们再来点难的： 我想要一个10 x 10 个的小方块组成的大正方形! 正好我们可以借此尝试使用一下它提供的API 123456&lt;css-doodle&gt; :doodle &#123; @grid: 10x10 / 500px; &#125; background: #60569e;&lt;/css-doodle&gt; 出现了！ 我们要的 10 x 10 个小方块组成的大正方， 并且还把颜色换成了骚骚的紫色 好既然实现了， 那现在需求升级了 那我要10个长方形怎么办， 并且我还要长短不一的！ 我去，还要长短不一， 咋整呢 别慌 机制的你一定可以在官网找到有一个获取当前小方块顺序的的参数@index 严格的来说他会返回当前单元格的索引值 既然有方法了那我们也有思路了， 二话不说开始动手。 12345678910&lt;!-- 首先把 10 x 10 小方块变为10个长方形 --&gt;&lt;!-- 然后根据 @index 获取当前单元格的索引 --&gt;&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; background: #60569e; @size: calc(@index() * 1vmin);&lt;/css-doodle&gt;&lt;!-- 根据 index 这个索引值乘以高度 --&gt; duang! 这就是我们想要的结果了， 虽然还有点不完美， 其实每个紫色都是一个正方形， 但所在的单元格是长方形没跑了 我们再给他加上border-radius: 50%; 它就变成10个球了 此时需求又来了 甲方：可不可以弄10个光环？还是渐变的那种? 行吧， 试试喽谁怕谁 我们可以举一反三， 利用@index这个好东西来修改hsla产生不同的颜色， 当然修改rgba 也是可以的 123456789101112&lt;!-- 根据index 每个的单元格递增20的色调， 再调整出不同的透明度 --&gt;&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; border-color: hsla( calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8) ); @size: calc(@index() * 10%); border-style: dashed; border-radius: 50%;&lt;/css-doodle&gt; 好， 甲方爸爸， 你的需求我做到了 甲方: 还不够，我要的是同心圆 我。。。。。 得嘞，您说是啥就是啥 同心圆， 你第一反应想到的是不是使用position: absolute; ?不 ，那太low 了我们只需要 @place-cell: center; 这个参数就搞定了， 它会将每个单元格都摆放至中间 12345678&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; @place-cell: center; &lt;!-- ...省略之前的代码 --&gt;&lt;/css-doodle&gt; 然后去看一下效果， 卧槽 进阶基础学的差不多了， 其他的一些api有了上面的参照都应该思路了吧 既然是进阶篇， 我们就做点难的， 我们看看能不能利用这些特性和 CSS动画结合一下 我们先让光环变粗一点， 让他呈现扇叶的形状 1border-width: calc(@index() * 10px); 然后让我们用上 keyframes ， 为他添加动画 为每个单元格注册几个css变量（css的新特性）， 变量--speed控制动画的持续时间，也就是速度。 --start 控制当前光环的起始角度 --direction: 控制方向， 因为turn表示一圈， 所以 1turn 就是正的转一圈,-1turn 就是反着转一圈， 利用@pick方法来随机取一个值 1234567891011121314151617181920212223&lt;css-doodle&gt; &lt;!-- ...省略之前的代码 --&gt; &lt;!-- 动画执行时间在20秒 - 40秒之间取值--&gt; --speed: @rand(20s, 40s); &lt;!-- 360度里取随机数 --&gt; --start: @rand(360deg); &lt;!-- 顺时针 或 逆时针 --&gt; --direction: calc(var(--start) + @pick(1turn, -1turn)); animation: demo var(--speed) linear infinite; @keyframes demo &#123; form &#123; &lt;!-- 填入起始角度 --&gt; transform: rotate(var(--start)); &#125; to &#123; &lt;!-- 随机顺时针和逆时针旋转 --&gt; transform: rotate(var(--direction)); &#125; &#125;&lt;/css-doodle&gt; 看看效果 炫酷不？ 能不能再酷一点？ 可以， 我们再给他添一笔， 给他加上一个自定义的贝塞尔 贝塞尔可以去这个网站，根据需要生成 http://cubic-bezier.com/#1,.25,.83,.67 然后我们你所需要的贝塞尔去更改animation 的参数1animation: demo var(--speed) cubic-bezier(0,.88,.42,.99) infinite; 根据贝塞尔曲线完成了加速减速的动画效果 😎cool~ 还有更多更酷的特效等着大家去探索~ 切记css-doodle 中不能写注释，大家拷贝的时候记得删掉 释义 :doodle 选择器会创建一个display: grid; 的布局 @grid提供布局， 用法为 @grid: 行 x 列 / 总宽高 @index 返回当前单元格的索引 hsla 此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度。 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% A：Alpha透明度。取值0~1之间。 @place-cell 调整单元格相对于网格放置。 @pick： 从给定列表中随机选择一个值。 turn: 转、圈（Turns）。一个圆共1圈 ( 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad ) 1turn 就是1圈 完整的代码1234567891011121314151617181920212223242526&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; @place-cell: center; border-color: hsla( calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8) ); border-width: calc(@index() * 10px); @size: calc(@index() * 10%); border-style: dashed; border-radius: 50%; --speed: @rand(20s, 40s); --start: @rand(360deg); --direction: calc(var(--start) + @pick(1turn, -1turn)); animation: demo var(--speed) cubic-bezier(0,.88,.42,.99) infinite; @keyframes demo &#123; form &#123; transform: rotate(var(--start)); &#125; to &#123; transform: rotate(var(--direction)); &#125; &#125;&lt;/css-doodle&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web-component</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CSS混合模式更改图片颜色]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%88%A9%E7%94%A8CSS%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E6%9B%B4%E6%94%B9%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[CSS3 新增了一个很有意思的属性 mix-blend-mode ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。 混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。 开始动手吧 ~ 尝试修改图片物体颜色首先我们创建一个Input框和一个 Img标签（其实这里我选择的图片不是很好）1234&lt;body&gt; &lt;input type="color" /&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553336864&amp;di=2f41edc8eedbf09fb1d106545acaed5f&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic44.nipic.com%2F20140723%2F19276212_171901262000_2.jpg" alt=""&gt;&lt;/body&gt; 然后我们将图片撑满屏幕， 将Input也撑满屏幕， 将input覆盖至图片之上， 然后为input 添加上混合模式mix-blend-mode: hue; 因为input框自带颜色， 所以当用户切换颜色时也就能不依靠JS 即时生效 123456789101112&lt;style&gt;html,body, input, img &#123; width: 100%; height: 100%;&#125;input&#123; position: absolute; top: 0; left: 0; mix-blend-mode: hue;&#125;&lt;/style&gt; 过程记录原图: 添加上了混合模式(变灰是因为color选择器默认是黑色): 切换颜色中: 切换后: 虽然有点丑但我们成功了~ 更多可能性利用整个混合模式的特性， 我们还能做出更多的东西， 比如利用三原色实现彩色loading、 万花筒等等炫酷动画， 可以看看参考文献中的例子， 非常的不错 参考文献 https://www.cnblogs.com/coco1s/p/6829372.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js与CSS变量操作]]></title>
    <url>%2F2019%2F03%2F16%2FJs%E4%B8%8ECSS%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[就目前来说CSS变量已经不是什么新鲜的东西了， 渐渐的我们可以在浏览器中尝试使用它， 和SCSS、 LESS 等预处理器不同的是， CSS的变量机制是浏览器天生支持的， 并且浏览器还对其做了优化， 减少了我们使用JS 去操作CSS变量造成的重绘和重排 一起来看看如何操作吧~ 变量虽好， 不可滥用哦 定义一个简单的变量12345678/* 定义css 变量 */:root &#123; --backgroundColor: pink;&#125;body &#123; background-color: var(--backgroundColor);&#125; 创建一个按钮123&lt;body&gt; &lt;button id="btn"&gt;点我改变背景&lt;/button&gt;&lt;/body&gt; 获取root元素并绑定按钮的点击事件12345678&lt;script&gt;var root = document.documentElementbtn.onclick = function() &#123; // 将变量修改为天蓝色 root.style.setProperty('--backgroundColor', 'skyblue')&#125;&lt;/script&gt; 结果对比点击前 按钮点击后 非常Nice~ 利用这个特性实现更多的可能吧！]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS如何了解新知识]]></title>
    <url>%2F2019%2F03%2F16%2FCSS%E5%A6%82%E4%BD%95%E4%BA%86%E8%A7%A3%E6%96%B0%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[平时闲着无聊的时候多去看看MDN或者一些国外的网站， 多试试一些新特性， 说不定就会有新的发现 并且还可以尝试着参与MDN的文章翻译及国外优质技术文章 MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference]]></content>
      <categories>
        <category>学习技巧</category>
      </categories>
      <tags>
        <tag>学习技巧</tag>
        <tag>学习渠道</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PostCss】使用明天的CSS]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90PostCss%E3%80%91%E4%BD%BF%E7%94%A8%E6%98%8E%E5%A4%A9%E7%9A%84CSS%2F</url>
    <content type="text"><![CDATA[通过PostCss作为CSS的后处理器， 可以根据浏览器的市场份额， 选择性的将一些最新的CSS新特性编译成浏览器支持的语法 当然国内的情况有点不一样 新特性举例比如这个CSS变量:他存储了媒体查询的规则， 在多个媒体查询的情况下就不用重复写了12345@custom-media --viewport-medium (width &lt;= 50rem);@media (--viewport-medium) &#123; body &#123; font-size: calc(var(--fontSize) * 1.2); &#125;&#125; 那这个属性浏览器兼容不理想怎么办？ 别担心， 交给PostCss, 经过处理， 我们可以看到，生成了一个规规矩矩的媒体查询代码 123@media (max-width: 50rem) &#123; body &#123; font-size: 1.2rem; &#125;&#125; 更多演示 编译前后以 —— 分割 自定义选择器1234@custom-selector :--heading h1, h2, h3, h4, h5, h6;:--heading &#123; margin-top: 0 &#125;/* ------------------------------------ */h1,h2,h3,h4,h5,h6 &#123; margin-top: 0 &#125; 自动一倍图(1X)和二倍图(2X)123456789101112131415161718192021222324/* image-set function */.foo &#123; background-image: image-set( url(img/test.png) 1x, url(img/test-2x.png) 2x );&#125;/* ------------------------------------ *//* 默认状态 */.foo &#123; background-image: url(img/test.png);&#125;/* 满足 设备上物理像素和设备独立像素( device-independent pixels (dips) )的比例 */@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) &#123;.foo &#123; background-image: url(img/test-2x.png);&#125;&#125; any-link, 补齐标签的剩余的所有状态， 这是为了防止某些样式不生效1234567891011121314151617181920212223a &#123;color: var(--highlightColor);transition: color 1s; /* autoprefixed ! */&#125;a:hover &#123; color: gray(255, 50%) &#125;a:active &#123; color: rebeccapurple &#125;a:focus &#123; background-color: rgb(255 153 0 / 33%); outline: 3px solid hsl(1turn 60% 50%); &#125;a:any-link &#123; color: color(var(--highlightColor) blackness(+20%)) &#125;/* --------------------------------- */a &#123; color: rgb(89, 185, 204); -webkit-transition: color 1s; transition: color 1s; /* autoprefixed ! */&#125;a:hover &#123; color: rgba(255, 255, 255, 0.5) &#125;a:active &#123; color: #639 &#125;a:focus &#123; background-color: rgba(255, 153, 0, .33); outline: 3px solid hsl(360, 60%, 50%); &#125;a:link,a:visited &#123; color: rgb(89, 142, 153) &#125; 还有很多， 不一一举例了， 比如： 各个浏览器的滤镜filter兼容 选择器正则 css嵌套 如何让PostCS支持嵌套 本环境基于webpack npm地址: https://www.npmjs.com/package/postcss https://www.npmjs.com/package/postcss-loader 1234567891011121314.container &#123; /* 一定要带上 &amp; 才会编译 */ &amp; .menu &#123; height: 40px; background: sandybrown; &amp; .menu--item &#123; height: 40px; color: skyblue; &amp; .menu--item__active &#123; color: pink; &#125; &#125; &#125;&#125; 首先在项目的根目录中创建一个文件postcss.config.js 相关依赖安装就不说了， 真的缺了也会报错提示的 我们将会在里面做PostCSS的相关配置 12345module.exports = &#123; plugins: [ require('postcss-nested') ]&#125; 然后接下来是配置 Loader ， 进入webpack 配置css loader 的地方， 我们在css loader 后面加上PostCss 的loader123456789101112131415161718192021222324252627rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'css-loader', &#125;, // --------------新增区域--------------- &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: (loader) =&gt; [ require('postcss-preset-env')(&#123; /* 这里要改成 0 否则不一定编译嵌套 */ stage: 0, features: &#123; 'nesting-rules': true &#125; &#125;) ] &#125; &#125; // --------------新增区域--------------- ] &#125;] 像这样，记得把 stage 这个参数修改为 0 ， 因为PostCss 会根据这个参数分为好几个阶段，阶段太高它是不处理嵌套的。 我们运行一下看看 1234567891011121314.container &#123; /* 一定要带上 &amp; 才会编译 */&#125;.container .menu &#123; height: 40px; background: sandybrown&#125;.container .menu .menu--item &#123; height: 40px; color: skyblue&#125;.container .menu .menu--item .menu--item__active &#123; color: pink;&#125; 大功告成😄~ 想知道有用的PostCSS的插件大纲，可以在本站内搜索: CSS插件 相关的网站 PostCss: https://postcss.org/css next: http://cssnext.io/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins构建前端持续集成]]></title>
    <url>%2F2019%2F03%2F16%2F%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[安装JDK 直接使用yum 安装的是 openjdk , 和sun 公司发布的jdk有略微区别， 但这里我们并不需要使用java,所以使用最快的方式安装 1yum install -y java 安装jenkins 添加Jenkins库到yum库，Jenkins将从这里下载安装。 123wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.reporpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.keyyum install -y jenkins 添加Jenkins库到yum库，Jenkins将从这里下载安装。12wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpmrpm -ivh jenkins-2.7.3-1.1.noarch.rpm 配置jenkis的端口 jenkins 的默认端口为 8080 ， 为了避免和其他的应用程序冲突， 所以建议修改一下默认占用的端口 1vim /etc/sysconfig/jenkins 找到修改端口号： JENKINS_PORT=”8080” 启动jenkins 1service jenkins start/stop/restart 安装成功后Jenkins将作为一个守护进程随系统启动 系统会创建一个“jenkins”用户来允许这个服务，如果改变服务所有者，同时需要修改/var/log/jenkins, /var/lib/jenkins, 和/var/cache/jenkins的所有者 启动的时候将从/etc/sysconfig/jenkins获取配置参数 默认情况下，Jenkins运行在8080端口，在浏览器中直接访问该端进行服务配置 Jenkins的RPM仓库配置被加到/etc/yum.repos.d/jenkins.repo 配置阶段安装好jenkins 后 ， 我们就可以根据刚才所设置的端口号访问 jenkins 服务了 比如进入 127.0.0.1:8081 访问jenkins 首先会看到让我们输入初始密码 它提示我们进入 /var/lib/jenkins/secrets/initialAdminPassword 查看 输入密码无误后， 就是提示我们安装对应的插件了， 左边是推荐安装， 右边是自定义安装， 这里我们建议点击 推荐安装 安装过程可能稍长 这时我们创建一个 Jenkins 账户，一定要牢记你的输入账号和密码， 用作之后的登录 创建账户之后， 会显示一个 jenkins 的资源根路径， 一般不需要修改， 保持默认即可 之后就是愉快的jenkins 之旅啦 补善插件阶段我们要做的前端持续集成， 所以 jenkins 默认安装的插件 并不能完全的满足我们的需求 进入jenkins 主页面后， 找到插件管理 首先查看我们必要的插件是否安装好了 NodeJs Plugin Publish Over SSH GitHub 如果发现没有安装的就安装， 查漏补缺 变量及远程服务器基本配置插件安装好后, 进入系统设置 界面, 进行变量的相关配置, 这里就展示几个可以修改的参数, 大部分都可以不用动, 使用默认就好 管理员邮件地址, 推荐填写, 当jenkins 工作完成后会把 构建信息发送至此邮箱 (这条选择填写) 可以选择配置 github 服务器, 并且可以配置多个, 因为你的项目代码有可能在多个服务器上 比较重要的就是这里了 , 配置远程服务器, 也就是你的发布地址 点击新增添加你的服务器 点击新增后, 这里有几个关键的参数, 需要注意 连接目标服务器肯定需要登录, 下面几个参数就是对应的验证参数, 你可以输入固定的密码, 也可以告诉Jenkins 你的本地私钥路径或私钥的内容, 前提是你配置了 ssh 的免密登录 填写密钥路径这里你很有可能会出现权限不够的错误， 如下图， 因为jenkins的在运行时会自动的创建一个名为jenkins的用户， 而这个用户的权限不够，无法访问你的目录 解决方案有两个: 把密钥切换至一个普通用户可以访问的目录， 并修改密钥的所属用户身份和访问权限 把jenkins 的运行身份修改为 root, 但是会有点安全性问题 本次实践以学习为目的， 所以这里我选择了第二钟 相关操作文章: https://blog.csdn.net/jeikerxiao/article/details/80768949 ssh 免密配置成功后， 我们就可以开始创建一个自己的任务了 创建任务阶段回到主页， 找到新建任务 进入新建任务后， 有几种不同的项目， 我们这里选择 自由风格， 并且输入项目名称 创建好项目后就会自动进入 当前项目的配置文件中 首先我们看到General, 这是一些全局的配置， 在这里我们可以写上该项目的描述 General的后面几个类目是构建项目阶段几个比较大的步骤和流程 如果你要配置的“github”项目， 可以在Git这里打上勾 并且填写上仓库地址 及 分支 即可， 如果需要填写账户密码， 则可在Credentials 处新增配置 接下来是看看构建触发器， 这里的填写根据你的工程需要， 可以配置定时任务 或 多任务构建 本次演示我并没有用到 现在来到我们的重点构建 ， 我们可以添加步骤，我们可以看到能够支持 Node、shell 、批处理等等方式 这些添加的步骤会按顺序执行， 我们需要shell 脚本来运行npm 命令 所以我创建了 shell的操作步骤 基于此， jenkins 就会自动帮我们做好 测试与打包的步骤， 在此之后， 我们需要将测试通过的项目代码推送到远程发布服务器上， 所以， 我们添加一个send files or execute commands over SSH 步骤， 建议新旧文件搞两个文件夹存放， 这样可以先删除掉旧文件再把新文件拷贝过去 deploy文件参考 你可能遇到的问题命令无效或不存在 这里拿npm举例， 其他命令如:node ,都是同理 因为全局的命令需要设置软连接 Jenkins 才可以访问的到 如何设置: 先查看一下你的 npm 在哪 whereis npm 这个/usr/local/bin/npm 就是你的npm所在位置 ( 使用带 local 的地址) 我们来创建 软连接, 这里使用刚刚获取到的npm ln -s /usr/local/bin/npm /usr/bin 如果出现无法修改的情况， 那我们就将他强制更改 😄 ln -sf /usr/local/bin/npm /usr/bin 再去构建一次Jenkins 任务 看到控制台输出， 现在npm 可以正常运行了 持续集成的必要条件 必须有github 、svn或私有git服务器 完整的项目 test 接口测试 其他的测试内容 CI 平台 项目代码要提交到Github、 svn等服务器上 保证代码在开发机的正常 bug 运行环境 ( 引用的包要写入packa) 保证jenkins 环境一切正常 发布服务器上也要存在基础的运行环境(不包括项目本身引用的包) 必要的静态资源服务器 配置jenkins的自动化处理流程 参考文章: https://www.cnblogs.com/loveyouyou616/p/8714544.html]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Jenkins</tag>
        <tag>Centos</tag>
        <tag>前端持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css预处理与后处理器]]></title>
    <url>%2F2019%2F03%2F16%2Fcss%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预处理器在前两年是非常流行的技术， 但是这两年发展的却不怎么有起色， 因为人们渐渐发先即使代码经过了预处理的的编译， 还要经过后处理， 并且PostCss 的崛起拥有了预处理器的功能， 可以完美代替预处理的工作， 并且可以做到让人们使用下一个版本的css 一旦预处理器阶段代码出现污染，预处理器的事就算是白干了， 不如直接交给后处理器， 所以使用预处理器的意义越来越小了 预处理器具有的能力 变量 混合(Mixin) Extend 嵌套规则 运算 函数 Namespaces &amp; Accessors (命名空间和访问器) scope 注释 后处理器的能力 CSS 压缩 CLEAN-CSS 自动添加浏览器前缀 Autoprefixer CSS更加美观排序 CSScomb Rework取代stylus 后处理器发热 前后通吃的 PostCss 他们是如何处理的CSS预处理器预处理器， 如： sass 它会先将他的语法转换成 AST–抽象语法树（Abstract Syntax Tree ）, AST是程序的一种中间表示形式， 然后遍历 AST 这棵树， 将对应想要的结果生成为CSS PostCssPostCss 改变了之前对CSS的处理流程， 它提供了一套插件的机制， 对于PostCss来说，自己是一套空的工程，它为插件提供了CSS数据， 根据配置的不同插件， 产生不同的功能]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手摸手AngularJs入门教程]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%89%8B%E6%91%B8%E6%89%8BAngularJs%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[AngularJs 是一款来自Google 的前端JavaScript框架， 也是SPA框架。 AngularJs框架的体积非常小， 但是设计理念和功能却非常强大， 极大地简化前端开发的负担， 它快速成为了JavaScript的主流框架， 帮助开发者从事web开发。 这里我们用AngularJs7的练手吧 起步 请确保电脑已安装了Node.js 首先是全局安装脚手架1npm install -g @angular/cli 安装好后查看一下版本 ng –version 确认ng命令存在后就可以开始创建我们的第一个 Angular 项目了12# 创建项目 project 替换为你的项目名称ng new project 当你输入命令后他会问你需要的配置， 这里附上我的选择， 大家可以参照 你是否需要添加路由？ —- yes 选择你喜欢的css 风格 —- SCSS 选择好后， 就会进入漫长的安装了 安装好后， cd 进入到项目所在的目录， 运行 ng serve 命令， 并打开http://localhost:4200/ 查看我们第一个 Angular项目12345678# 进入你的项目目录cd project# 启动项目ng serve# 如果你需要 可以生产环境运行ng serve --prod --aot 基本的路由配置 如果你不知道路由是什么， 你只需要先理解路由帮助我们实现切换页面的功能因为之前我们在构建项目时就选择了加入路由， 因此也省去了很多配置过程， 现在，我们来看看怎么用吧， 首先想使用路由， 得需要再创建一个”页面”（这里指组件）， 这样才能通过切换看出是否实现了路由， 那如何创建一个组件呢？ Angular 给我们提供了非常多的创建命令， 组件也可以一键的生成 我们来创建一个 Demo 组件 ng g c Demo 等待片刻， 安装好后 我们发现项目文件中的 app 目录下多了一个文件夹 里面有配套的 模板文件 样式文件 测试文件 ts 脚本文件 既然有了组件， 那我们现在需要为这个路由分配相应的访问路径 进入 app/app-routing.module.ts 这个文件 我们首先导入刚刚创建的Demo组件， 再 routes数组中，分配一个用于访问的path, 并和导入的DemoComponent关联上 如下: 123456789101112131415161718192021// ------------新增区域------------import &#123; DemoComponent &#125; from './demo/demo.component';// ------------新增区域------------import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ // -----------新增区域------------- &#123; path: "demo", component: DemoComponent &#125; // ------------新增区域------------];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; 然后进入 app/app.component.html 文件中找到 &lt;router-outlet&gt;&lt;/router-outlet&gt; 刚才配置的路由就会显示在这个标签所在的位置，为了减少一点干扰，我们把没有用的信息删除 !component19html切换后](http://img.nixiaolei.com/2019-03--17-17-27-25.png app.我只留了一张图片, 然后我们进入 app/demo/demo.component.html 文件中 原本是123&lt;p&gt; demo works!&lt;/p&gt; 我们改成明显一点的内容 千万注意dom结构别错了， dom结构错误会造成白屏，坑的是没有错误信息 123&lt;div&gt; &lt;h1&gt;我是Demo 页面&lt;/h1&gt;&lt;/div&gt; 我们看看是否配置成功了 首先，刚进入， 只有一张图片 让我们切换至/demo 我们可以看到， 刚刚为demo组件编写的文字成功显示出来了， 并且是位于图片下方， 这跟我们之前 app/app.component.html 中所做的配置一样 ——————–待完善————————- 常用的命令 把 XXX 替换成你要的名字 ng g cl xxx // 创建一个新类 ng g c xxx // 创建一个新组件 ng g d xxx // 创建一个新指令 ng g e xxx // 创建一个新枚举 ng g m xxx // 创建一个新模块 ng g p xxx // 创建一个新管道 ng g s xxx // 创建一个新的指服务 参考文献 https://github.com/angular/angular-cli/wiki]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中如何使用本地图片]]></title>
    <url>%2F2019%2F03%2F16%2Fhexo%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[首先需要修改_config.yml配置文件post_asset_folder项为true 使用命令创建博客1hexo new 你的文章名称 他会生成.md文件及一个对应的文件夹， 我们将图片放到该文件夹中 方法一在文章中这样插入图片1&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125; 效果如下: 方法二 这个方法在首页无法正常预览图片 安装一下这个插件 1npm install hexo-asset-image --save 在文章中这样插入图片1![这是一张图片](xxxx.png) 效果如下: 参考文献 http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
