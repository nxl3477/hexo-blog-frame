<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript事件机制]]></title>
    <url>%2F2019%2F03%2F26%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[首先我们都知道JavaScript是单线程的， 当然现在浏览器中 HTML5 为我们提供了Web-Worker, 但JavaScript本质上还是一门单线程的语言， 这也是为了保持JavaScript 的简单易学，并且这也和DOM有关，因为如果 JavaScript 是多线程的， 一个县城增加了 DOM，一个删除了DOM， 那该听哪个线程的 所以JavaScript 放弃了多线程 事件机制单线程当遇到比较费事的操作带来的后果就是浏览器卡死， 那怎么办？为了应对这些问题， JavaScript将事件分为了 同步任务 异步任务 所有的事件任务都被加入到栈内, 栈的特点是先入后出， 如下图 看图中， 最开始调用的函数被压在了最下面， 直到最后才出栈 当我们递归书写不规范时， 就会撑爆函数的执行栈， 也就是爆栈 微任务与宏任务的区别我们可以把事件处理机制想象成银行柜台的柜员， 柜员每次只能处理接待一个客户， 就和JS一样是单线程的， 每一次的事件循环就是一个来办理业务的客户， 这个客户就是宏任务， 当前的客户结束之后， 柜员叫号，继续接待下一个客户， 也就是开始下一个宏任务 能进入任务队列的都是已完成的异步操作， 当你注册了异步事件，但还未完成， 就好比你取了排队的票子， 但是人离开了，有可能先去吃饭，有可能先去逛街， 于是当轮到你的号码时， 银行柜员会先跳过你， 当你回来时， 你依旧需要重新排队 在宏任务期间， 可以追加微任务的， 或者说微任务是可以插队的， 就像在柜台办理业务中， 一位大爷在办完自己的本来的业务后， 柜员通常都会问还有什么需要办理的业务， 这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。 所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。 所以在当前的微任务没有执行完成时，是不会执行下一个宏任务的 优先级不管是微任务还是宏任务， 都是异步任务， 当他们的事件处理完成后， 最终都是要归回到同步事件队列处理的， 也就是主进程， 既然是主进程，主进程又要负责浏览器的渲染， 那这三者之间的优先级是什么呢 因为微任务实际上是宏任务的其中一个步骤， 也就是下一次的宏任务到来之前必然得先执行完当前的宏任务的微任务, 所以可以这么看: 浏览器渲染 &gt; 微任务 &gt; 宏任务 微任务会插队， 插入每一次的执行栈末尾， 宏任务比较可怜， 只要存在微任务，就会被插队，顺序就会往后 看下图， 我们可以理解微任务和微任务分别维护着一个队列， 微任务的箭头指向靠前， 表示微任务会优先于宏任务加入事件队列， 宏任务会延迟加入 理论上UI渲染的优先级是比较高的， 但实际上如果你的微任务或宏任务之内， 出现了死循环或大量计算的情况， UI渲染就会被阻塞住， 无法进行，也就是页面卡死状态， 毕竟js单线程 EventLoop每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。（检查还有没有微任务需要处理）而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。（结束本次宏任务、检查还有没有宏任务需要处理）这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。(这是个非常简易的描述了，实际上会复杂很多) 而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑： 宏任务例子 API 浏览器 Node I/O ✅ ✅ setTimeout ✅ ✅ setInterval ✅ ✅ setImmediate ❌ ✅ requestAnimationFrame ✅ ❌ I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。 有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了HTML规范文档以后，发现这很显然是和微任务平行的一个操作步骤 requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行 微任务例子 API 浏览器 Node process.nextTick ❌ ✅ MutationObserver ✅ ❌ Promise.then catch finally ✅ ✅ 浏览器中的情况在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤） I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。 假设有这样的一些DOM结构：123456789101112131415&lt;style&gt; #outer &#123; padding: 20px; background: #616161; &#125; #inner &#123; width: 100px; height: 100px; background: #757575; &#125;&lt;/style&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223const $inner = document.querySelector('#inner')const $outer = document.querySelector('#outer')function handler () &#123; console.log('click') // 直接输出 Promise.resolve().then(_ =&gt; console.log('promise')) // 注册微任务 setTimeout(_ =&gt; console.log('timeout')) // 注册宏任务 requestAnimationFrame(_ =&gt; console.log('animationFrame')) // 注册宏任务 $outer.setAttribute('data-random', Math.random()) // DOM属性修改，触发微任务&#125;new MutationObserver(_ =&gt; &#123; console.log('observer')&#125;).observe($outer, &#123; attributes: true&#125;)$inner.addEventListener('click', handler)$outer.addEventListener('click', handler) 如果点击#inner，其执行顺序一定是：click -&gt; promise -&gt; observer -&gt; click -&gt; promise -&gt; observer -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。 因为一次I/O创建了一个宏任务，也就是说在这次任务中会去触发handler。按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了Promise和MutationObserver两个微任务，遂执行之。因为click事件会冒泡，所以对应的这次I/O会触发两次handler函数(一次在inner、一次在outer)，所以会优先执行冒泡的事件(早于其他的宏任务)，也就是说会重复上述的逻辑。在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。需要注意的一点是，因为我们触发了setAttribute，实际上修改了DOM的属性，这会导致页面的重绘，而这个set的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。 Node Js中的情况Node也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，这里是Node官方文档的地址。 就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。 几个特殊的API SetTimeout和SetInterval 线程池不参与 process.nextTick() 实现类似SetTimeout(function(){},0);每次调用放入队列中，在下一轮循环中取出。 setImmediate();比process.nextTick()优先级低 来看看这段代码 1234567891011121314151617181920setTimeout(() =&gt; &#123; console.log(1)&#125;, 0)setImmediate(() =&gt; &#123; console.log(2)&#125;)process.nextTick(() =&gt; &#123; console.log(3)&#125;)new Promise((resolve, reject) =&gt; &#123; console.log(4) resolve(4)&#125;).then(() =&gt; &#123; console.log(5)&#125;)console.log(6) 这道题目的答案是 463512 这里有几个注意点， 第一就是 nextTick ，它的优先级比 promise.then 要高， 如下图， 它加入队列的方式属于插队行为, 它直接加入到了当前执行栈（同步队列）与 下一次的等待执行栈之间 我们都知道 then 比 setTimeout 优先级高 然后就是 setTimeout 和 setImmediate 的问题了， setImmediate与setTimeout的区别，在官方文档中的定义，setImmediate为一次Event Loop执行完毕后调用。 setTimeout则是通过计算一个延迟时间后进行执行。 但是在实际使用中， 当setTimeout 设置为0时， 他们都是放在队列最后, 所以执行顺序就是谁先写就先执行谁了， 但当setTimeout 设置的时间大于0 时（最低延迟会被忽略）， 情况就不一样了， setTmmediate 会先被执行 参考文献(原文写的不错， 所以我大部分是复制，方便之后自己回顾理解) https://segmentfault.com/a/1190000016022069]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NodeJs】异步IO与EventLoop]]></title>
    <url>%2F2019%2F03%2F26%2F%E3%80%90NodeJs%E3%80%91%E5%BC%82%E6%AD%A5IO%E4%B8%8EEventLoop%2F</url>
    <content type="text"><![CDATA[IO密集型就是需要频繁请求的程序，高访问量， CPU密集型就是需要进行大量计算的 异步IO的好处 前端通过异步IO可以消除UI堵塞。 假设请求资源A的时间为M,请求资源B的时间为N.那么同步的请求耗时为M+N.如果采用异步方式占用时间为Max(M,N)。 随着业务的复杂，会引入分布式系统，时间会线性的增加，M+N+…和Max(M,N…)，这会放大同步和异步之间的差异。 I/O是昂贵的，分布式I/O是更昂贵的。 分布式因为你读取到了这个值， 但并没有在你这台机器上， 远程的机器想要读取到那就必须要走网络， 这个过程就变长了 NodeJS 适用于IO密集型不适用CPU密集型 Node对异步IO的实现 完美的异步IO应该是应该是应用程序发起非阻塞调用，无需通过遍历或者事件幻想等方式轮询。 Node.js 的事件循环和在浏览器中的实现不太一样， 在Node.js 中事件循环交给了Libuv托管， Libuv 和 v8 是分别独立的线程， 辅助Node.js 进行事件轮询 Node.js 依靠v8运行javascript, 并且绑定了底层的操作系统 当V8接收到用户的请求进入， 通过绑定系统接口，将事件交给Libuv处理， Libuv 将事件加入事件队列( event queue)， EventLoop 不行的旋转并执行同步事件，当遇到异步事件时，将其交给 worker Threads 线程， 比如操作文件就是交给工作线程去同步完成， 当文件操作完毕后， 根据文件描述符去获取数据， 然后将结果作为参数返回给事件队列中等候的回调函数 常用的Node控制异步技术手段 Promise 是一个语法， 规范， js只是实现了这个规范， Promise 是一个高级接口， 创建一次，不容易修改， then就是 低级接口， 可以一直then ,处理逻辑 Step、wind（提供等待的异步库）、Bigpipe、Q.js Async、Await Promise/Defferred 是一种先执行异步调用，延迟传递的处理方式。Promise是高级接口，事件是低级接口。低级接口可以构建更多复杂的场景，高级接口一旦定义，不太容易变化，不再有低级接口的灵活性，但对于解决问题非常有效 由于Node基于V8的原因，目前还不支持协程。协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。 底层的知识 CPU时钟周期：1/cpu主频 -&gt; 1s/3.1 GHz 操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理。应用程序如果需要进行IO需要打开文件描述符，在进行文件和数据的读写。异步IO不带数据直接返回，要获取数据还需要通过文件描述符再次读取。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript语法]]></title>
    <url>%2F2019%2F03%2F24%2FTypeScript%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[初始化配置文件 tsc –init修改outDir 定义数组 1 1var arr:number[] = [1,2,3,4] 2 1var arr:Array&lt;number&gt; = [3,4,56,7,8,9] 3 1var arr:any[] = [1,'5515', false] 定义元组 元组表示一个已知元素数量和类型的数组，各元素的类型不必相同。1 1let arr:[number, string] = [123, 'this is ts'] 定义枚举 用于处理非数值的数据 1234enum Flag &#123; success=1, error=2 &#125;;let s:Flag=Flag.successconsole.log(s) // 1 never 类型: never类型表示的是那些永不存在的值的类型, 如null, undefind, error 12var a:undefineda = undefined 定义 symbol类型 symbol类型的值是通过Symbol构造函数创建的。 1let sym1 = Symbol(); 容许多个类型1234var num:number | undefined;num = 123;console.log(num) 有返回值类型 函数声明 123function run():string &#123; return '32132132'&#125; 函数表达式 123var fun2 = function():number &#123; return 132&#125; 无返回值类型123function run():void&#123; console.log('run')&#125; 可选参数、 默认参数 、剩余参数 默认必传, 带‘?’可传可不传， 必须配置到参数的最后面 123function getInfo(name:string, age?:number):string &#123; return `$&#123;name&#125; ---- $&#123;age&#125;`&#125; 默认参数写了默认参数就不再需要 ‘?’ 标记 123function getInfo(name:string, age:number=250):string &#123; return `$&#123;name&#125; ---- $&#123;age&#125;`&#125; 剩余参数12 json 属性约束12345// json属性约束function jsonCon(label) &#123; console.log(label.labelJson);&#125;jsonCon(&#123; labelJson: '你好评' &#125;); 重载 因为需要遵循js ， 所以无法像java一样实现重载， 实现的只能是变体， 自己判断typeof 123456789101112131415function getInfo(name:string):string;function getInfo(name:string, age:number):string;function getInfo(name:string, age?:any):string &#123; // 判断类型用 typeof if(age) &#123; return `姓名:$&#123;name&#125;, 年龄$&#123;age&#125;` &#125;else &#123; return `姓名:$&#123;name&#125;` &#125;&#125;console.log(getInfo('吴大龙')) 创建类123456789101112131415161718class Person&#123; name:string; // 属性 ,前面省略了Public 关键词 constructor(name:string)&#123; // 构造函数 实例化类的时候 触发的方法 this.name = name; &#125; getName():string&#123; return this.name &#125; setName(name:string):void&#123; this.name=name; &#125;&#125; var aa = new Person('栗色')console.log(aa.getName())aa.setName('吴大龙')console.log(aa.getName()) 使用类的 get 和 set 123456789101112131415class Person&#123; private _name:string; constructor(name:string, age:number)&#123; this._name = name; &#125; get name():string&#123; return this._name &#125; set name(name:string)&#123; this._name = name; &#125;&#125;const p = new Person('吴大龙', 112)p.name = '吴强' // 赋值console.log(p.name) // 取值 实现继承 继承自上方类 12345678class Web extends Person &#123; constructor(name:string)&#123; super(name); &#125;&#125;var w=new Web('往');console.log(w.run()) 类修饰符 不加修饰符默认就是 Public , ==外部的意思就是指不被内部函数里被调用, 而是被外部人为调用==public: 共有, 在类的里面, 子类, 类外部都可以访问 protected: 保护类型, 在类里面, 子类里面可以访问, 类外部无法访问 private: 私有, 在类里可以访问, 子类, 类外部都没法访问 静态属性和静态方法 static 静态方法, 在没有 new 出实例前都可以调用==但是没法直接调用类里面的属性== 123456789class Person &#123; public nickname:string= '吴大龙'; static speak():void&#123; console.log(`用户姓名:$&#123;this.nickname&#125;`) &#125;&#125;Person.speak() // 用户姓名:undefined 多态 父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现也是继承的一种表现, 子类实现或重写父类中的已有的方法， 这叫多态 123456789101112131415161718192021222324252627282930313233343536// 多态class Animal &#123; name:string; constructor(name:string)&#123; this.name = name; &#125; eat():void&#123; console.log(`$&#123;this.name&#125;， 在吃屎`) &#125;&#125;class Dog extends Animal &#123; constructor(name:string)&#123; super(name) &#125; // 子类重新定义 eat方法 eat():void &#123; console.log(this.name+'吃肉') &#125;&#125;const wuxiaohong = new Dog('吴晓红')wuxiaohong.eat()// 子类重新定义 eat方法class Cat extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat():void&#123; console.log(this.name+ '吃粮食') &#125;&#125;var cc = new Cat('吴强')cc.eat() 抽象类 用abstract关键字定义抽象类和抽象方法， 是提供其他类继承的基类==抽象方法只能放在抽象类里==从抽象类继承的方法必须被子类重写, 重新实现 1234567891011121314151617181920abstract class Animal&#123; public name:string; constructor(name:string)&#123; this.name=name; &#125; abstract eat():any;&#125;class Dog extends Animal&#123; constructor(name:any)&#123; super(name) &#125; eat()&#123; console.log(this.name + '吃粮食') &#125;&#125;var d = new Dog('小狗')d.eat() 接口 也是一种定义标准. 类似抽象类, 抽象类只能规定方法， 接口可以规定属性， 函数， 索引和类 批量属性接口， 可定义可选参数 123456789// 属性接口interface FullName&#123; firstName: string; //封号结束 secondName: string;&#125;function printName (name: FullName) : void&#123; console.log(name.firstName +'====&gt;' + name.secondName);&#125;printName(&#123;firstName: '吴', secondName: '大龙'&#125;) // 吴====&gt;大龙 数组类型接口123456interface StringArray &#123; [index:number]:string&#125;var myArray:StringArray;myArray = ["iwen", "ime"]alert(myArray[1]) 函数类型接口, 对方法传入的参数， 以及返回值进行约束 123456789// 比如建一个md5加密的接口 的接口interface encrypt&#123; (key:string, value:string):string;&#125;var md5:encrypt = function(key:string, value:string):string &#123; return key + value;&#125;console.log(md5('name', '吴大龙')) 接口扩展， 接口可以继承接口 1234567891011121314151617181920212223interface Animal&#123; eat():void;&#125;// 继承上方接口interface Person extends Animal &#123; work():void;&#125;// 有个类 实现 这个接口class Web implements Person &#123; public name:string; constructor(name:string)&#123; this.name=name &#125; eat()&#123; console.log(this.name + '喜欢吃馒头') &#125; work()&#123; console.log(this.name + '写代码') &#125;&#125;var w = new Web('小林')w.work() // 小林写代码 接口多继承 &amp;&amp; ==创建一个接口对象==123456789101112131415161718// 多继承 并 创建一个接口对象interface Shape &#123; color:string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength:number;&#125;// 创建接口对象不需要 new 而是这样的语法var s = &lt;Square&gt;&#123;&#125;;s.color = "blue"s.penWidth = 10s.sideLength = 10 泛型 用于创建可重用的组件， 让一个组件支持多种数据类型 ==泛型就是解决类 接口 方法的复用性、 以及对不特定数据类型的支持== 基本使用 12345// 泛型 : 可以支持不特定的数据类型 要求： 传入的参数和返回的参数一致function getData&lt;T&gt;(value:T):T&#123; // T表示泛型 return value&#125;console.log(getData&lt;string&gt;('我是泛型')) 多个泛型参数 12345678910class HelloNumber&lt;T, S&gt;&#123; Ten:T; add:(x:T, y:T) =&gt; S;&#125;var myHelloNumber = new HelloNumber&lt;number, string&gt;()myHelloNumber.Ten = 10;myHelloNumber.add = function(x, y) &#123; return x+y+''&#125;console.log(myHelloNumber.add(1, 2)); lamb 表达式 12345678function Hello&lt;T&gt;(arg:T):T&#123; return arg;&#125;// lamb 表达式只是表达具体 参数和返回类型, 需要重新赋值上真函数var myHello:&lt;K&gt;(arg:K)=&gt; K = &lt;K&gt;(arg:K):K =&gt; &#123; return arg&#125;alert(myHello('hello')) 另一种写法， 对象形式 12345function Hello&lt;T&gt;(arg:T)&#123; return arg&#125;var myHello:&#123;&lt;T&gt;(arg:T):T&#125; = Hello;alert(myHello(" Hello")) 泛型接口 12345678// 泛型接口interface ConfigFn&#123; &lt;T&gt;(value:T):T;&#125;var getData:ConfigFn = function&lt;T&gt;(value:T):T&#123; return value&#125;console.log( getData&lt;string&gt;('你好') ) 泛型小实战 ==需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现== 12345678910111213141516171819202122// 泛型类: 比如有个最小堆算法， 需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现class MinClass&lt;T&gt;&#123; list:T[]=[] add(value:T):void&#123; this.list.push(value) &#125; min():T&#123; var minNum = this.list[0] for(var i=0;i&lt;this.list.length;i++)&#123; if(minNum &gt; this.list[i])&#123; minNum=this.list[i] &#125; &#125; return minNum; &#125;&#125;var m1 = new MinClass&lt;string&gt;();m1.add('1')m1.add('you')m1.add('love')console.log(m1.min()) 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在伪元素中使用Iconfont]]></title>
    <url>%2F2019%2F03%2F24%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%AD%E4%BD%BF%E7%94%A8Iconfont%2F</url>
    <content type="text"><![CDATA[把iconfont 中的样式拷到 伪元素上1234567.iconfont&#123; font-family:"iconfont" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; 砍掉unicode 前面的字符如下 即可123456789&amp;::after&#123; content: '\e60e'; font-family:"iconfont" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuecli3脚手架环境变量]]></title>
    <url>%2F2019%2F03%2F24%2Fvuecli3%E8%84%9A%E6%89%8B%E6%9E%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[环境变量 环境变量, 在开发和生产环境中会经常使用到 举一个例子 在开发过程中我们使用一个本地的接口但是在我们打包上线的时候, 我们会使用线上的接口这时候我们就可以通过环境变量来配置 如何创建环境变量 进入脚手架根目录 , 新建一个 .env 文件 , 这就是一个环境变量文件 .env 优先级最低的配置文件, 两种环境都可以用.env.development 开发环境, 时优先使用的环境变量.env.production 生产环节, 打包时使用的环境变量 环境变量语法 VUE_APP_衔接上一个名字=’你的变量’ 如: VUE_APP_URL=’https://baidu.com&#39; 如何在组件中获取环境变量 process.env.VUE_APP_URL然后挂载到当前组件的data 上 ,如下 12345data()&#123; return &#123; url: process.env.VUE_APP_URL &#125;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的add命令与npm的小区别]]></title>
    <url>%2F2019%2F03%2F24%2Fvue%E7%9A%84add%E5%91%BD%E4%BB%A4%E4%B8%8Enpm%E7%9A%84%E5%B0%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[add如果你下载的库, 特别是 Ui 库, 希望对脚手架结构产生影响, 那就选择 vue add xxx npm如果不希望对脚手架结构产生影响, 只是单纯的使用, 比如 axios 这个插件那就选择 npm install xxx 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3脚手架配置px2rem适配方案]]></title>
    <url>%2F2019%2F03%2F24%2Fvue-cli3%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AEpx2rem%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[安装12npm i lib-flexible --savenpm install px2rem-loader 引入 main.js 1import &apos;lib-flexible/flexible&apos; index.html 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 根目录新建 vue.config.js 文件 复制如下代码， 重启， 搞定 123456789101112131415// vue.config.jsmodule.exports = &#123; chainWebpack: config =&gt; &#123; config.module .rule(&apos;css&apos;) .test(/\.css$/) .oneOf(&apos;vue&apos;) .resourceQuery(/\?vue/) .use(&apos;px2rem&apos;) .loader(&apos;px2rem-loader&apos;) .options(&#123; remUnit: 75 &#125;) &#125;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AOP】面向切面编程]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%90AOP%E3%80%91%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Aspect Oriented Programming 面向切面编程（aop）是对面向对象编程（oop）的补充 面向切面编程在软件业， AOP为 Aspect Oriented Programming 的缩写， 意为: 面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续， 是软件开发中的一个热点， 也是Spring 框架中的一个重要内容， 是函数式编程的一种衍生范式。 利用AOP可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低， 提高程序的可重用性， 同时提高了开发效率。 基础概念AOP 完善Spring 的依赖注入(DI) 面向对象编程将程序分解成各个层次的对象， 面向切面编程将程序运行过程分解成各个切面。 FilterFilter(过滤器) 也是一种AOPA， 他利用一种称为“横切”的技术， 刨解开封装的对象内部， 并将那些影响了多个类的公共行为封装到一个可重用的模块， 并将其命名为”Aspect”， 即切面。 所谓“切面”。 优点AOP的好处就是你只需要干你的正事， 其他事情别人帮你干。 在你访问数据库之前， 自动帮你开启事务， 当你访问数据库结束之后， 自动帮你提交/回滚事务！ 就像函数的before和 after 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则之IOC控制反转]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BIOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[IOC （控制反转） Inversion of Control IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚。 什么是控制反转控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注⼊到对象中。 DI是IOC的一种表现形式 两种方式依赖查找容器提供回调接口和上下文条件给组件。 依赖注入组件不做定位查询， 需提供普通的方法让容器去决定依赖关系。 IOC概念图在未使用IOC的时候 各个 Object 之间的耦合度很高， 谁也离不开谁 在使用 IOC 后， 各个 Object 之间通过 IOC容器 整个第三方角色来调度， 变成了可任意组装的模式， 谁需要的时候注入谁， 降低了耦合度 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>IOC</tag>
        <tag>编程原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则之S.O.L.I.D]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BSOLID%2F</url>
    <content type="text"><![CDATA[作为一名优秀的工程师，最重要的不是招式， 而是内功， 像武侠小说里的高手， 一旦有了几十年的内功， 学什么武功都能快人一步 那编程里如何提升内功， 主要就是体现在编程思想上了， 逐层提升你编程思想比如从一开始的最传统的面向对象 到 面向切面 面向对象 -&gt; 工厂模式 -&gt; 面向切面 从 “oop 的静态抽象” 演变为 “aop的动态抽象” SOLID原则的基本概念让我们来看下 SOLID 的概念 程序设计领域， SOLID (单一一功能、开闭原则、⾥里里⽒氏替换、接⼝口隔离以及依赖反转)是由罗伯特·C·⻢马丁在21世纪早期 引⼊入的记忆术⾸首字⺟母缩略略字，指代了了⾯面向对象编程和⾯面向对象设计的五个基本原则。当这些原则被一一起应⽤用时，它们使得一一个程序员开发一一个容易易进⾏行行软件维护和扩展的系统变得更更加可能SOLID被典型的应⽤用在测试驱动开发上，并且是敏敏捷开发以及⾃自适应软件开发的基本原则的重要组成部分。 SOLID这几个字母代表什么意义？S (单一一功能原则) Single Responsibility Principle 单一一功能原则 ：单一一功能原则 认为对象应该仅具有一一种单一一功能的概念。换句句话说就是让一一个类只做一一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。在所有的SOLID原则中，这是⼤大多数开发⼈人员感到最能完全理理解的一一条。严格来说，这也可能是违反最频繁的一一条原则了了。单一一责任原则可以看作是低耦合、⾼内聚在面向对象原则上的引申，将责任定义为引起变化的原因，以提高内聚性来减少引起变化的原因。责任过多，可能引起它变化的原因就越多，这将导致责任依赖，相互之间就产⽣生影响，从⽽而极⼤大的损伤其内聚性和耦合度。单一一责任，通常意味着单一一的功能，因此不不要为一一个模块实 现过多的功能点，以保证实体只有一一个引起它变化的原因。 缩减一下就是: 让每个函数和每个类都只做一件小事，职责单一，解耦和 O (开闭原则) Open Close Principle 开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。软件实体应该是可扩展，而不不可修改的。也就是说，对扩展是开放的，而对修改是封闭的（“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不不应该被修改。也就是说你可以新增功能但不能去修改源码。）。这个原则是诸多面向对象编程原则中最抽象、最难理理解的一个。 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独⽴立完成其⼯工作，⽽而不要对类进⾏行行任何修改。可以使用变化和不变来说明：封装不变部分，开放变化部分，一般使用接口继承实现⽅方式来实现“开放”应对变化。 说大白话就是：你不不是要变化吗？，那么我就让你继承实现一个对象，用一个接口来抽象你的职责，你变化越多，继承实现的子类就越多。 让我们来看下一个简单的 Ts demo 糟糕的实现1234567891011121314class Animal &#123; constructor(name: any) &#123; super(name) this.name = name &#125; eat() &#123; if(this.name == '小猫') &#123; console.log(this.name + '吃猫粮') &#125; else if( this.name == "小狗") &#123; console.log(this.name + '吃狗粮') &#125; &#125;&#125; 这种糟糕的实现不但使程序的可扩展性降低， 而且每次新增一种动物都需要修改之前的代码， 容易造成隐患， 这和编程思想极大的违背 利用 OCP 思想1234567891011121314151617181920// Animal 抽象类abstract class Animal &#123; public name: string; constructor(name: string) &#123; this.name = name; &#125; abstract eat(): any;&#125;// 实现Animal抽象类class Dog extends Animal &#123; constructor(name: any) &#123; super(name) &#125; eat() &#123; console.log(this.name + '吃狗粮') &#125;&#125;var d = new Dog('小狗')d.eat() 上面的代码中， 首先使用abstract 定义抽象类和抽象方法，提供其他类继承的基类我们定义只要是Animal就必须要有eat方法 于是， 我们创建了一个Dog 继承Animal ,这个Dog就不一般了， 它规定了必须重新实现 eat 方法， 并且可以扩展自己的方法 当我们将来如果需要一只 Cat我们一样只需要让他继承Animal抽象类， 然后实现一个自己的eat方法 L (里⽒氏替换原则) Liskov Substitution Principle 里氏替换原则: 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下提前被它的子类所替换的”的概念。 子类必须能够替换他们的基类。即： 子类应该可以替换任何基类能够出现的地方， 并且经过替换以后， 代码还能正常工作。 另外， 不应该在代码中出现if/else之类对子类类型进行判断的条件。 里氏替换原则LSP使使代码符合开闭原则的一个重要保证。 正是由于子类的替换性才使得父类型的模块在无需修改的情况下就可以扩展。在很多情况下， 在设计初期我们类之间的关系不是很明确， LSP则给了我们一个判断和设计类之间关系的基准: 需不需要继承， 以及怎样设计继承关系。 当一个子类的实例应该能够替换任何其超类的实例时， 它们之间才具有is-A关系。 继承对于OCP， 就相当于多态性对于里氏替换原则。子类可以代替基类， 客户使用基类， 他们不需要知道派生类所做的事情。这是一个针对行为职责可替代的原则， 如果S是T的子类型， 那么S对象就应该在不改变任何抽象属性情况下替换所有T对象。 缩减一下就是: 老爸能干的事， 儿子必须都能干， 并且还要干的能多， 只要有儿子在， 老爸不在现场都没关系 I (接⼝隔离原则) Interface Segregation Principle 接口隔离原则: 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。 不能强迫用户去依赖那些他们不能使用的接口。 换句话说， 使用多个专门的接口比使用单一的总接口总要好(JavaScript几乎没有接口的概念， 所以使用ts)。 注意： 在代码中应用 ISP 并不一定意味着服务就是绝对安全的。 仍然需要采用良好的编码实践， 以确保正确的验证与授权。 这个原则起源于施乐公司， 他们需要建立了一个新的打印机系统， 可以执行诸如装订的印刷品一套，传真多种任务。此系统软件创建从底层开始编制， 并实现了这些任务功能， 但是不断增长的软件功能却使软件本身越来越难适应变化和维护。 每一次改变，即使是最小的变化， 有人可能需要近一个小时的重新编译和重新部署。这几乎不可能再继续发展， 所以他们聘请罗伯特(Robert)帮助他们。他们首先设计了一个主要类Job,几乎能够用于实现所有任务功能。 只要调用Job类的一个方法就可以实现一个功能， Job类就变动非常大， 是一个胖模型啊， 对于客户端如果只需要一个打印功能， 但是其他无关打印的方法功能也和其耦合， ISP原则建议在客户端和Job类之间增加一个接口层， 对于不同功能有不同的接口， 比如打印功能就是Print接口， 然后将大的Job类切分为继承不同接口的子类， 这样有一个Print Job类 等等。 缩减一下就是: 每一个业务都要准备一个接口， 每个不同功能的接口再继承自公共的基础接口 D (依赖反转原则) Dependency Inversion Principle 依赖倒置原则（Dependency Inversion Principle， DIP）规定： 代码应当取决于抽象概念， 而不是具体实现。 高层模块不应该依赖于底层模块， 二者都应该依赖于抽象抽象不应该依赖于细节， 细节应该依赖于抽象(总结解耦) 类可能依赖于其他类来执行其工作， 但是， 他们不应当依赖于该类的特定具体实现， 而应当是它的抽象。 这个原则实在是太重要了， 社会的分工化， 标准化都是这个设计原则的体现。显然， 这一概念会大大提高系统的灵活性。 如果类只是关心他们支持特定锲约而不是特定类型的组件， 就可以快速而轻松地修改这些低级服务的功能， 同时最大限度地降低对系统其余部分地影响。 举个例子: 你家里需要洗衣机， 不可能把整个洗衣机的生产流程都给实现了， 搬到自己家里， 当然时去超市商场购买一台洗衣机。 你需要电饭煲，也不可能把电饭煲地生产工艺实现了， 也是去商场买现成地。 此时商场就是一个容器， 商场帮我们去各个工厂采购这些商品， 当我们需要某件物品时就可以去商场购买现成地商品 依赖反转原则依赖注入 当某个⻆角⾊色要另一个角色协助时，通常由调用者来创建被调用者的实例。现在创建实例由容器来完成然后注⼊调用者。 注⼊入过程 如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注⼊ 依赖反转有两种方式 设值注入（在类上方设置字段） 构造注入 （在constructor中接收需要地参数） DI（依赖注⼊入） 依赖注⼊入（Dependency Injection） 为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注⼊是该原则的一种实现⽅方式。 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>编程原则</tag>
        <tag>SOLID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript手册]]></title>
    <url>%2F2019%2F03%2F18%2FTypeScript%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[TypeScript是JavaScript的超集 开发环境搭建 我的环境: window10 + vscode 全局安装Ts npm i -g typescript 生成并配置tsconfig.json tsc –init 配置文件， 下面的配置中ts应存放在src 目录下， 并且会自动编译到dist文件夹下1234567891011121314151617181920212223242526272829303132333435&#123; "compilerOptions": &#123; "target": "es2017", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' "module": "commonjs", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' "moduleResolution": "node", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) "emitDecoratorMetadata": true, // 为装饰器提供元数据的支持 "experimentalDecorators": true, // 启用装饰器 "allowSyntheticDefaultImports": true, // 允许从没有设置默认导出的模块中默认导入。 "strict": true, // 启用所有严格类型检查选项 "noImplicitAny": true, // 在表达式和声明上有隐含的 any类型时报错 "alwaysStrict": true, // 以严格模式检查没个模块，并在没个文件里加入 'use strict' "sourceMap": true, "noEmit": false, // 不生成输出文件 "removeComments": true, // 删除编译后的所有的注释 "importHelpers": true, // 从 tslib 导入辅助工具函数 "strictNullChecks": true, // 启用严格的 null 检查 "lib": ["es2017"], // 指定要包含在编译中的库文件 "typeRoots": ["node_modules/@types"], "types": [ "node", ], "outDir": "./dist", // 编译后文件产出目录 "rootDir": "./src" // 你的ts文件目录 &#125;, "include": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 "./src/*.ts", "./src/**/*.ts" ], "exclude": [ "node_modules", "dist", "**/*.test.ts", "public" ]&#125; 快速生成package.json npm init -y 运行命令， 开始监听 tsc -w 是否有效呢？ 让我们来试一下 进入src目录新建一个 hello.ts，记得是.ts， 不要写习惯了打成.js😅 随便写点东西， 比如定义一个字符串类型:1var a:string = "hello world" 如果你配置没有问题的话， 我们就会看到他监听文件修改并编译 这是ts文件与 编译后的js文件 并且在他运行过程中， 我们可以按F5进行调试 基本数据类型 Boolean Number String Array Enum Any Void 简单的几种数据的定义123456// 定义一个Booleanvar a:boolean = true// 定义一个Numbervar a:number = 13// 定义一个 String var a:string = "13" 基本的数据结构定义1var list:number[] = [1,2,3] 接口 interfaces 基础接口没有接口时我们如何规范参数类型12345function fn(dog:&#123;name:string&#125;) &#123; console.log(dog.name)&#125;var myObj = &#123; name: "Hello" &#125;fn(myObj) 有了接口， 我们就可以把参数规定与函数分离 如何创建接口 通过 interface 关键字来声明 1234567891011interface dogValue &#123; name:string;&#125;// 指定参数`dog`是接口类型function fn(dog: dogValue) &#123; console.log(dog.name)&#125;var myObj = &#123; name: "Hello" &#125;fn(myObj) // 编译通过 接口的可选属性接口定义的参数不一定每一个都会被用到 泛型什么是泛型? 泛型: 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 一句话理解就是： 参数化类型（把类型当作是参数一样传递） 使用泛型的好处: 代码更加简洁【不用强制转换】 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】 可读性和稳定性【在编写集合的时候，就限定了类型】 指定一个最简单的泛型123function Hello&lt;T&gt;(arg:T):T &#123; return arg;&#125; Module 模块Module 模式是常见的JavaScript模式之一， 在ES6的模块话实现之前， 人们通常通过 IFEE 来实现Module Module 的好处 模块化 可重用 封装变量和函数 来看看在ES6之前是如何书写的123(function() &#123; // do somtiong&#125;()); 让我们来看一个例子， 使用 TS 的 Module 来防止调用多种 interface 时的麻烦 使用Module之前1234567891011121314151617interface StringValidator &#123; // 接口定义的方法 isAcceptable(s:string):boolean;&#125;var lettersRegexp = /^[A-Za-z]+$]/;var numberRegexp = /^[0-9]+$/;// 实现接口的方法class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return lettersRegexp.test(s) &#125;&#125; class ZipCodeValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s) &#125;&#125; 使用了Module 的书写方式后 1234567891011121314151617181920module Validation &#123; // 需要使用 export 来表示对外暴露 export interface StringValidator &#123; isAcceptable(s:string): boolean; &#125; var lettersRegexp = /^[A-Za-z]+$]/; var numberRegexp = /^[0-9]+$/; export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s:string) &#123; return lettersRegexp.test(s) &#125; &#125; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s) &#125; &#125;&#125; Module 与 类相结合使用12345678910111213141516171819module Person &#123; export class Student &#123; name: string; constructor(name:string) &#123; this.name = name; &#125; study() &#123; console.log(this.name + '在学习') &#125; speak() &#123; console.log(this.name + '在说话') &#125; &#125;&#125;// ----------- 使用时 -------------const xiaoming = new Person.Student('小明')xiaoming.study() NamespacesNamespaces 的和Module 的用法相同， 在Ts 的1.5 版本后， 用 Namespaces 取代了 Module 查看一下官方的示例 123456789namespace Shapes &#123; export namespace Polygons &#123; export class Triangle &#123; &#125; export class Square &#123; &#125; &#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()' 装饰器 &lt; Decorators &gt;如何定义一个装饰器 其实装饰器就是一个普通的函数， 他接收一个参数target ，这个参数就是被装饰对象， 看下面的例子， sealed 装饰了Dog类， 并且在sealed 中打印了 target ， 让我们看看 target到底是什么？123456789101112function sealed(target:any) &#123; // do something with 'target' ... console.log(target) return target&#125;// 被装饰的对象 foo@sealedclass Dog &#123;&#125; 打印结果 我们可以看到， 得到的正是 Dog这个类 装饰器工厂&lt; Decorator Factories &gt; 如果希望自定义如何将装饰器应用于声明，可以编写装饰器工厂。装饰器工厂只是一个函数，它返回将在运行时由装饰器调用的表达式。 装饰器工厂和普通装饰器相比的好处就是更加的自定义了， 可以根据不同情况自定义效果 如何定义一个装饰器工厂 123456789101112function dec(value:string) &#123; return function (target:any) &#123; console.log(value) console.log(target) &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; &#125; 让我们来看看运行的结果 可以看到，我们传入的test字符串和 Cat类都被打印出来了， 多装饰器的执行顺序使用多个装饰器时如何书写呢? 当我们使用多个装饰器时有两种写法 写成一行 1@f @g x 垂直书写 123@f@gx 多个装饰器的执行顺序是如何的呢？ 套用官网的说明 对每个装饰器的表达式进行自上而下的计算。 然后将结果作为自下而上的函数调用。 其实真实的运行原理是1f(g(x)) 访问器修饰器访问器修饰器的接收的参数和方法修饰器接收的参数一样 123456789101112131415161718192021function dec(value:string) &#123; return function (target:any, propertyKey: string, descriptor: PropertyDescriptor) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; this._x = x this._y = y &#125; // 访问器修饰器 @dec(true) get x() &#123; return this._x &#125; @dec(false) get y() &#123; return this._y &#125;&#125; 属性修饰器属性修饰器只有前两个参数123456789101112131415161718function dec(value:string) &#123; return function (target:any, propertyKey: string) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; // 属性修饰器 @dec(false) this._x = x this._y = y &#125;&#125; 参数修饰器参数修饰器也是三个参数， 但不同的是第三个参数接收 参数装饰器只能确认一个方法的参数是否被传入 前两个和其他的修饰器都相同， target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象 propertyKey 成员的名称 参数在所处函数的参数列表中的索引， 说人话就是告诉你他是第几个参数 1234567891011function require(value:boolean) &#123; return function (target:any, propertyKey: string, index: number) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; run(@require(true) name:string) &#123; &#125;&#125; 装饰器参数 类装饰器 类装饰器的参数只接收一个， 那就是target 也就是这个类本身 就和上面演示的那些例子一样 方法装饰器 一般会传入三个参数 target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象 propertyKey 成员的名称 descriptor 成员属性的描述符 我们来验证下方法装饰器的参数 让我们看看这段例子会输出什么123456789101112function f(value:string) &#123; return function (target:any, propertyKey: string, descriptor: PropertyDescriptor) &#123; console.log(arguments) console.log(target) &#125;&#125;class Tiger &#123; @f('tiger run') run() &#123; &#125;&#125; 输入结果: 在控制台输出， 我们看到了，第一个参数是 tiger 的实例对象（因为run是实例成员） 第二个参数是成员名称， 也就是被装饰的run 第三个参数是 run 的属性描述符 Mixins 混入除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。 Mixins 其实可以拆分为两个单词 Mix : 混合 ins : 是进入 所以合在一起就是叫 混入 的意思的单词 它想要表达的是一个对象中混入另一个对象的方法 让我们来实现一下Mixins 代码里首先定义两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。 12345678910111213141516171819// Disposable Mixinclass Disposable &#123; isDisposed: boolean; dispose() &#123; this.isDisposed = true; &#125;&#125;// Activatable Mixinclass Activatable &#123; isActive: boolean; activate() &#123; this.isActive = true; &#125; deactivate() &#123; this.isActive = false; &#125;&#125; 创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：12class SmartObject implements Disposable, Activatable &#123; &#125; 这里我们没有使用extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的。 我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。 也就是这样 1234567891011121314151617class SmartObject implements Disposable, Activatable &#123; constructor() &#123; setInterval(() =&gt; console.log(this.isActive + " : " + this.isDisposed), 500); &#125; interact() &#123; this.activate(); &#125; // Disposable isDisposed: boolean = false; dispose: () =&gt; void; // Activatable isActive: boolean = false; activate: () =&gt; void; deactivate: () =&gt; void;&#125; 最后，把mixins混入定义的类，完成全部实现部分。1applyMixins(SmartObject, [Disposable, Activatable]); 我们同时也需要创建这个帮助函数， 帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。1234567function applyMixins(derivedCtor: any, baseCtors: any[]) &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;) &#125;);&#125; 参考文献 https://segmentfault.com/a/1190000016305647 ————————-待完善—————————-]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Css矩阵]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90CSS%E7%9F%A9%E9%98%B5%E3%80%91%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Css%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[矩阵 matrix(a,b,c,d,e,f); a c e 分别和 X, Y, 1 相乘得出线性方程 b d f 分别和 X, Y, 1 相乘得出线性方程 这是很清楚的计算公式 rotateZ矩阵推理推理过程 参考同学的笔记同学写的很不错👍]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS全景】淘宝造物节H5原理]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90CSS%E5%85%A8%E6%99%AF%E3%80%91%E6%B7%98%E5%AE%9D%E9%80%A0%E7%89%A9%E8%8A%82H5%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[2016年的淘宝造物节邀请函， 太牛了， 不过，我们这回先不研究他的入场特效，先研究下它的全景是如何实现的 一、 载入图片, 定位至统一位置 因为20张图片被定位到统一地方, 所以所有图片都叠在一起了 此时效果 二、依照Y轴旋转图片 先说下为什么要依照y轴: 我们需要把图片围绕成一个环形, 类似于 木桶的每一块木板, 图片就是木板, 按图片的顺序旋转自各自的角度, 目前也是原地旋转, 所以图片依旧叠加在一起 素材有20张图片, 那每张的旋转角度就是 360 / 20 = 18度, 每张旋转的度数在前一张的基础上累加 18 度, 这里注意注意注意: 因为是按图片中心的Y轴旋转, 所以同一个度数会有两张图片, 比如: 0度的图片, 头在0度, 尾在90度, 然后当轮到头在90度的图片时, 他的尾在 0 度, 所以会有同一个度数两张图片的现象 此时效果 为了方便理解, 切换成上帝视角, , 所有图片围绕中心点旋转 三、将图片沿着各自Z轴向外推 现在木板(也就是每一张图片)是穿插在一起的, 我们需要让他们远离中心点, 拉开距离, 让他,们边缘连接而不是这样交叉在一起, 才能形成一个圆 先了解每一块木板怎么推 简单的画了个前后的效果图, 用的是上帝视角, 也就是你低头看一个木桶的视角 如何计算该推多少距离 做一道三角函数数学题 画的角度不太对别介意 设一共12条线, 每条长200px(此时的长就对应图片的宽) , 求将橙线移动到图中最终位置的距离 “黑线”,12345678910// 先求旋转度数// 然后取度数的一半360 / 12 / 2 = 15 度// 得知直角底边长度200 / 2 = 100px// 根据度数得知 tan, 顺便说下, tan是对边比邻边tan15°= 0.26794// 求出黑线100PX / 黑线 = 0.26794黑线约等于 373.2px js计算时注意 Math.tan 接收的是弧度单位 Math.PI 表示的是一个 Π 360度 = 2Π 计算出每张图片之间的形成的弧度 12345678 // 假设图片数量是 8 张// 因为 360 = 2Π// 1度 = Π / 180// 每份的角度是const deg = 360 / 8 // 此时为 45// 一份的弧度就是 每份弧度 * 旋转角度的一半// 最后结果就等于 Π / 图片数量( Math.PI / 180 ) * ( 45 / 2 ) ==&gt; Math.PI / 8 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vue】源码解析]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90Vue%E3%80%91%2F</url>
    <content type="text"><![CDATA[现在三大框架风起云涌， JQuery老大哥的光辉不再， 使前端成为了各路诸侯的兵家必争之地， 当然作为一名优质的前端，光跟风学框架是肯定不行的， 要知其然而知其所以然 要了解MVVM的本质原理， virtual Dom和 Diff算法带来的好处以及坏处 拒绝盲目跟风 🍎diffDom优劣现在很多人都说 Vue, React 多牛， Diff算法快，不用操作Dom。 只能无语。 Diff算法不是不需要操作Dom, 而是不需要开发者去操作Dom了， Diff算法其实不快， 就算使用了virtual Dom, 还得花实现把真实Dom 转换为 virtual Dom 再去比对， 这远远没有js直接 getElementById直达目标来的快 那Diff算法不快为什么还要用呢? Diff算法其实是给那些比较随意的新手开发者准备的 看这个例子 123456&lt;!-- 原本的dom --&gt;&lt;ul id="ul"&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt; 12345678// 拿到结果不管三七二十一把旧dom全替换了$.get('/api', (res) =&gt; &#123; var _HTML = "" for(var i=0; i&lt; res.length; i++)&#123; _HTML = "&lt;li&gt;" + res[i] +"&lt;/li&gt;" &#125; $("#ul").html(_HTML)&#125;) 如果是原始的Dom操作， 有很多小白会像这个例子一样， 不管Dom需不需要更新， 他都把ajax返回的请求全部跑一边，生成HTML模板， 然后把原本的所有li都删了， 再把新的模板放进去， Dom少还看不出来， 如果Dom多了呢， 上千的Dom， 这顿操作一下就玩炸了。 况且网站优化原则就是尽量减小Dom操作， 如果是有经验的开发者， 会选择找到有变化的位置，使用append插入 📄Vue架构目录去Vue官网下载Vue源码看看， 打开里面会有一个 src目录， 里面就是整个的Vue源码 目前有6个目录， 作用分别如下 Vue.js 的组成是由 core + 对应的 ‘平台’ 补充代码构成（独立构建和运行时构建只是 platforms 下 web 平台的两种选择） vue的核心原理就在core文件夹中， 让我们进入 core 文件夹看看 了解了目录，接下来我们就来研究Vue的双向绑定 🔗双向绑定（响应式原理） 所涉及到的技术 ✅ Obejct.defineProperty 【提供getter 和 setter】 ✅ Observer 【提供getter 和 setter】 ✅ watcher 【提供getter 和 setter】 ✅ Dep 【负责收集watcher】 ✅ Directive 【处理Vue模板指令】 Obejct.definePropertyObejct.defineProperty 是整个Vue的灵魂， 来看一下Obejct.defineProperty 如何使用1234567891011121314151617var obj = &#123;&#125;var c;Object.defineProperty(obj, 'a', &#123; get() &#123; console.log('getter') return a &#125;, set(newVal) &#123; console.log('setter') c = newVal this.a = newVal &#125;&#125;)obj.a = '234'console.log(c) // 234console.log(obj.a) // 234 它帮助Vue实现了双向绑定, 但也因为这个， Vue也只能舍弃了对低版本浏览器的支持。 它只能兼容到IE9 ， 并且市面上的polyfill实现的也并不是很好 那低版本如何代替Obejct.defineProperty ？， 难道真没了它就不行吗？ 当然有： 👆 &gt; IE 7 实际上在IE7的时候就已经有暴露了 __defineGetter__ 方法， 具体用法如下1234567var random = &#123;&#125;;random.__defineGetter__('ten', function() &#123; return Math.floor(Math.random()*10); &#125;);random.__defineGetter__('hundred', function() &#123; return Math.floor(Math.random()*100); &#125;);random.ten // 4 👇 &lt; IE 7 早年间的IE 是支持VBScript, VBScript 就可以直接写类， 并且也支持get，set方法 12345678class Test &#123; get name () &#123; &#125; set name() &#123; &#125;&#125; 🐶霸道的IE说了这么多IE的坏， 这里也带一嘴IE的好， IE能够调用EXE程序, 比如JS无法设置打印机的宽高，就可以利用ActiveObjectX来做到, 甚至可以修改word格式等等 , 所以办公类的项目离不开IE 😕MVVM 双向数据绑定流程MVVM: Model–view–viewmodel 那怎么区分这些层呢 🚀Model: Observer ✈️view : directive 🚚viewmodel: Watcher &amp;&amp; Dep 【用于连接 Model 和 view】 先看Directive, 这就是我们平时写的vue指令， 如上面举例得的v-text=&quot;times&quot;, 这就是一个指令， 一个Directive会分配一个Watcher Observer观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。订阅者模式涉及三个对象：发布者、主题对象、订阅者，三个对象间的是一对多的关系，每当主题对象状态发生改变时，其相关依赖对象都会得到通知，并被自动更新。 简单的描述就是: 你想买漫画， 但是问了报刊亭的大爷， 大爷说现在没有， 还没到货， 然后你回去了， 第二天你又去问， 大爷还是说没有， 如果你每天这样问， 大爷估计会嫌你烦。 如果这时候你把你的电话给大爷， 大爷记录到他的本子上, 当大爷的漫画到货的时候电话通知你。 这时你就是订阅者, 大爷就是发布者, 你们就存在一个发布订阅者的关系 优质文献: 汤姆大叔的观察者模式]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具目录]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%B7%A5%E5%85%B7%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这里存放各种可能用到的用不到的东西， 真用到时方便查找😄 当然平日里经常用到的， 耳熟能详的， 我就不放进来了， 主要是起个备忘录的作用 CSS兼容查询 https://caniuse.com/ https://cssdb.org/ 动画 贝塞尔: http://cubic-bezier.com/#.17,.67,.83,.67 可生成matrix的网站 名称 网址 matrix3d http://ds-overdesign.com/transform/matrix3d.html CSS-Matrix3d https://github.com/Zhangdroid/CSS-Matrix3d matrix http://meyerweb.com/eric/tools/matrix/ tools http://www.f2e.name/case/css3/tools.html 高逼格 web component CSS: https://css-doodle.com/ PostCss 值得收藏的插件 功能 插件名 运行时变量 POSTCSS-CUSTOM-PROPERTIES 与SCSS一致的变量实现 POSTCSS-SIMPLE-VARS 实现类似SASS的@MIXIN的功能 POSTCSS-MIXINS 实现类似SASS的继承功能 POSTCSS-EXTEND 实现类似SASS的IMPORT POSTCSS-IMPORT 面向未来 CSSNext 修复过去（兼容IE，zomm、一像素留白等） CSS Grace Node框架 功能 插件名 周边生态 帮助实现DI的库 Awilix awilix-koa 实现控制反转&amp;构造注入的框架 InversifyJS inversify-koa-utils webpack4功能性能类 功能 插件名 自动插入html及静态文件 HtmlWebpackPlugin【配置自动注入loading（监测资源）】 抽离css文件 MiniCssExtractPlugin 清空指定目录 CleanWebpackPlugin js 深度 tree sharking 基于ES6模块 webpack-deep-scope-plugin css tree sharking PurifyCSSPlugin 多核打包件 [需要babel] uglifyjs-webpack-plugin[官方], happypack 前端缓存负载【自动生成缓存文件】 Webpack Manifest Plugin js 压缩 以及 es压缩 多核压缩 webpack-parallel-uglify-plugin, happypack hint css 多核压缩css css-nano, optimize-css-assets-webpack-plugin js 转 ast静态语法分析树 acorn , acorn-walk 能对html进行hint 以及 fix 的插件 html-minifier, html-minifier-lint 搬运静态文件 copy-webpack-plugin 优化体验类 功能 插件名 监测 webpack 打包速度 speed-measure-webpack-plugin 打包成功通知 webpack-build-notifier 显示打包进度 progress-bar-webpack-plugin 信息面板优化 webpack-dashboard[需要配置Pagejson]， webpack-jarvis[网页中浏览] 修改cmd 标题 node-bash-title[ github ][cmder 无效] loader 功能 插件名 缓存Loader结果 cache-loader TypeScript运行工具 功能 插件名 周边生态 在node中不用编译就运行 ts-node ts-node-dev 热重启 Linuxvim 快速学习vim的网站: https://vim-adventures.com/ 算法学习帮助 算法过程可视化: https://algorithm-visualizer.org/branch-and-bound/binary-search]]></content>
      <categories>
        <category>目录</category>
      </categories>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css分层&命名规范]]></title>
    <url>%2F2019%2F03%2F16%2Fcss%E5%88%86%E5%B1%82-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[为什么要分层? CSS有语义化的命名约定和CSS层的分离， 将有助于它的可扩展性， 性能的提高和代码的组织管理。 避免大量的样式、 覆盖、 权重和很多！important, 分好层可以让团队命名统一规范， 方便维护。 有责任感地去命名你的选择器 有哪些分层理论? SMACSS BEM SUIT ACSS ITCSS BEMBEM和SMACCS非常类似， 主要用来如何给项目命名。一个简单命名更容易让别人一起工作。 比如选项卡导航是一个块(Block)， 这个块里的元素是其中标签之一（Element）, 而当前选项卡是一个修饰状态( Modifier ) block - 代表了更高级别的抽象或组件 block__element - 代表.block的后代， 用于形成一个完整的.block的整体。 block–modifier - 代表.block 的不同状态或不同版本。 修饰符使用的是_, 子模块使用的是__符号。 ( 不同一个-的原因是因为CSS单词连接 ) 12345678&lt;!-- container 是大容器 --&gt;&lt;div class="container"&gt; &lt;div class="menu"&gt; &lt;div class="menu--item menu--item__active"&gt;首页&lt;/div&gt; &lt;div class="menu--item"&gt;新闻&lt;/div&gt; &lt;div class="menu--item"&gt;消息&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【css-doodle】 css web-component入门]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90css-doodle%E3%80%91css-web-component%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[首先祭出 css-doodle的官网， 真的老厉害了， 使用它能够轻松的实现各种炫酷特效 https://css-doodle.com/ &lt;css-doodle /&gt;基于 Shadow DOM v1和 Custom Elements v1。您可以立即在最新的Chrome，Safari和Firefox上使用它，而无需使用polyfill。该组件将根据其中的规则（纯CSS）生成div网格。您可以使用CSS轻松操作这些单元格，以获得图形模式或动画图形。限制是CSS本身的限制。 既然它这么牛逼， 那怎么用呢？ 我们一起来搭几个demo css-doodle入门 此处用到的语法或api有不了解的 请看页面下方的“释义” 区域 动手过程中需要注意， 不要在css-doodle内部写注释， 会导致样式无效 首先搭建好运行css-doodle的环境12345678&lt;!-- 引入CDN --&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.5.1/css-doodle.min.js"&gt;&lt;/script&gt;&lt;!-- 页面上加入 css-doodle --&gt;&lt;css-doodle&gt;&lt;!-- 我们将在这里写代码 --&gt;&lt;/css-doodle&gt; 此时如果我们打开页面， 你会发现是空空如也的， 因为这个元素既没有宽高也没有背景颜色， 我们当然看不到。 现在我们给他加点料。 12345&lt;css-doodle&gt; width: 100px; height: 100px; background: red;&lt;/css-doodle&gt; 此时我们再看看页面， 就出现了一个100 x 100的红色小方块， 好，这个相当于hello world 级别的练习就完成了， 我们再来点难的： 我想要一个10 x 10 个的小方块组成的大正方形! 正好我们可以借此尝试使用一下它提供的API 123456&lt;css-doodle&gt; :doodle &#123; @grid: 10x10 / 500px; &#125; background: #60569e;&lt;/css-doodle&gt; 出现了！ 我们要的 10 x 10 个小方块组成的大正方， 并且还把颜色换成了骚骚的紫色 好既然实现了， 那现在需求升级了 那我要10个长方形怎么办， 并且我还要长短不一的！ 我去，还要长短不一， 咋整呢 别慌 机制的你一定可以在官网找到有一个获取当前小方块顺序的的参数@index 严格的来说他会返回当前单元格的索引值 既然有方法了那我们也有思路了， 二话不说开始动手。 12345678910&lt;!-- 首先把 10 x 10 小方块变为10个长方形 --&gt;&lt;!-- 然后根据 @index 获取当前单元格的索引 --&gt;&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; background: #60569e; @size: calc(@index() * 1vmin);&lt;/css-doodle&gt;&lt;!-- 根据 index 这个索引值乘以高度 --&gt; duang! 这就是我们想要的结果了， 虽然还有点不完美， 其实每个紫色都是一个正方形， 但所在的单元格是长方形没跑了 我们再给他加上border-radius: 50%; 它就变成10个球了 此时需求又来了 甲方：可不可以弄10个光环？还是渐变的那种? 行吧， 试试喽谁怕谁 我们可以举一反三， 利用@index这个好东西来修改hsla产生不同的颜色， 当然修改rgba 也是可以的 123456789101112&lt;!-- 根据index 每个的单元格递增20的色调， 再调整出不同的透明度 --&gt;&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; border-color: hsla( calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8) ); @size: calc(@index() * 10%); border-style: dashed; border-radius: 50%;&lt;/css-doodle&gt; 好， 甲方爸爸， 你的需求我做到了 甲方: 还不够，我要的是同心圆 我。。。。。 得嘞，您说是啥就是啥 同心圆， 你第一反应想到的是不是使用position: absolute; ?不 ，那太low 了我们只需要 @place-cell: center; 这个参数就搞定了， 它会将每个单元格都摆放至中间 12345678&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; @place-cell: center; &lt;!-- ...省略之前的代码 --&gt;&lt;/css-doodle&gt; 然后去看一下效果， 卧槽 进阶基础学的差不多了， 其他的一些api有了上面的参照都应该思路了吧 既然是进阶篇， 我们就做点难的， 我们看看能不能利用这些特性和 CSS动画结合一下 我们先让光环变粗一点， 让他呈现扇叶的形状 1border-width: calc(@index() * 10px); 然后让我们用上 keyframes ， 为他添加动画 为每个单元格注册几个css变量（css的新特性）， 变量--speed控制动画的持续时间，也就是速度。 --start 控制当前光环的起始角度 --direction: 控制方向， 因为turn表示一圈， 所以 1turn 就是正的转一圈,-1turn 就是反着转一圈， 利用@pick方法来随机取一个值 1234567891011121314151617181920212223&lt;css-doodle&gt; &lt;!-- ...省略之前的代码 --&gt; &lt;!-- 动画执行时间在20秒 - 40秒之间取值--&gt; --speed: @rand(20s, 40s); &lt;!-- 360度里取随机数 --&gt; --start: @rand(360deg); &lt;!-- 顺时针 或 逆时针 --&gt; --direction: calc(var(--start) + @pick(1turn, -1turn)); animation: demo var(--speed) linear infinite; @keyframes demo &#123; form &#123; &lt;!-- 填入起始角度 --&gt; transform: rotate(var(--start)); &#125; to &#123; &lt;!-- 随机顺时针和逆时针旋转 --&gt; transform: rotate(var(--direction)); &#125; &#125;&lt;/css-doodle&gt; 看看效果 炫酷不？ 能不能再酷一点？ 可以， 我们再给他添一笔， 给他加上一个自定义的贝塞尔 贝塞尔可以去这个网站，根据需要生成 http://cubic-bezier.com/#1,.25,.83,.67 然后我们你所需要的贝塞尔去更改animation 的参数1animation: demo var(--speed) cubic-bezier(0,.88,.42,.99) infinite; 根据贝塞尔曲线完成了加速减速的动画效果 😎cool~ 还有更多更酷的特效等着大家去探索~ 切记css-doodle 中不能写注释，大家拷贝的时候记得删掉 释义 :doodle 选择器会创建一个display: grid; 的布局 @grid提供布局， 用法为 @grid: 行 x 列 / 总宽高 @index 返回当前单元格的索引 hsla 此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度。 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% A：Alpha透明度。取值0~1之间。 @place-cell 调整单元格相对于网格放置。 @pick： 从给定列表中随机选择一个值。 turn: 转、圈（Turns）。一个圆共1圈 ( 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad ) 1turn 就是1圈 完整的代码1234567891011121314151617181920212223242526&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; @place-cell: center; border-color: hsla( calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8) ); border-width: calc(@index() * 10px); @size: calc(@index() * 10%); border-style: dashed; border-radius: 50%; --speed: @rand(20s, 40s); --start: @rand(360deg); --direction: calc(var(--start) + @pick(1turn, -1turn)); animation: demo var(--speed) cubic-bezier(0,.88,.42,.99) infinite; @keyframes demo &#123; form &#123; transform: rotate(var(--start)); &#125; to &#123; transform: rotate(var(--direction)); &#125; &#125;&lt;/css-doodle&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web-component</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CSS混合模式更改图片颜色]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%88%A9%E7%94%A8CSS%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E6%9B%B4%E6%94%B9%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[CSS3 新增了一个很有意思的属性 mix-blend-mode ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。 混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。 开始动手吧 ~ 尝试修改图片物体颜色首先我们创建一个Input框和一个 Img标签（其实这里我选择的图片不是很好）1234&lt;body&gt; &lt;input type="color" /&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553336864&amp;di=2f41edc8eedbf09fb1d106545acaed5f&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic44.nipic.com%2F20140723%2F19276212_171901262000_2.jpg" alt=""&gt;&lt;/body&gt; 然后我们将图片撑满屏幕， 将Input也撑满屏幕， 将input覆盖至图片之上， 然后为input 添加上混合模式mix-blend-mode: hue; 因为input框自带颜色， 所以当用户切换颜色时也就能不依靠JS 即时生效 123456789101112&lt;style&gt;html,body, input, img &#123; width: 100%; height: 100%;&#125;input&#123; position: absolute; top: 0; left: 0; mix-blend-mode: hue;&#125;&lt;/style&gt; 过程记录原图: 添加上了混合模式(变灰是因为color选择器默认是黑色): 切换颜色中: 切换后: 虽然有点丑但我们成功了~ 更多可能性利用整个混合模式的特性， 我们还能做出更多的东西， 比如利用三原色实现彩色loading、 万花筒等等炫酷动画， 可以看看参考文献中的例子， 非常的不错 参考文献 https://www.cnblogs.com/coco1s/p/6829372.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js与CSS变量操作]]></title>
    <url>%2F2019%2F03%2F16%2FJs%E4%B8%8ECSS%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[就目前来说CSS变量已经不是什么新鲜的东西了， 渐渐的我们可以在浏览器中尝试使用它， 和SCSS、 LESS 等预处理器不同的是， CSS的变量机制是浏览器天生支持的， 并且浏览器还对其做了优化， 减少了我们使用JS 去操作CSS变量造成的重绘和重排 一起来看看如何操作吧~ 变量虽好， 不可滥用哦 定义一个简单的变量12345678/* 定义css 变量 */:root &#123; --backgroundColor: pink;&#125;body &#123; background-color: var(--backgroundColor);&#125; 创建一个按钮123&lt;body&gt; &lt;button id="btn"&gt;点我改变背景&lt;/button&gt;&lt;/body&gt; 获取root元素并绑定按钮的点击事件12345678&lt;script&gt;var root = document.documentElementbtn.onclick = function() &#123; // 将变量修改为天蓝色 root.style.setProperty('--backgroundColor', 'skyblue')&#125;&lt;/script&gt; 结果对比点击前 按钮点击后 非常Nice~ 利用这个特性实现更多的可能吧！]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS如何了解新知识]]></title>
    <url>%2F2019%2F03%2F16%2FCSS%E5%A6%82%E4%BD%95%E4%BA%86%E8%A7%A3%E6%96%B0%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[平时闲着无聊的时候多去看看MDN或者一些国外的网站， 多试试一些新特性， 说不定就会有新的发现 并且还可以尝试着参与MDN的文章翻译及国外优质技术文章 MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference]]></content>
      <categories>
        <category>学习技巧</category>
      </categories>
      <tags>
        <tag>学习技巧</tag>
        <tag>学习渠道</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PostCss】使用明天的CSS]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90PostCss%E3%80%91%E4%BD%BF%E7%94%A8%E6%98%8E%E5%A4%A9%E7%9A%84CSS%2F</url>
    <content type="text"><![CDATA[通过PostCss作为CSS的后处理器， 可以根据浏览器的市场份额， 选择性的将一些最新的CSS新特性编译成浏览器支持的语法 当然国内的情况有点不一样 新特性举例比如这个CSS变量:他存储了媒体查询的规则， 在多个媒体查询的情况下就不用重复写了12345@custom-media --viewport-medium (width &lt;= 50rem);@media (--viewport-medium) &#123; body &#123; font-size: calc(var(--fontSize) * 1.2); &#125;&#125; 那这个属性浏览器兼容不理想怎么办？ 别担心， 交给PostCss, 经过处理， 我们可以看到，生成了一个规规矩矩的媒体查询代码 123@media (max-width: 50rem) &#123; body &#123; font-size: 1.2rem; &#125;&#125; 更多演示 编译前后以 —— 分割 自定义选择器1234@custom-selector :--heading h1, h2, h3, h4, h5, h6;:--heading &#123; margin-top: 0 &#125;/* ------------------------------------ */h1,h2,h3,h4,h5,h6 &#123; margin-top: 0 &#125; 自动一倍图(1X)和二倍图(2X)123456789101112131415161718192021222324/* image-set function */.foo &#123; background-image: image-set( url(img/test.png) 1x, url(img/test-2x.png) 2x );&#125;/* ------------------------------------ *//* 默认状态 */.foo &#123; background-image: url(img/test.png);&#125;/* 满足 设备上物理像素和设备独立像素( device-independent pixels (dips) )的比例 */@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) &#123;.foo &#123; background-image: url(img/test-2x.png);&#125;&#125; any-link, 补齐标签的剩余的所有状态， 这是为了防止某些样式不生效1234567891011121314151617181920212223a &#123;color: var(--highlightColor);transition: color 1s; /* autoprefixed ! */&#125;a:hover &#123; color: gray(255, 50%) &#125;a:active &#123; color: rebeccapurple &#125;a:focus &#123; background-color: rgb(255 153 0 / 33%); outline: 3px solid hsl(1turn 60% 50%); &#125;a:any-link &#123; color: color(var(--highlightColor) blackness(+20%)) &#125;/* --------------------------------- */a &#123; color: rgb(89, 185, 204); -webkit-transition: color 1s; transition: color 1s; /* autoprefixed ! */&#125;a:hover &#123; color: rgba(255, 255, 255, 0.5) &#125;a:active &#123; color: #639 &#125;a:focus &#123; background-color: rgba(255, 153, 0, .33); outline: 3px solid hsl(360, 60%, 50%); &#125;a:link,a:visited &#123; color: rgb(89, 142, 153) &#125; 还有很多， 不一一举例了， 比如： 各个浏览器的滤镜filter兼容 选择器正则 css嵌套 如何让PostCS支持嵌套 本环境基于webpack npm地址: https://www.npmjs.com/package/postcss https://www.npmjs.com/package/postcss-loader 1234567891011121314.container &#123; /* 一定要带上 &amp; 才会编译 */ &amp; .menu &#123; height: 40px; background: sandybrown; &amp; .menu--item &#123; height: 40px; color: skyblue; &amp; .menu--item__active &#123; color: pink; &#125; &#125; &#125;&#125; 首先在项目的根目录中创建一个文件postcss.config.js 相关依赖安装就不说了， 真的缺了也会报错提示的 我们将会在里面做PostCSS的相关配置 12345module.exports = &#123; plugins: [ require('postcss-nested') ]&#125; 然后接下来是配置 Loader ， 进入webpack 配置css loader 的地方， 我们在css loader 后面加上PostCss 的loader123456789101112131415161718192021222324252627rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'css-loader', &#125;, // --------------新增区域--------------- &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: (loader) =&gt; [ require('postcss-preset-env')(&#123; /* 这里要改成 0 否则不一定编译嵌套 */ stage: 0, features: &#123; 'nesting-rules': true &#125; &#125;) ] &#125; &#125; // --------------新增区域--------------- ] &#125;] 像这样，记得把 stage 这个参数修改为 0 ， 因为PostCss 会根据这个参数分为好几个阶段，阶段太高它是不处理嵌套的。 我们运行一下看看 1234567891011121314.container &#123; /* 一定要带上 &amp; 才会编译 */&#125;.container .menu &#123; height: 40px; background: sandybrown&#125;.container .menu .menu--item &#123; height: 40px; color: skyblue&#125;.container .menu .menu--item .menu--item__active &#123; color: pink;&#125; 大功告成😄~ 想知道有用的PostCSS的插件大纲，可以在本站内搜索: CSS插件 相关的网站 PostCss: https://postcss.org/css next: http://cssnext.io/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins构建前端持续集成]]></title>
    <url>%2F2019%2F03%2F16%2F%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[安装JDK 直接使用yum 安装的是 openjdk , 和sun 公司发布的jdk有略微区别， 但这里我们并不需要使用java,所以使用最快的方式安装 1yum install -y java 安装jenkins 添加Jenkins库到yum库，Jenkins将从这里下载安装。 123wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.reporpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.keyyum install -y jenkins 添加Jenkins库到yum库，Jenkins将从这里下载安装。12wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpmrpm -ivh jenkins-2.7.3-1.1.noarch.rpm 配置jenkis的端口 jenkins 的默认端口为 8080 ， 为了避免和其他的应用程序冲突， 所以建议修改一下默认占用的端口 1vim /etc/sysconfig/jenkins 找到修改端口号： JENKINS_PORT=”8080” 启动jenkins 1service jenkins start/stop/restart 安装成功后Jenkins将作为一个守护进程随系统启动 系统会创建一个“jenkins”用户来允许这个服务，如果改变服务所有者，同时需要修改/var/log/jenkins, /var/lib/jenkins, 和/var/cache/jenkins的所有者 启动的时候将从/etc/sysconfig/jenkins获取配置参数 默认情况下，Jenkins运行在8080端口，在浏览器中直接访问该端进行服务配置 Jenkins的RPM仓库配置被加到/etc/yum.repos.d/jenkins.repo 配置阶段安装好jenkins 后 ， 我们就可以根据刚才所设置的端口号访问 jenkins 服务了 比如进入 127.0.0.1:8081 访问jenkins 首先会看到让我们输入初始密码 它提示我们进入 /var/lib/jenkins/secrets/initialAdminPassword 查看 输入密码无误后， 就是提示我们安装对应的插件了， 左边是推荐安装， 右边是自定义安装， 这里我们建议点击 推荐安装 安装过程可能稍长 这时我们创建一个 Jenkins 账户，一定要牢记你的输入账号和密码， 用作之后的登录 创建账户之后， 会显示一个 jenkins 的资源根路径， 一般不需要修改， 保持默认即可 之后就是愉快的jenkins 之旅啦 补善插件阶段我们要做的前端持续集成， 所以 jenkins 默认安装的插件 并不能完全的满足我们的需求 进入jenkins 主页面后， 找到插件管理 首先查看我们必要的插件是否安装好了 NodeJs Plugin Publish Over SSH GitHub 如果发现没有安装的就安装， 查漏补缺 变量及远程服务器基本配置插件安装好后, 进入系统设置 界面, 进行变量的相关配置, 这里就展示几个可以修改的参数, 大部分都可以不用动, 使用默认就好 管理员邮件地址, 推荐填写, 当jenkins 工作完成后会把 构建信息发送至此邮箱 (这条选择填写) 可以选择配置 github 服务器, 并且可以配置多个, 因为你的项目代码有可能在多个服务器上 比较重要的就是这里了 , 配置远程服务器, 也就是你的发布地址 点击新增添加你的服务器 点击新增后, 这里有几个关键的参数, 需要注意 连接目标服务器肯定需要登录, 下面几个参数就是对应的验证参数, 你可以输入固定的密码, 也可以告诉Jenkins 你的本地私钥路径或私钥的内容, 前提是你配置了 ssh 的免密登录 填写密钥路径这里你很有可能会出现权限不够的错误， 如下图， 因为jenkins的在运行时会自动的创建一个名为jenkins的用户， 而这个用户的权限不够，无法访问你的目录 解决方案有两个: 把密钥切换至一个普通用户可以访问的目录， 并修改密钥的所属用户身份和访问权限 把jenkins 的运行身份修改为 root, 但是会有点安全性问题 本次实践以学习为目的， 所以这里我选择了第二钟 相关操作文章: https://blog.csdn.net/jeikerxiao/article/details/80768949 ssh 免密配置成功后， 我们就可以开始创建一个自己的任务了 创建任务阶段回到主页， 找到新建任务 进入新建任务后， 有几种不同的项目， 我们这里选择 自由风格， 并且输入项目名称 创建好项目后就会自动进入 当前项目的配置文件中 首先我们看到General, 这是一些全局的配置， 在这里我们可以写上该项目的描述 General的后面几个类目是构建项目阶段几个比较大的步骤和流程 如果你要配置的“github”项目， 可以在Git这里打上勾 并且填写上仓库地址 及 分支 即可， 如果需要填写账户密码， 则可在Credentials 处新增配置 接下来是看看构建触发器， 这里的填写根据你的工程需要， 可以配置定时任务 或 多任务构建 本次演示我并没有用到 现在来到我们的重点构建 ， 我们可以添加步骤，我们可以看到能够支持 Node、shell 、批处理等等方式 这些添加的步骤会按顺序执行， 我们需要shell 脚本来运行npm 命令 所以我创建了 shell的操作步骤 基于此， jenkins 就会自动帮我们做好 测试与打包的步骤， 在此之后， 我们需要将测试通过的项目代码推送到远程发布服务器上， 所以， 我们添加一个send files or execute commands over SSH 步骤， 建议新旧文件搞两个文件夹存放， 这样可以先删除掉旧文件再把新文件拷贝过去 deploy文件参考 你可能遇到的问题命令无效或不存在 这里拿npm举例， 其他命令如:node ,都是同理 因为全局的命令需要设置软连接 Jenkins 才可以访问的到 如何设置: 先查看一下你的 npm 在哪 whereis npm 这个/usr/local/bin/npm 就是你的npm所在位置 ( 使用带 local 的地址) 我们来创建 软连接, 这里使用刚刚获取到的npm ln -s /usr/local/bin/npm /usr/bin 如果出现无法修改的情况， 那我们就将他强制更改 😄 ln -sf /usr/local/bin/npm /usr/bin 再去构建一次Jenkins 任务 看到控制台输出， 现在npm 可以正常运行了 持续集成的必要条件 必须有github 、svn或私有git服务器 完整的项目 test 接口测试 其他的测试内容 CI 平台 项目代码要提交到Github、 svn等服务器上 保证代码在开发机的正常 bug 运行环境 ( 引用的包要写入packa) 保证jenkins 环境一切正常 发布服务器上也要存在基础的运行环境(不包括项目本身引用的包) 必要的静态资源服务器 配置jenkins的自动化处理流程 参考文章: https://www.cnblogs.com/loveyouyou616/p/8714544.html]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Jenkins</tag>
        <tag>Centos</tag>
        <tag>前端持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css预处理与后处理器]]></title>
    <url>%2F2019%2F03%2F16%2Fcss%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预处理器在前两年是非常流行的技术， 但是这两年发展的却不怎么有起色， 因为人们渐渐发先即使代码经过了预处理的的编译， 还要经过后处理， 并且PostCss 的崛起拥有了预处理器的功能， 可以完美代替预处理的工作， 并且可以做到让人们使用下一个版本的css 一旦预处理器阶段代码出现污染，预处理器的事就算是白干了， 不如直接交给后处理器， 所以使用预处理器的意义越来越小了 预处理器具有的能力 变量 混合(Mixin) Extend 嵌套规则 运算 函数 Namespaces &amp; Accessors (命名空间和访问器) scope 注释 后处理器的能力 CSS 压缩 CLEAN-CSS 自动添加浏览器前缀 Autoprefixer CSS更加美观排序 CSScomb Rework取代stylus 后处理器发热 前后通吃的 PostCss 他们是如何处理的CSS预处理器预处理器， 如： sass 它会先将他的语法转换成 AST–抽象语法树（Abstract Syntax Tree ）, AST是程序的一种中间表示形式， 然后遍历 AST 这棵树， 将对应想要的结果生成为CSS PostCssPostCss 改变了之前对CSS的处理流程， 它提供了一套插件的机制， 对于PostCss来说，自己是一套空的工程，它为插件提供了CSS数据， 根据配置的不同插件， 产生不同的功能]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手摸手AngularJs入门教程]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%89%8B%E6%91%B8%E6%89%8BAngularJs%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[AngularJs 是一款来自Google 的前端JavaScript框架， 也是SPA框架。 AngularJs框架的体积非常小， 但是设计理念和功能却非常强大， 极大地简化前端开发的负担， 它快速成为了JavaScript的主流框架， 帮助开发者从事web开发。 这里我们用AngularJs7的练手吧 起步 请确保电脑已安装了Node.js 首先是全局安装脚手架1npm install -g @angular/cli 安装好后查看一下版本 ng –version 确认ng命令存在后就可以开始创建我们的第一个 Angular 项目了12# 创建项目 project 替换为你的项目名称ng new project 当你输入命令后他会问你需要的配置， 这里附上我的选择， 大家可以参照 你是否需要添加路由？ —- yes 选择你喜欢的css 风格 —- SCSS 选择好后， 就会进入漫长的安装了 安装好后， cd 进入到项目所在的目录， 运行 ng serve 命令， 并打开http://localhost:4200/ 查看我们第一个 Angular项目12345678# 进入你的项目目录cd project# 启动项目ng serve# 如果你需要 可以生产环境运行ng serve --prod --aot 基本的路由配置 如果你不知道路由是什么， 你只需要先理解路由帮助我们实现切换页面的功能因为之前我们在构建项目时就选择了加入路由， 因此也省去了很多配置过程， 现在，我们来看看怎么用吧， 首先想使用路由， 得需要再创建一个”页面”（这里指组件）， 这样才能通过切换看出是否实现了路由， 那如何创建一个组件呢？ Angular 给我们提供了非常多的创建命令， 组件也可以一键的生成 我们来创建一个 Demo 组件 ng g c Demo 等待片刻， 安装好后 我们发现项目文件中的 app 目录下多了一个文件夹 里面有配套的 模板文件 样式文件 测试文件 ts 脚本文件 既然有了组件， 那我们现在需要为这个路由分配相应的访问路径 进入 app/app-routing.module.ts 这个文件 我们首先导入刚刚创建的Demo组件， 再 routes数组中，分配一个用于访问的path, 并和导入的DemoComponent关联上 如下: 123456789101112131415161718192021// ------------新增区域------------import &#123; DemoComponent &#125; from './demo/demo.component';// ------------新增区域------------import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ // -----------新增区域------------- &#123; path: "demo", component: DemoComponent &#125; // ------------新增区域------------];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; 然后进入 app/app.component.html 文件中找到 &lt;router-outlet&gt;&lt;/router-outlet&gt; 刚才配置的路由就会显示在这个标签所在的位置，为了减少一点干扰，我们把没有用的信息删除 !component19html切换后](http://img.nixiaolei.com/2019-03--17-17-27-25.png app.我只留了一张图片, 然后我们进入 app/demo/demo.component.html 文件中 原本是123&lt;p&gt; demo works!&lt;/p&gt; 我们改成明显一点的内容 千万注意dom结构别错了， dom结构错误会造成白屏，坑的是没有错误信息 123&lt;div&gt; &lt;h1&gt;我是Demo 页面&lt;/h1&gt;&lt;/div&gt; 我们看看是否配置成功了 首先，刚进入， 只有一张图片 让我们切换至/demo 我们可以看到， 刚刚为demo组件编写的文字成功显示出来了， 并且是位于图片下方， 这跟我们之前 app/app.component.html 中所做的配置一样 ——————–待完善————————- 常用的命令 把 XXX 替换成你要的名字 ng g cl xxx // 创建一个新类 ng g c xxx // 创建一个新组件 ng g d xxx // 创建一个新指令 ng g e xxx // 创建一个新枚举 ng g m xxx // 创建一个新模块 ng g p xxx // 创建一个新管道 ng g s xxx // 创建一个新的指服务 参考文献 https://github.com/angular/angular-cli/wiki]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中如何使用本地图片]]></title>
    <url>%2F2019%2F03%2F16%2Fhexo%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[首先需要修改_config.yml配置文件post_asset_folder项为true 使用命令创建博客1hexo new 你的文章名称 他会生成.md文件及一个对应的文件夹， 我们将图片放到该文件夹中 方法一在文章中这样插入图片1&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125; 效果如下: 方法二 这个方法在首页无法正常预览图片 安装一下这个插件 1npm install hexo-asset-image --save 在文章中这样插入图片1![这是一张图片](xxxx.png) 效果如下: 参考文献 http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
