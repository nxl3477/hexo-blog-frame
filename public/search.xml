<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【AOP】面向切面编程]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%90AOP%E3%80%91%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则之IOC控制反转]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BIOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[IOC （控制反转） Inversion of Control IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚。 什么是控制反转控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注⼊到对象中。 DI是IOC的一种表现形式 两种方式依赖查找容器提供回调接口和上下文条件给组件。 依赖注入组件不做定位查询， 需提供普通的方法让容器去决定依赖关系。 IOC概念图在未使用IOC的时候 各个 Object 之间的耦合度很高， 谁也离不开谁 在使用 IOC 后， 各个 Object 之间通过 IOC容器 整个第三方角色来调度， 变成了可任意组装的模式， 谁需要的时候注入谁， 降低了耦合度 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>IOC</tag>
        <tag>编程原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则之S.O.L.I.D]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BSOLID%2F</url>
    <content type="text"><![CDATA[作为一名优秀的工程师，最重要的不是招式， 而是内功， 像武侠小说里的高手， 一旦有了几十年的内功， 学什么武功都能快人一步 那编程里如何提升内功， 主要就是体现在编程思想上了， 逐层提升你编程思想比如从一开始的最传统的面向对象 到 面向切面 面向对象 -&gt; 工厂模式 -&gt; 面向切面 从 “oop 的静态抽象” 演变为 “aop的动态抽象” SOLID原则的基本概念让我们来看下 SOLID 的概念 程序设计领域， SOLID (单一一功能、开闭原则、⾥里里⽒氏替换、接⼝口隔离以及依赖反转)是由罗伯特·C·⻢马丁在21世纪早期 引⼊入的记忆术⾸首字⺟母缩略略字，指代了了⾯面向对象编程和⾯面向对象设计的五个基本原则。当这些原则被一一起应⽤用时，它们使得一一个程序员开发一一个容易易进⾏行行软件维护和扩展的系统变得更更加可能SOLID被典型的应⽤用在测试驱动开发上，并且是敏敏捷开发以及⾃自适应软件开发的基本原则的重要组成部分。 SOLID这几个字母代表什么意义？S (单一一功能原则) Single Responsibility Principle 单一一功能原则 ：单一一功能原则 认为对象应该仅具有一一种单一一功能的概念。换句句话说就是让一一个类只做一一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。在所有的SOLID原则中，这是⼤大多数开发⼈人员感到最能完全理理解的一一条。严格来说，这也可能是违反最频繁的一一条原则了了。单一一责任原则可以看作是低耦合、⾼内聚在面向对象原则上的引申，将责任定义为引起变化的原因，以提高内聚性来减少引起变化的原因。责任过多，可能引起它变化的原因就越多，这将导致责任依赖，相互之间就产⽣生影响，从⽽而极⼤大的损伤其内聚性和耦合度。单一一责任，通常意味着单一一的功能，因此不不要为一一个模块实 现过多的功能点，以保证实体只有一一个引起它变化的原因。 缩减一下就是: 让每个函数和每个类都只做一件小事，职责单一，解耦和 O (开闭原则) Open Close Principle 开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。软件实体应该是可扩展，而不不可修改的。也就是说，对扩展是开放的，而对修改是封闭的（“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不不应该被修改。也就是说你可以新增功能但不能去修改源码。）。这个原则是诸多面向对象编程原则中最抽象、最难理理解的一个。 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独⽴立完成其⼯工作，⽽而不要对类进⾏行行任何修改。可以使用变化和不变来说明：封装不变部分，开放变化部分，一般使用接口继承实现⽅方式来实现“开放”应对变化。 说大白话就是：你不不是要变化吗？，那么我就让你继承实现一个对象，用一个接口来抽象你的职责，你变化越多，继承实现的子类就越多。 让我们来看下一个简单的 Ts demo 糟糕的实现1234567891011121314class Animal &#123; constructor(name: any) &#123; super(name) this.name = name &#125; eat() &#123; if(this.name == '小猫') &#123; console.log(this.name + '吃猫粮') &#125; else if( this.name == "小狗") &#123; console.log(this.name + '吃狗粮') &#125; &#125;&#125; 这种糟糕的实现不但使程序的可扩展性降低， 而且每次新增一种动物都需要修改之前的代码， 容易造成隐患， 这和编程思想极大的违背 利用 OCP 思想1234567891011121314151617181920// Animal 抽象类abstract class Animal &#123; public name: string; constructor(name: string) &#123; this.name = name; &#125; abstract eat(): any;&#125;// 实现Animal抽象类class Dog extends Animal &#123; constructor(name: any) &#123; super(name) &#125; eat() &#123; console.log(this.name + '吃狗粮') &#125;&#125;var d = new Dog('小狗')d.eat() 上面的代码中， 首先使用abstract 定义抽象类和抽象方法，提供其他类继承的基类我们定义只要是Animal就必须要有eat方法 于是， 我们创建了一个Dog 继承Animal ,这个Dog就不一般了， 它规定了必须重新实现 eat 方法， 并且可以扩展自己的方法 当我们将来如果需要一只 Cat我们一样只需要让他继承Animal抽象类， 然后实现一个自己的eat方法 L (里⽒氏替换原则) Liskov Substitution Principle 里氏替换原则: 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下提前被它的子类所替换的”的概念。 子类必须能够替换他们的基类。即： 子类应该可以替换任何基类能够出现的地方， 并且经过替换以后， 代码还能正常工作。 另外， 不应该在代码中出现if/else之类对子类类型进行判断的条件。 里氏替换原则LSP使使代码符合开闭原则的一个重要保证。 正是由于子类的替换性才使得父类型的模块在无需修改的情况下就可以扩展。在很多情况下， 在设计初期我们类之间的关系不是很明确， LSP则给了我们一个判断和设计类之间关系的基准: 需不需要继承， 以及怎样设计继承关系。 当一个子类的实例应该能够替换任何其超类的实例时， 它们之间才具有is-A关系。 继承对于OCP， 就相当于多态性对于里氏替换原则。子类可以代替基类， 客户使用基类， 他们不需要知道派生类所做的事情。这是一个针对行为职责可替代的原则， 如果S是T的子类型， 那么S对象就应该在不改变任何抽象属性情况下替换所有T对象。 缩减一下就是: 老爸能干的事， 儿子必须都能干， 并且还要干的能多， 只要有儿子在， 老爸不在现场都没关系 I (接⼝隔离原则) Interface Segregation Principle 接口隔离原则: 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。 不能强迫用户去依赖那些他们不能使用的接口。 换句话说， 使用多个专门的接口比使用单一的总接口总要好(JavaScript几乎没有接口的概念， 所以使用ts)。 注意： 在代码中应用 ISP 并不一定意味着服务就是绝对安全的。 仍然需要采用良好的编码实践， 以确保正确的验证与授权。 这个原则起源于施乐公司， 他们需要建立了一个新的打印机系统， 可以执行诸如装订的印刷品一套，传真多种任务。此系统软件创建从底层开始编制， 并实现了这些任务功能， 但是不断增长的软件功能却使软件本身越来越难适应变化和维护。 每一次改变，即使是最小的变化， 有人可能需要近一个小时的重新编译和重新部署。这几乎不可能再继续发展， 所以他们聘请罗伯特(Robert)帮助他们。他们首先设计了一个主要类Job,几乎能够用于实现所有任务功能。 只要调用Job类的一个方法就可以实现一个功能， Job类就变动非常大， 是一个胖模型啊， 对于客户端如果只需要一个打印功能， 但是其他无关打印的方法功能也和其耦合， ISP原则建议在客户端和Job类之间增加一个接口层， 对于不同功能有不同的接口， 比如打印功能就是Print接口， 然后将大的Job类切分为继承不同接口的子类， 这样有一个Print Job类 等等。 缩减一下就是: 每一个业务都要准备一个接口， 每个不同功能的接口再继承自公共的基础接口 D (依赖反转原则) Dependency Inversion Principle 依赖倒置原则（Dependency Inversion Principle， DIP）规定： 代码应当取决于抽象概念， 而不是具体实现。 高层模块不应该依赖于底层模块， 二者都应该依赖于抽象抽象不应该依赖于细节， 细节应该依赖于抽象(总结解耦) 类可能依赖于其他类来执行其工作， 但是， 他们不应当依赖于该类的特定具体实现， 而应当是它的抽象。 这个原则实在是太重要了， 社会的分工化， 标准化都是这个设计原则的体现。显然， 这一概念会大大提高系统的灵活性。 如果类只是关心他们支持特定锲约而不是特定类型的组件， 就可以快速而轻松地修改这些低级服务的功能， 同时最大限度地降低对系统其余部分地影响。 举个例子: 你家里需要洗衣机， 不可能把整个洗衣机的生产流程都给实现了， 搬到自己家里， 当然时去超市商场购买一台洗衣机。 你需要电饭煲，也不可能把电饭煲地生产工艺实现了， 也是去商场买现成地。 此时商场就是一个容器， 商场帮我们去各个工厂采购这些商品， 当我们需要某件物品时就可以去商场购买现成地商品 依赖反转原则依赖注入 当某个⻆角⾊色要另一个角色协助时，通常由调用者来创建被调用者的实例。现在创建实例由容器来完成然后注⼊调用者。 注⼊入过程 如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注⼊ 依赖反转有两种方式 设值注入（在类上方设置字段） 构造注入 （在constructor中接收需要地参数） DI（依赖注⼊入） 依赖注⼊入（Dependency Injection） 为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注⼊是该原则的一种实现⽅方式。 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>编程原则</tag>
        <tag>SOLID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript手册]]></title>
    <url>%2F2019%2F03%2F18%2FTypeScript%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[TypeScript是JavaScript的超集 开发环境搭建 我的环境: window10 + vscode 全局安装Ts npm i -g typescript 生成并配置tsconfig.json tsc –init 配置文件， 下面的配置中ts应存放在src 目录下， 并且会自动编译到dist文件夹下1234567891011121314151617181920212223242526272829303132333435&#123; "compilerOptions": &#123; "target": "es2017", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' "module": "commonjs", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' "moduleResolution": "node", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) "emitDecoratorMetadata": true, // 为装饰器提供元数据的支持 "experimentalDecorators": true, // 启用装饰器 "allowSyntheticDefaultImports": true, // 允许从没有设置默认导出的模块中默认导入。 "strict": true, // 启用所有严格类型检查选项 "noImplicitAny": true, // 在表达式和声明上有隐含的 any类型时报错 "alwaysStrict": true, // 以严格模式检查没个模块，并在没个文件里加入 'use strict' "sourceMap": true, "noEmit": false, // 不生成输出文件 "removeComments": true, // 删除编译后的所有的注释 "importHelpers": true, // 从 tslib 导入辅助工具函数 "strictNullChecks": true, // 启用严格的 null 检查 "lib": ["es2017"], // 指定要包含在编译中的库文件 "typeRoots": ["node_modules/@types"], "types": [ "node", ], "outDir": "./dist", // 编译后文件产出目录 "rootDir": "./src" // 你的ts文件目录 &#125;, "include": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 "./src/*.ts", "./src/**/*.ts" ], "exclude": [ "node_modules", "dist", "**/*.test.ts", "public" ]&#125; 快速生成package.json npm init -y 运行命令， 开始监听 tsc -w 是否有效呢？ 让我们来试一下 进入src目录新建一个 hello.ts，记得是.ts， 不要写习惯了打成.js😅 随便写点东西， 比如定义一个字符串类型:1var a:string = "hello world" 如果你配置没有问题的话， 我们就会看到他监听文件修改并编译 这是ts文件与 编译后的js文件 并且在他运行过程中， 我们可以按F5进行调试 基本数据类型 Boolean Number String Array Enum Any Void 简单的几种数据的定义123456// 定义一个Booleanvar a:boolean = true// 定义一个Numbervar a:number = 13// 定义一个 String var a:string = "13" 基本的数据结构定义1var list:number[] = [1,2,3] 接口 interfaces 基础接口没有接口时我们如何规范参数类型12345function fn(dog:&#123;name:string&#125;) &#123; console.log(dog.name)&#125;var myObj = &#123; name: "Hello" &#125;fn(myObj) 有了接口， 我们就可以把参数规定与函数分离 如何创建接口 通过 interface 关键字来声明 1234567891011interface dogValue &#123; name:string;&#125;// 指定参数`dog`是接口类型function fn(dog: dogValue) &#123; console.log(dog.name)&#125;var myObj = &#123; name: "Hello" &#125;fn(myObj) // 编译通过 接口的可选属性接口定义的参数不一定每一个都会被用到 泛型什么是泛型? 泛型: 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 一句话理解就是： 参数化类型（把类型当作是参数一样传递） 使用泛型的好处: 代码更加简洁【不用强制转换】 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】 可读性和稳定性【在编写集合的时候，就限定了类型】 指定一个最简单的泛型123function Hello&lt;T&gt;(arg:T):T &#123; return arg;&#125; Module 模块Module 模式是常见的JavaScript模式之一， 在ES6的模块话实现之前， 人们通常通过 IFEE 来实现Module Module 的好处 模块化 可重用 封装变量和函数 来看看在ES6之前是如何书写的123(function() &#123; // do somtiong&#125;()); 让我们来看一个例子， 使用 TS 的 Module 来防止调用多种 interface 时的麻烦 使用Module之前1234567891011121314151617interface StringValidator &#123; // 接口定义的方法 isAcceptable(s:string):boolean;&#125;var lettersRegexp = /^[A-Za-z]+$]/;var numberRegexp = /^[0-9]+$/;// 实现接口的方法class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return lettersRegexp.test(s) &#125;&#125; class ZipCodeValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s) &#125;&#125; 使用了Module 的书写方式后 1234567891011121314151617181920module Validation &#123; // 需要使用 export 来表示对外暴露 export interface StringValidator &#123; isAcceptable(s:string): boolean; &#125; var lettersRegexp = /^[A-Za-z]+$]/; var numberRegexp = /^[0-9]+$/; export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s:string) &#123; return lettersRegexp.test(s) &#125; &#125; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s) &#125; &#125;&#125; Module 与 类相结合使用12345678910111213141516171819module Person &#123; export class Student &#123; name: string; constructor(name:string) &#123; this.name = name; &#125; study() &#123; console.log(this.name + '在学习') &#125; speak() &#123; console.log(this.name + '在说话') &#125; &#125;&#125;// ----------- 使用时 -------------const xiaoming = new Person.Student('小明')xiaoming.study() NamespacesNamespaces 的和Module 的用法相同， 在Ts 的1.5 版本后， 用 Namespaces 取代了 Module 查看一下官方的示例 123456789namespace Shapes &#123; export namespace Polygons &#123; export class Triangle &#123; &#125; export class Square &#123; &#125; &#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()' 装饰器 &lt; Decorators &gt;如何定义一个装饰器 其实装饰器就是一个普通的函数， 他接收一个参数target ，这个参数就是被装饰对象， 看下面的例子， sealed 装饰了Dog类， 并且在sealed 中打印了 target ， 让我们看看 target到底是什么？123456789101112function sealed(target:any) &#123; // do something with 'target' ... console.log(target) return target&#125;// 被装饰的对象 foo@sealedclass Dog &#123;&#125; 打印结果 我们可以看到， 得到的正是 Dog这个类 装饰器工厂&lt; Decorator Factories &gt; 如果希望自定义如何将装饰器应用于声明，可以编写装饰器工厂。装饰器工厂只是一个函数，它返回将在运行时由装饰器调用的表达式。 装饰器工厂和普通装饰器相比的好处就是更加的自定义了， 可以根据不同情况自定义效果 如何定义一个装饰器工厂 123456789101112function dec(value:string) &#123; return function (target:any) &#123; console.log(value) console.log(target) &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; &#125; 让我们来看看运行的结果 可以看到，我们传入的test字符串和 Cat类都被打印出来了， 多装饰器的执行顺序使用多个装饰器时如何书写呢? 当我们使用多个装饰器时有两种写法 写成一行 1@f @g x 垂直书写 123@f@gx 多个装饰器的执行顺序是如何的呢？ 套用官网的说明 对每个装饰器的表达式进行自上而下的计算。 然后将结果作为自下而上的函数调用。 其实真实的运行原理是1f(g(x)) 访问器修饰器访问器修饰器的接收的参数和方法修饰器接收的参数一样 123456789101112131415161718192021function dec(value:string) &#123; return function (target:any, propertyKey: string, descriptor: PropertyDescriptor) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; this._x = x this._y = y &#125; // 访问器修饰器 @dec(true) get x() &#123; return this._x &#125; @dec(false) get y() &#123; return this._y &#125;&#125; 属性修饰器属性修饰器只有前两个参数123456789101112131415161718function dec(value:string) &#123; return function (target:any, propertyKey: string) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; // 属性修饰器 @dec(false) this._x = x this._y = y &#125;&#125; 参数修饰器参数修饰器也是三个参数， 但不同的是第三个参数接收 参数装饰器只能确认一个方法的参数是否被传入 前两个和其他的修饰器都相同， target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象 propertyKey 成员的名称 参数在所处函数的参数列表中的索引， 说人话就是告诉你他是第几个参数 1234567891011function require(value:boolean) &#123; return function (target:any, propertyKey: string, index: number) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; run(@require(true) name:string) &#123; &#125;&#125; 装饰器参数 类装饰器 类装饰器的参数只接收一个， 那就是target 也就是这个类本身 就和上面演示的那些例子一样 方法装饰器 一般会传入三个参数 target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象 propertyKey 成员的名称 descriptor 成员属性的描述符 我们来验证下方法装饰器的参数 让我们看看这段例子会输出什么123456789101112function f(value:string) &#123; return function (target:any, propertyKey: string, descriptor: PropertyDescriptor) &#123; console.log(arguments) console.log(target) &#125;&#125;class Tiger &#123; @f('tiger run') run() &#123; &#125;&#125; 输入结果: 在控制台输出， 我们看到了，第一个参数是 tiger 的实例对象（因为run是实例成员） 第二个参数是成员名称， 也就是被装饰的run 第三个参数是 run 的属性描述符 Mixins 混入除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。 Mixins 其实可以拆分为两个单词 Mix : 混合 ins : 是进入 所以合在一起就是叫 混入 的意思的单词 它想要表达的是一个对象中混入另一个对象的方法 让我们来实现一下Mixins 代码里首先定义两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。 12345678910111213141516171819// Disposable Mixinclass Disposable &#123; isDisposed: boolean; dispose() &#123; this.isDisposed = true; &#125;&#125;// Activatable Mixinclass Activatable &#123; isActive: boolean; activate() &#123; this.isActive = true; &#125; deactivate() &#123; this.isActive = false; &#125;&#125; 创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：12class SmartObject implements Disposable, Activatable &#123; &#125; 这里我们没有使用extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的。 我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。 也就是这样 1234567891011121314151617class SmartObject implements Disposable, Activatable &#123; constructor() &#123; setInterval(() =&gt; console.log(this.isActive + " : " + this.isDisposed), 500); &#125; interact() &#123; this.activate(); &#125; // Disposable isDisposed: boolean = false; dispose: () =&gt; void; // Activatable isActive: boolean = false; activate: () =&gt; void; deactivate: () =&gt; void;&#125; 最后，把mixins混入定义的类，完成全部实现部分。1applyMixins(SmartObject, [Disposable, Activatable]); 我们同时也需要创建这个帮助函数， 帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。1234567function applyMixins(derivedCtor: any, baseCtors: any[]) &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;) &#125;);&#125; 参考文献 https://segmentfault.com/a/1190000016305647 ————————-待完善—————————-]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法工具&插件]]></title>
    <url>%2F2019%2F03%2F17%2F%E7%AE%97%E6%B3%95%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[学习帮助 算法过程可视化: https://algorithm-visualizer.org/branch-and-bound/binary-search]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>工具</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux工具&插件]]></title>
    <url>%2F2019%2F03%2F17%2FLinux%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[vim 快速学习vim的网站: https://vim-adventures.com/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>工具</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css分层&命名规范]]></title>
    <url>%2F2019%2F03%2F16%2Fcss%E5%88%86%E5%B1%82-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[为什么要分层? CSS有语义化的命名约定和CSS层的分离， 将有助于它的可扩展性， 性能的提高和代码的组织管理。 避免大量的样式、 覆盖、 权重和很多！important, 分好层可以让团队命名统一规范， 方便维护。 有责任感地去命名你的选择器 有哪些分层理论? SMACSS BEM SUIT ACSS ITCSS BEMBEM和SMACCS非常类似， 主要用来如何给项目命名。一个简单命名更容易让别人一起工作。 比如选项卡导航是一个块(Block)， 这个块里的元素是其中标签之一（Element）, 而当前选项卡是一个修饰状态( Modifier ) block - 代表了更高级别的抽象或组件 block__element - 代表.block的后代， 用于形成一个完整的.block的整体。 block–modifier - 代表.block 的不同状态或不同版本。 修饰符使用的是_, 子模块使用的是__符号。 ( 不同一个-的原因是因为CSS单词连接 ) 12345678&lt;!-- container 是大容器 --&gt;&lt;div class="container"&gt; &lt;div class="menu"&gt; &lt;div class="menu--item menu--item__active"&gt;首页&lt;/div&gt; &lt;div class="menu--item"&gt;新闻&lt;/div&gt; &lt;div class="menu--item"&gt;消息&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【css-doodle】 css web-component入门]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90css-doodle%E3%80%91css-web-component%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[首先祭出 css-doodle的官网， 真的老厉害了， 使用它能够轻松的实现各种炫酷特效 https://css-doodle.com/ &lt;css-doodle /&gt;基于 Shadow DOM v1和 Custom Elements v1。您可以立即在最新的Chrome，Safari和Firefox上使用它，而无需使用polyfill。该组件将根据其中的规则（纯CSS）生成div网格。您可以使用CSS轻松操作这些单元格，以获得图形模式或动画图形。限制是CSS本身的限制。 既然它这么牛逼， 那怎么用呢？ 我们一起来搭几个demo css-doodle入门 此处用到的语法或api有不了解的 请看页面下方的“释义” 区域 动手过程中需要注意， 不要在css-doodle内部写注释， 会导致样式无效 首先搭建好运行css-doodle的环境12345678&lt;!-- 引入CDN --&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.5.1/css-doodle.min.js"&gt;&lt;/script&gt;&lt;!-- 页面上加入 css-doodle --&gt;&lt;css-doodle&gt;&lt;!-- 我们将在这里写代码 --&gt;&lt;/css-doodle&gt; 此时如果我们打开页面， 你会发现是空空如也的， 因为这个元素既没有宽高也没有背景颜色， 我们当然看不到。 现在我们给他加点料。 12345&lt;css-doodle&gt; width: 100px; height: 100px; background: red;&lt;/css-doodle&gt; 此时我们再看看页面， 就出现了一个100 x 100的红色小方块， 好，这个相当于hello world 级别的练习就完成了， 我们再来点难的： 我想要一个10 x 10 个的小方块组成的大正方形! 正好我们可以借此尝试使用一下它提供的API 123456&lt;css-doodle&gt; :doodle &#123; @grid: 10x10 / 500px; &#125; background: #60569e;&lt;/css-doodle&gt; 出现了！ 我们要的 10 x 10 个小方块组成的大正方， 并且还把颜色换成了骚骚的紫色 好既然实现了， 那现在需求升级了 那我要10个长方形怎么办， 并且我还要长短不一的！ 我去，还要长短不一， 咋整呢 别慌 机制的你一定可以在官网找到有一个获取当前小方块顺序的的参数@index 严格的来说他会返回当前单元格的索引值 既然有方法了那我们也有思路了， 二话不说开始动手。 12345678910&lt;!-- 首先把 10 x 10 小方块变为10个长方形 --&gt;&lt;!-- 然后根据 @index 获取当前单元格的索引 --&gt;&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; background: #60569e; @size: calc(@index() * 1vmin);&lt;/css-doodle&gt;&lt;!-- 根据 index 这个索引值乘以高度 --&gt; duang! 这就是我们想要的结果了， 虽然还有点不完美， 其实每个紫色都是一个正方形， 但所在的单元格是长方形没跑了 我们再给他加上border-radius: 50%; 它就变成10个球了 此时需求又来了 甲方：可不可以弄10个光环？还是渐变的那种? 行吧， 试试喽谁怕谁 我们可以举一反三， 利用@index这个好东西来修改hsla产生不同的颜色， 当然修改rgba 也是可以的 123456789101112&lt;!-- 根据index 每个的单元格递增20的色调， 再调整出不同的透明度 --&gt;&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; border-color: hsla( calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8) ); @size: calc(@index() * 10%); border-style: dashed; border-radius: 50%;&lt;/css-doodle&gt; 好， 甲方爸爸， 你的需求我做到了 甲方: 还不够，我要的是同心圆 我。。。。。 得嘞，您说是啥就是啥 同心圆， 你第一反应想到的是不是使用position: absolute; ?不 ，那太low 了我们只需要 @place-cell: center; 这个参数就搞定了， 它会将每个单元格都摆放至中间 12345678&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; @place-cell: center; &lt;!-- ...省略之前的代码 --&gt;&lt;/css-doodle&gt; 然后去看一下效果， 卧槽 进阶基础学的差不多了， 其他的一些api有了上面的参照都应该思路了吧 既然是进阶篇， 我们就做点难的， 我们看看能不能利用这些特性和 CSS动画结合一下 我们先让光环变粗一点， 让他呈现扇叶的形状 1border-width: calc(@index() * 10px); 然后让我们用上 keyframes ， 为他添加动画 为每个单元格注册几个css变量（css的新特性）， 变量--speed控制动画的持续时间，也就是速度。 --start 控制当前光环的起始角度 --direction: 控制方向， 因为turn表示一圈， 所以 1turn 就是正的转一圈,-1turn 就是反着转一圈， 利用@pick方法来随机取一个值 1234567891011121314151617181920212223&lt;css-doodle&gt; &lt;!-- ...省略之前的代码 --&gt; &lt;!-- 动画执行时间在20秒 - 40秒之间取值--&gt; --speed: @rand(20s, 40s); &lt;!-- 360度里取随机数 --&gt; --start: @rand(360deg); &lt;!-- 顺时针 或 逆时针 --&gt; --direction: calc(var(--start) + @pick(1turn, -1turn)); animation: demo var(--speed) linear infinite; @keyframes demo &#123; form &#123; &lt;!-- 填入起始角度 --&gt; transform: rotate(var(--start)); &#125; to &#123; &lt;!-- 随机顺时针和逆时针旋转 --&gt; transform: rotate(var(--direction)); &#125; &#125;&lt;/css-doodle&gt; 看看效果 炫酷不？ 能不能再酷一点？ 可以， 我们再给他添一笔， 给他加上一个自定义的贝塞尔 贝塞尔可以去这个网站，根据需要生成 http://cubic-bezier.com/#1,.25,.83,.67 然后我们你所需要的贝塞尔去更改animation 的参数1animation: demo var(--speed) cubic-bezier(0,.88,.42,.99) infinite; 根据贝塞尔曲线完成了加速减速的动画效果 😎cool~ 还有更多更酷的特效等着大家去探索~ 切记css-doodle 中不能写注释，大家拷贝的时候记得删掉 释义 :doodle 选择器会创建一个display: grid; 的布局 @grid提供布局， 用法为 @grid: 行 x 列 / 总宽高 @index 返回当前单元格的索引 hsla 此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度。 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% A：Alpha透明度。取值0~1之间。 @place-cell 调整单元格相对于网格放置。 @pick： 从给定列表中随机选择一个值。 turn: 转、圈（Turns）。一个圆共1圈 ( 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad ) 1turn 就是1圈 完整的代码1234567891011121314151617181920212223242526&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; @place-cell: center; border-color: hsla( calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8) ); border-width: calc(@index() * 10px); @size: calc(@index() * 10%); border-style: dashed; border-radius: 50%; --speed: @rand(20s, 40s); --start: @rand(360deg); --direction: calc(var(--start) + @pick(1turn, -1turn)); animation: demo var(--speed) cubic-bezier(0,.88,.42,.99) infinite; @keyframes demo &#123; form &#123; transform: rotate(var(--start)); &#125; to &#123; transform: rotate(var(--direction)); &#125; &#125;&lt;/css-doodle&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web-component</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CSS混合模式更改图片颜色]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%88%A9%E7%94%A8CSS%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E6%9B%B4%E6%94%B9%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[CSS3 新增了一个很有意思的属性 mix-blend-mode ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。 混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。 开始动手吧 ~ 尝试修改图片物体颜色首先我们创建一个Input框和一个 Img标签（其实这里我选择的图片不是很好）1234&lt;body&gt; &lt;input type="color" /&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553336864&amp;di=2f41edc8eedbf09fb1d106545acaed5f&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic44.nipic.com%2F20140723%2F19276212_171901262000_2.jpg" alt=""&gt;&lt;/body&gt; 然后我们将图片撑满屏幕， 将Input也撑满屏幕， 将input覆盖至图片之上， 然后为input 添加上混合模式mix-blend-mode: hue; 因为input框自带颜色， 所以当用户切换颜色时也就能不依靠JS 即时生效 123456789101112&lt;style&gt;html,body, input, img &#123; width: 100%; height: 100%;&#125;input&#123; position: absolute; top: 0; left: 0; mix-blend-mode: hue;&#125;&lt;/style&gt; 过程记录原图: 添加上了混合模式(变灰是因为color选择器默认是黑色): 切换颜色中: 切换后: 虽然有点丑但我们成功了~ 更多可能性利用整个混合模式的特性， 我们还能做出更多的东西， 比如利用三原色实现彩色loading、 万花筒等等炫酷动画， 可以看看参考文献中的例子， 非常的不错 参考文献 https://www.cnblogs.com/coco1s/p/6829372.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS插件及工具]]></title>
    <url>%2F2019%2F03%2F16%2FCSS%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[CSS兼容查询 https://caniuse.com/ https://cssdb.org/ 动画 贝塞尔: http://cubic-bezier.com/#.17,.67,.83,.67 高逼格 web component CSS: https://css-doodle.com/ PostCss 值得收藏的插件 POSTCSS-CUSTOM-PROPERTIES 运行时变量 POSTCSS-SIMPLE-VARS 与SCSS一致的变量实现 POSTCSS-MIXINS 实现类似SASS的@MIXIN的功能 POSTCSS-EXTEND 实现类似SASS的继承功能 POSTCSS-IMPORT 实现类似SASS的IMPORT CSSNext 面向未来 CSS Grace 修复过去（兼容IE，zomm、一像素留白等）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
        <tag>插件</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js与CSS变量操作]]></title>
    <url>%2F2019%2F03%2F16%2FJs%E4%B8%8ECSS%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[就目前来说CSS变量已经不是什么新鲜的东西了， 渐渐的我们可以在浏览器中尝试使用它， 和SCSS、 LESS 等预处理器不同的是， CSS的变量机制是浏览器天生支持的， 并且浏览器还对其做了优化， 减少了我们使用JS 去操作CSS变量造成的重绘和重排 一起来看看如何操作吧~ 变量虽好， 不可滥用哦 定义一个简单的变量12345678/* 定义css 变量 */:root &#123; --backgroundColor: pink;&#125;body &#123; background-color: var(--backgroundColor);&#125; 创建一个按钮123&lt;body&gt; &lt;button id="btn"&gt;点我改变背景&lt;/button&gt;&lt;/body&gt; 获取root元素并绑定按钮的点击事件12345678&lt;script&gt;var root = document.documentElementbtn.onclick = function() &#123; // 将变量修改为天蓝色 root.style.setProperty('--backgroundColor', 'skyblue')&#125;&lt;/script&gt; 结果对比点击前 按钮点击后 非常Nice~ 利用这个特性实现更多的可能吧！]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS如何了解新知识]]></title>
    <url>%2F2019%2F03%2F16%2FCSS%E5%A6%82%E4%BD%95%E4%BA%86%E8%A7%A3%E6%96%B0%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[平时闲着无聊的时候多去看看MDN或者一些国外的网站， 多试试一些新特性， 说不定就会有新的发现 并且还可以尝试着参与MDN的文章翻译及国外优质技术文章 MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference]]></content>
      <categories>
        <category>学习技巧</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>学习技巧</tag>
        <tag>学习渠道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PostCss】使用明天的CSS]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90PostCss%E3%80%91%E4%BD%BF%E7%94%A8%E6%98%8E%E5%A4%A9%E7%9A%84CSS%2F</url>
    <content type="text"><![CDATA[通过PostCss作为CSS的后处理器， 可以根据浏览器的市场份额， 选择性的将一些最新的CSS新特性编译成浏览器支持的语法 当然国内的情况有点不一样 新特性举例比如这个CSS变量:他存储了媒体查询的规则， 在多个媒体查询的情况下就不用重复写了12345@custom-media --viewport-medium (width &lt;= 50rem);@media (--viewport-medium) &#123; body &#123; font-size: calc(var(--fontSize) * 1.2); &#125;&#125; 那这个属性浏览器兼容不理想怎么办？ 别担心， 交给PostCss, 经过处理， 我们可以看到，生成了一个规规矩矩的媒体查询代码 123@media (max-width: 50rem) &#123; body &#123; font-size: 1.2rem; &#125;&#125; 更多演示 编译前后以 —— 分割 自定义选择器1234@custom-selector :--heading h1, h2, h3, h4, h5, h6;:--heading &#123; margin-top: 0 &#125;/* ------------------------------------ */h1,h2,h3,h4,h5,h6 &#123; margin-top: 0 &#125; 自动一倍图(1X)和二倍图(2X)123456789101112131415161718192021222324/* image-set function */.foo &#123; background-image: image-set( url(img/test.png) 1x, url(img/test-2x.png) 2x );&#125;/* ------------------------------------ *//* 默认状态 */.foo &#123; background-image: url(img/test.png);&#125;/* 满足 设备上物理像素和设备独立像素( device-independent pixels (dips) )的比例 */@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) &#123;.foo &#123; background-image: url(img/test-2x.png);&#125;&#125; any-link, 补齐标签的剩余的所有状态， 这是为了防止某些样式不生效1234567891011121314151617181920212223a &#123;color: var(--highlightColor);transition: color 1s; /* autoprefixed ! */&#125;a:hover &#123; color: gray(255, 50%) &#125;a:active &#123; color: rebeccapurple &#125;a:focus &#123; background-color: rgb(255 153 0 / 33%); outline: 3px solid hsl(1turn 60% 50%); &#125;a:any-link &#123; color: color(var(--highlightColor) blackness(+20%)) &#125;/* --------------------------------- */a &#123; color: rgb(89, 185, 204); -webkit-transition: color 1s; transition: color 1s; /* autoprefixed ! */&#125;a:hover &#123; color: rgba(255, 255, 255, 0.5) &#125;a:active &#123; color: #639 &#125;a:focus &#123; background-color: rgba(255, 153, 0, .33); outline: 3px solid hsl(360, 60%, 50%); &#125;a:link,a:visited &#123; color: rgb(89, 142, 153) &#125; 还有很多， 不一一举例了， 比如： 各个浏览器的滤镜filter兼容 选择器正则 css嵌套 如何让PostCS支持嵌套 本环境基于webpack npm地址: https://www.npmjs.com/package/postcss https://www.npmjs.com/package/postcss-loader 1234567891011121314.container &#123; /* 一定要带上 &amp; 才会编译 */ &amp; .menu &#123; height: 40px; background: sandybrown; &amp; .menu--item &#123; height: 40px; color: skyblue; &amp; .menu--item__active &#123; color: pink; &#125; &#125; &#125;&#125; 首先在项目的根目录中创建一个文件postcss.config.js 相关依赖安装就不说了， 真的缺了也会报错提示的 我们将会在里面做PostCSS的相关配置 12345module.exports = &#123; plugins: [ require('postcss-nested') ]&#125; 然后接下来是配置 Loader ， 进入webpack 配置css loader 的地方， 我们在css loader 后面加上PostCss 的loader123456789101112131415161718192021222324252627rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'css-loader', &#125;, // --------------新增区域--------------- &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: (loader) =&gt; [ require('postcss-preset-env')(&#123; /* 这里要改成 0 否则不一定编译嵌套 */ stage: 0, features: &#123; 'nesting-rules': true &#125; &#125;) ] &#125; &#125; // --------------新增区域--------------- ] &#125;] 像这样，记得把 stage 这个参数修改为 0 ， 因为PostCss 会根据这个参数分为好几个阶段，阶段太高它是不处理嵌套的。 我们运行一下看看 1234567891011121314.container &#123; /* 一定要带上 &amp; 才会编译 */&#125;.container .menu &#123; height: 40px; background: sandybrown&#125;.container .menu .menu--item &#123; height: 40px; color: skyblue&#125;.container .menu .menu--item .menu--item__active &#123; color: pink;&#125; 大功告成😄~ 想知道有用的PostCSS的插件大纲，可以在本站内搜索: CSS插件 相关的网站 PostCss: https://postcss.org/css next: http://cssnext.io/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins构建前端持续集成]]></title>
    <url>%2F2019%2F03%2F16%2F%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[安装JDK 直接使用yum 安装的是 openjdk , 和sun 公司发布的jdk有略微区别， 但这里我们并不需要使用java,所以使用最快的方式安装 1yum install -y java 安装jenkins 添加Jenkins库到yum库，Jenkins将从这里下载安装。 123wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.reporpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.keyyum install -y jenkins 添加Jenkins库到yum库，Jenkins将从这里下载安装。12wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpmrpm -ivh jenkins-2.7.3-1.1.noarch.rpm 配置jenkis的端口 jenkins 的默认端口为 8080 ， 为了避免和其他的应用程序冲突， 所以建议修改一下默认占用的端口 1vim /etc/sysconfig/jenkins 找到修改端口号： JENKINS_PORT=”8080” 启动jenkins 1service jenkins start/stop/restart 安装成功后Jenkins将作为一个守护进程随系统启动 系统会创建一个“jenkins”用户来允许这个服务，如果改变服务所有者，同时需要修改/var/log/jenkins, /var/lib/jenkins, 和/var/cache/jenkins的所有者 启动的时候将从/etc/sysconfig/jenkins获取配置参数 默认情况下，Jenkins运行在8080端口，在浏览器中直接访问该端进行服务配置 Jenkins的RPM仓库配置被加到/etc/yum.repos.d/jenkins.repo 配置阶段安装好jenkins 后 ， 我们就可以根据刚才所设置的端口号访问 jenkins 服务了 比如进入 127.0.0.1:8081 访问jenkins 首先会看到让我们输入初始密码 它提示我们进入 /var/lib/jenkins/secrets/initialAdminPassword 查看 输入密码无误后， 就是提示我们安装对应的插件了， 左边是推荐安装， 右边是自定义安装， 这里我们建议点击 推荐安装 安装过程可能稍长 这时我们创建一个 Jenkins 账户，一定要牢记你的输入账号和密码， 用作之后的登录 创建账户之后， 会显示一个 jenkins 的资源根路径， 一般不需要修改， 保持默认即可 之后就是愉快的jenkins 之旅啦 补善插件阶段我们要做的前端持续集成， 所以 jenkins 默认安装的插件 并不能完全的满足我们的需求 进入jenkins 主页面后， 找到插件管理 首先查看我们必要的插件是否安装好了 NodeJs Plugin Publish Over SSH GitHub 如果发现没有安装的就安装， 查漏补缺 变量及远程服务器基本配置插件安装好后, 进入系统设置 界面, 进行变量的相关配置, 这里就展示几个可以修改的参数, 大部分都可以不用动, 使用默认就好 管理员邮件地址, 推荐填写, 当jenkins 工作完成后会把 构建信息发送至此邮箱 (这条选择填写) 可以选择配置 github 服务器, 并且可以配置多个, 因为你的项目代码有可能在多个服务器上 比较重要的就是这里了 , 配置远程服务器, 也就是你的发布地址 点击新增添加你的服务器 点击新增后, 这里有几个关键的参数, 需要注意 连接目标服务器肯定需要登录, 下面几个参数就是对应的验证参数, 你可以输入固定的密码, 也可以告诉Jenkins 你的本地私钥路径或私钥的内容, 前提是你配置了 ssh 的免密登录 填写密钥路径这里你很有可能会出现权限不够的错误， 如下图， 因为jenkins的在运行时会自动的创建一个名为jenkins的用户， 而这个用户的权限不够，无法访问你的目录 解决方案有两个: 把密钥切换至一个普通用户可以访问的目录， 并修改密钥的所属用户身份和访问权限 把jenkins 的运行身份修改为 root, 但是会有点安全性问题 本次实践以学习为目的， 所以这里我选择了第二钟 相关操作文章: https://blog.csdn.net/jeikerxiao/article/details/80768949 ssh 免密配置成功后， 我们就可以开始创建一个自己的任务了 创建任务阶段回到主页， 找到新建任务 进入新建任务后， 有几种不同的项目， 我们这里选择 自由风格， 并且输入项目名称 创建好项目后就会自动进入 当前项目的配置文件中 首先我们看到General, 这是一些全局的配置， 在这里我们可以写上该项目的描述 General的后面几个类目是构建项目阶段几个比较大的步骤和流程 如果你要配置的“github”项目， 可以在Git这里打上勾 并且填写上仓库地址 及 分支 即可， 如果需要填写账户密码， 则可在Credentials 处新增配置 接下来是看看构建触发器， 这里的填写根据你的工程需要， 可以配置定时任务 或 多任务构建 本次演示我并没有用到 现在来到我们的重点构建 ， 我们可以添加步骤，我们可以看到能够支持 Node、shell 、批处理等等方式 这些添加的步骤会按顺序执行， 我们需要shell 脚本来运行npm 命令 所以我创建了 shell的操作步骤 基于此， jenkins 就会自动帮我们做好 测试与打包的步骤， 在此之后， 我们需要将测试通过的项目代码推送到远程发布服务器上， 所以， 我们添加一个send files or execute commands over SSH 步骤， 建议新旧文件搞两个文件夹存放， 这样可以先删除掉旧文件再把新文件拷贝过去 deploy文件参考 你可能遇到的问题命令无效或不存在 这里拿npm举例， 其他命令如:node ,都是同理 因为全局的命令需要设置软连接 Jenkins 才可以访问的到 如何设置: 先查看一下你的 npm 在哪 whereis npm 这个/usr/local/bin/npm 就是你的npm所在位置 ( 使用带 local 的地址) 我们来创建 软连接, 这里使用刚刚获取到的npm ln -s /usr/local/bin/npm /usr/bin 如果出现无法修改的情况， 那我们就将他强制更改 😄 ln -sf /usr/local/bin/npm /usr/bin 再去构建一次Jenkins 任务 看到控制台输出， 现在npm 可以正常运行了 持续集成的必要条件 必须有github 、svn或私有git服务器 完整的项目 test 接口测试 其他的测试内容 CI 平台 项目代码要提交到Github、 svn等服务器上 保证代码在开发机的正常 bug 运行环境 ( 引用的包要写入packa) 保证jenkins 环境一切正常 发布服务器上也要存在基础的运行环境(不包括项目本身引用的包) 必要的静态资源服务器 配置jenkins的自动化处理流程 参考文章: https://www.cnblogs.com/loveyouyou616/p/8714544.html]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Jenkins</tag>
        <tag>Centos</tag>
        <tag>前端持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css预处理与后处理器]]></title>
    <url>%2F2019%2F03%2F16%2Fcss%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预处理器在前两年是非常流行的技术， 但是这两年发展的却不怎么有起色， 因为人们渐渐发先即使代码经过了预处理的的编译， 还要经过后处理， 并且PostCss 的崛起拥有了预处理器的功能， 可以完美代替预处理的工作， 并且可以做到让人们使用下一个版本的css 一旦预处理器阶段代码出现污染，预处理器的事就算是白干了， 不如直接交给后处理器， 所以使用预处理器的意义越来越小了 预处理器具有的能力 变量 混合(Mixin) Extend 嵌套规则 运算 函数 Namespaces &amp; Accessors (命名空间和访问器) scope 注释 后处理器的能力 CSS 压缩 CLEAN-CSS 自动添加浏览器前缀 Autoprefixer CSS更加美观排序 CSScomb Rework取代stylus 后处理器发热 前后通吃的 PostCss 他们是如何处理的CSS预处理器预处理器， 如： sass 它会先将他的语法转换成 AST–抽象语法树（Abstract Syntax Tree ）, AST是程序的一种中间表示形式， 然后遍历 AST 这棵树， 将对应想要的结果生成为CSS PostCssPostCss 改变了之前对CSS的处理流程， 它提供了一套插件的机制， 对于PostCss来说，自己是一套空的工程，它为插件提供了CSS数据， 根据配置的不同插件， 产生不同的功能]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手摸手AngularJs入门教程]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%89%8B%E6%91%B8%E6%89%8BAngularJs%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[AngularJs 是一款来自Google 的前端JavaScript框架， 也是SPA框架。 AngularJs框架的体积非常小， 但是设计理念和功能却非常强大， 极大地简化前端开发的负担， 它快速成为了JavaScript的主流框架， 帮助开发者从事web开发。 这里我们用AngularJs7的练手吧 起步 请确保电脑已安装了Node.js 首先是全局安装脚手架1npm install -g @angular/cli 安装好后查看一下版本 ng –version 确认ng命令存在后就可以开始创建我们的第一个 Angular 项目了12# 创建项目 project 替换为你的项目名称ng new project 当你输入命令后他会问你需要的配置， 这里附上我的选择， 大家可以参照 你是否需要添加路由？ —- yes 选择你喜欢的css 风格 —- SCSS 选择好后， 就会进入漫长的安装了 安装好后， cd 进入到项目所在的目录， 运行 ng serve 命令， 并打开http://localhost:4200/ 查看我们第一个 Angular项目12345678# 进入你的项目目录cd project# 启动项目ng serve# 如果你需要 可以生产环境运行ng serve --prod --aot 基本的路由配置 如果你不知道路由是什么， 你只需要先理解路由帮助我们实现切换页面的功能因为之前我们在构建项目时就选择了加入路由， 因此也省去了很多配置过程， 现在，我们来看看怎么用吧， 首先想使用路由， 得需要再创建一个”页面”（这里指组件）， 这样才能通过切换看出是否实现了路由， 那如何创建一个组件呢？ Angular 给我们提供了非常多的创建命令， 组件也可以一键的生成 我们来创建一个 Demo 组件 ng g c Demo 等待片刻， 安装好后 我们发现项目文件中的 app 目录下多了一个文件夹 里面有配套的 模板文件 样式文件 测试文件 ts 脚本文件 既然有了组件， 那我们现在需要为这个路由分配相应的访问路径 进入 app/app-routing.module.ts 这个文件 我们首先导入刚刚创建的Demo组件， 再 routes数组中，分配一个用于访问的path, 并和导入的DemoComponent关联上 如下: 123456789101112131415161718192021// ------------新增区域------------import &#123; DemoComponent &#125; from './demo/demo.component';// ------------新增区域------------import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ // -----------新增区域------------- &#123; path: "demo", component: DemoComponent &#125; // ------------新增区域------------];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; 然后进入 app/app.component.html 文件中找到 &lt;router-outlet&gt;&lt;/router-outlet&gt; 刚才配置的路由就会显示在这个标签所在的位置，为了减少一点干扰，我们把没有用的信息删除 !component19html切换后](http://img.nixiaolei.com/2019-03--17-17-27-25.png app.我只留了一张图片, 然后我们进入 app/demo/demo.component.html 文件中 原本是123&lt;p&gt; demo works!&lt;/p&gt; 我们改成明显一点的内容 千万注意dom结构别错了， dom结构错误会造成白屏，坑的是没有错误信息 123&lt;div&gt; &lt;h1&gt;我是Demo 页面&lt;/h1&gt;&lt;/div&gt; 我们看看是否配置成功了 首先，刚进入， 只有一张图片 让我们切换至/demo 我们可以看到， 刚刚为demo组件编写的文字成功显示出来了， 并且是位于图片下方， 这跟我们之前 app/app.component.html 中所做的配置一样 ——————–待完善————————- 常用的命令 把 XXX 替换成你要的名字 ng g cl xxx // 创建一个新类 ng g c xxx // 创建一个新组件 ng g d xxx // 创建一个新指令 ng g e xxx // 创建一个新枚举 ng g m xxx // 创建一个新模块 ng g p xxx // 创建一个新管道 ng g s xxx // 创建一个新的指服务 参考文献 https://github.com/angular/angular-cli/wiki]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中如何使用本地图片]]></title>
    <url>%2F2019%2F03%2F16%2Fhexo%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[首先需要修改_config.yml配置文件post_asset_folder项为true 使用命令创建博客1hexo new 你的文章名称 他会生成.md文件及一个对应的文件夹， 我们将图片放到该文件夹中 方法一在文章中这样插入图片1&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125; 效果如下: 方法二 这个方法在首页无法正常预览图片 安装一下这个插件 1npm install hexo-asset-image --save 在文章中这样插入图片1![这是一张图片](xxxx.png) 效果如下: 参考文献 http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
